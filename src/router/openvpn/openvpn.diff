diff -urN openvpn-2.1_rc7/COPYING openvpn-2.1_rc9/COPYING
--- openvpn-2.1_rc7/COPYING	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/COPYING	2008-07-14 20:49:15.000000000 +0200
@@ -1,6 +1,6 @@
 OpenVPN (TM) -- An Open Source VPN daemon
 
-Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
 
 This distribution contains multiple components, some
 of which fall under different licenses.  By using OpenVPN
@@ -11,7 +11,7 @@
 OpenVPN trademark
 -----------------
 
-  "OpenVPN" is a trademark of OpenVPN Solutions LLC.
+  "OpenVPN" is a trademark of Telethra, Inc.
 
 
 OpenVPN license:
@@ -21,7 +21,7 @@
 
   Special exception for linking OpenVPN with OpenSSL:
 
-  In addition, as a special exception, OpenVPN Solutions LLC gives
+  In addition, as a special exception, Telethra, Inc. gives
   permission to link the code of this program with the OpenSSL
   library (or with modified versions of OpenSSL that use the same
   license as OpenSSL), and distribute linked combinations including
@@ -52,9 +52,9 @@
   Damion K. Wilson.
 
   The source and object code of the TAP-Win32/TAP-Win64 driver
-  is Copyright (C) 2002-2007 OpenVPN Solutions LLC, and is released under
+  is Copyright (C) 2002-2008 Telethra, Inc., and is released under
   the GPL version 2 (see below), however due to the extra costs of
-  supporting Windows Vista, OpenVPN Solutions LLC reserves the right to
+  supporting Windows Vista, Telethra, Inc. reserves the right to
   change the terms of the TAP-Win32/TAP-Win64 license for versions 9.1
   and higher prior to the official release of OpenVPN 2.1.
 
diff -urN openvpn-2.1_rc7/ChangeLog openvpn-2.1_rc9/ChangeLog
--- openvpn-2.1_rc7/ChangeLog	2008-01-30 01:37:18.000000000 +0100
+++ openvpn-2.1_rc9/ChangeLog	2008-08-01 00:03:37.000000000 +0200
@@ -1,7 +1,100 @@
 OpenVPN
-Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
 
-$Id: ChangeLog 2702 2008-01-30 00:37:54Z james $
+$Id: ChangeLog 3149 2008-07-31 22:03:38Z james $
+
+2008.07.31 -- Version 2.1_rc9
+
+* Security Vulnerability -- affects non-Windows OpenVPN clients running
+  OpenVPN 2.1-beta14 through 2.1-rc8 (OpenVPN 2.0.x clients are NOT
+  vulnerable nor are any versions of the OpenVPN server vulnerable).
+  An OpenVPN client connecting to a malicious or compromised
+  server could potentially receive an "lladdr" or "iproute" configuration
+  directive from the server which could cause arbitrary code execution on
+  the client. A successful attack requires that (a) the client has agreed
+  to allow the server to push configuration directives to it by including
+  "pull" or the macro "client" in its configuration file, (b) the client
+  succesfully authenticates the server, (c) the server is malicious or has
+  been compromised and is under the control of the attacker, and (d) the
+  client is running a non-Windows OS.  Credit: David Wagner.
+
+* Miscellaneous defensive programming changes to multiple
+  areas of the code.  In particular, use of the system() call
+  for calling executables such as ifconfig, route, and
+  user-defined scripts has been completely revamped in favor
+  of execve() on unix and CreateProcess() on Windows.
+
+* In Windows build, package a statically linked openssl.exe to work around
+  observed instabilities in the dynamic build since the migration to
+  OpenSSL 0.9.8h.
+
+2008.06.11 -- Version 2.1_rc8
+
+* Added client authentication and packet filtering capability
+  to management interface.  In addition, allow OpenVPN plugins
+  to take advantage of deferred authentication and packet
+  filtering capability.
+
+* Added support for client-side connection profiles.
+
+* Fixed unbounded memory growth bug in environmental variable
+  code that could have caused long-running OpenVPN sessions
+  with many TLS renegotiations to incrementally
+  increase memory usage over time.
+
+* Windows release now packages openssl-0.9.8h.
+
+* Build system changes -- allow building on Windows using
+  autoconf/automake scripts (Alon Bar-Lev).
+
+* Changes to Windows build system to make it easier to do
+  partial builds, with a reduced set of prerequisites,
+  where only a subset of OpenVPN installer
+  components are built.  See ./domake-win comments.
+
+* Cleanup IP address for persistence interfaces for tap and also
+  using ifconfig, gentoo#209055 (Alon Bar-Lev).
+
+* Fall back to old version of extract_x509_field for OpenSSL 0.9.6.
+
+* Clarified tcp-queue-limit man page entry (Matti Linnanvuori).
+
+* Added new OpenVPN icon and installer graphic.
+
+* Minor pkitool changes.
+
+* Added --pkcs11-id-management option, which will cause OpenVPN to
+  query the management interface via the new NEED-STR asynchronous
+  notification query to get additional PKCS#11 options (Alon Bar-Lev).
+
+* Added NEED-STR management interface asynchronous query and
+  "needstr" management interface command to respond to the query
+  (Alon Bar-Lev).
+
+* Added Dragonfly BSD support (Francis-Gudin).
+
+* Quote device names before passing to up/down script (Josh Cepek).
+
+* Bracketed struct openvpn_pktinfo with #pragma pack(1) to
+  prevent structure padding from causing an incorrect length
+  to be returned by sizeof (struct openvpn_pktinfo) on 64-bit
+  platforms.
+
+* On systems that support res_init, always call it
+  before calling gethostbyname to ensure that
+  resolver configuration state is current.
+
+* Added NTLMv2 proxy support (Miroslav Zajic).
+
+* Fixed an issue in extract_x509_field_ssl where the extraction
+  would fail on the first field of the subject name, such as
+  the common name in:  /CN=foo/emailAddress=foo@bar.com
+
+* Made "Linux ip addr del failed" error nonfatal.
+
+* Amplified --client-cert-not-required warning.
+
+* Added #pragma pack to proto.h.
 
 2008.01.29 -- Version 2.1_rc7
 
diff -urN openvpn-2.1_rc7/INSTALL openvpn-2.1_rc9/INSTALL
--- openvpn-2.1_rc7/INSTALL	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/INSTALL	2008-07-14 20:37:55.000000000 +0200
@@ -1,6 +1,6 @@
 Installation instructions for OpenVPN, a Secure Tunneling Daemon
 
-Copyright (C) 2002-2005 OpenVPN Solutions LLC. This program is free software;
+Copyright (C) 2002-2008 Telethra, Inc. This program is free software;
 you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2
 as published by the Free Software Foundation.
diff -urN openvpn-2.1_rc7/Makefile.am openvpn-2.1_rc9/Makefile.am
--- openvpn-2.1_rc7/Makefile.am	2008-01-25 01:55:17.000000000 +0100
+++ openvpn-2.1_rc9/Makefile.am	2008-07-14 20:49:16.000000000 +0200
@@ -5,7 +5,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+#  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
@@ -22,18 +22,55 @@
 #  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 #
 
+LDADD = @LIBOBJS@
+.PHONY: plugin
+
 # This option prevents autoreconf from overriding our COPYING and
 # INSTALL targets:
 AUTOMAKE_OPTIONS = foreign
 
-sbin_PROGRAMS = openvpn
+MAINTAINERCLEANFILES = \
+	config.log config.status \
+	$(srcdir)/Makefile.in \
+	$(srcdir)/config.h.in $(srcdir)/config.h.in~ $(srcdir)/configure \
+	$(srcdir)/install-sh $(srcdir)/ltmain.sh $(srcdir)/missing \
+	$(srcdir)/depcomp $(srcdir)/aclocal.m4 \
+	$(srcdir)/config.guess $(srcdir)/config.sub \
+	$(srcdir)/config-win32.h $(srcdir)/openvpn.spec
+CLEANFILES = openvpn.8.html
 
-nodist_openvpn_SOURCES = config.h
+EXTRA_DIST = \
+	easy-rsa \
+	sample-config-files \
+	sample-keys \
+	sample-scripts \
+	suse \
+	tap-win32 \
+	contrib \
+	debug \
+	plugin
+
+SUBDIRS = \
+	images \
+	service-win32 \
+	install-win32
 
 TESTS = t_lpback.sh t_cltsrv.sh
-dist_noinst_SCRIPTS = $(TESTS)
+sbin_PROGRAMS = openvpn
 
-.PHONY: plugin
+dist_noinst_HEADERS = \
+	config-win32.h
+
+dist_noinst_SCRIPTS = \
+	$(TESTS) \
+	doclean \
+	domake-win
+
+dist_noinst_DATA = \
+	openvpn.spec \
+	COPYRIGHT.GPL \
+	PORTS \
+	INSTALL-win32.txt
 
 openvpn_SOURCES = \
         base64.c base64.h \
@@ -75,11 +112,13 @@
 	otime.c otime.h \
 	packet_id.c packet_id.h \
 	perf.c perf.h \
+	pf.c pf.h pf-inline.h \
 	ping.c ping.h ping-inline.h \
 	plugin.c plugin.h \
 	pool.c pool.h \
 	proto.c proto.h \
 	proxy.c proxy.h \
+	ieproxy.h ieproxy.c \
         ps.c ps.h \
 	push.c push.h \
 	reliable.c reliable.h \
@@ -94,44 +133,19 @@
 	status.c status.h \
 	syshead.h \
 	thread.c thread.h \
-	tun.c tun.h
-
-LDADD = @LIBOBJS@
-
-man_MANS = openvpn.8
+	tun.c tun.h \
+	win32.h win32.c \
+	cryptoapi.h cryptoapi.c
 
-EXTRA_DIST = \
-	doclean \
-	$(man_MANS) \
-	COPYRIGHT.GPL \
-	PORTS \
-	openvpn.spec \
-	easy-rsa \
-	sample-config-files \
-	sample-keys \
-	sample-scripts \
-	gentoo \
-	suse \
-	openvpn.spec.in \
-	config-win32.h \
-	win32.h \
-	win32.c \
-	cryptoapi.h \
-	cryptoapi.c \
-	makefile.w32 \
-        makefile.w32-vc \
-	INSTALL-win32.txt \
-	tap-win32 \
-	install-win32 \
-	service-win32 \
-	contrib \
-	debug \
-	plugin \
-        management \
-	images \
-	ieproxy.c \
-	ieproxy.h \
-	domake-win
 
 dist-hook:
 	cd $(distdir) && for i in $(EXTRA_DIST) ; do find $$i -name .svn -type d -prune -exec rm -rf '{}' ';' ; rm -f `find $$i -type f | grep -E '(^|\/)\.?\#|\~$$|\.s?o$$'` ; done
+
+if WIN32
+dist_noinst_DATA += openvpn.8
+nodist_html_DATA = openvpn.8.html
+openvpn.8.html: $(srcdir)/openvpn.8
+	$(MAN2HTML) < $(srcdir)/openvpn.8 > openvpn.8.html
+else
+dist_man_MANS = openvpn.8
+endif
diff -urN openvpn-2.1_rc7/Makefile.in openvpn-2.1_rc9/Makefile.in
--- openvpn-2.1_rc7/Makefile.in	2008-01-30 00:55:46.000000000 +0100
+++ openvpn-2.1_rc9/Makefile.in	2008-07-31 19:45:21.000000000 +0200
@@ -21,7 +21,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+#  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
@@ -39,6 +39,8 @@
 #
 
 
+
+
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
@@ -63,11 +65,15 @@
 host_triplet = @host@
 target_triplet = @target@
 sbin_PROGRAMS = openvpn$(EXEEXT)
-DIST_COMMON = README $(am__configure_deps) $(dist_noinst_SCRIPTS) \
+@WIN32_TRUE@am__append_1 = openvpn.8
+DIST_COMMON = README $(am__configure_deps) \
+	$(am__dist_noinst_DATA_DIST) $(dist_man_MANS) \
+	$(dist_noinst_HEADERS) $(dist_noinst_SCRIPTS) \
 	$(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(srcdir)/config.h.in $(srcdir)/openvpn.spec.in \
-	$(top_srcdir)/configure AUTHORS COPYING ChangeLog INSTALL NEWS \
-	config.guess config.sub depcomp install-sh memcmp.c missing
+	$(srcdir)/config-win32.h.in $(srcdir)/config.h.in \
+	$(srcdir)/openvpn.spec.in $(top_srcdir)/configure AUTHORS \
+	COPYING ChangeLog INSTALL NEWS config.guess config.sub depcomp \
+	install-sh memcmp.c missing
 subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
@@ -78,8 +84,9 @@
  configure.lineno configure.status.lineno
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = config.h
-CONFIG_CLEAN_FILES = openvpn.spec
-am__installdirs = "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(man8dir)"
+CONFIG_CLEAN_FILES = openvpn.spec config-win32.h
+am__installdirs = "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(man8dir)" \
+	"$(DESTDIR)$(htmldir)"
 sbinPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
 PROGRAMS = $(sbin_PROGRAMS)
 am_openvpn_OBJECTS = base64.$(OBJEXT) buffer.$(OBJEXT) \
@@ -92,14 +99,14 @@
 	mudp.$(OBJEXT) multi.$(OBJEXT) ntlm.$(OBJEXT) occ.$(OBJEXT) \
 	pkcs11.$(OBJEXT) openvpn.$(OBJEXT) options.$(OBJEXT) \
 	otime.$(OBJEXT) packet_id.$(OBJEXT) perf.$(OBJEXT) \
-	ping.$(OBJEXT) plugin.$(OBJEXT) pool.$(OBJEXT) proto.$(OBJEXT) \
-	proxy.$(OBJEXT) ps.$(OBJEXT) push.$(OBJEXT) reliable.$(OBJEXT) \
-	route.$(OBJEXT) schedule.$(OBJEXT) session_id.$(OBJEXT) \
-	shaper.$(OBJEXT) sig.$(OBJEXT) socket.$(OBJEXT) \
-	socks.$(OBJEXT) ssl.$(OBJEXT) status.$(OBJEXT) \
-	thread.$(OBJEXT) tun.$(OBJEXT)
-nodist_openvpn_OBJECTS =
-openvpn_OBJECTS = $(am_openvpn_OBJECTS) $(nodist_openvpn_OBJECTS)
+	pf.$(OBJEXT) ping.$(OBJEXT) plugin.$(OBJEXT) pool.$(OBJEXT) \
+	proto.$(OBJEXT) proxy.$(OBJEXT) ieproxy.$(OBJEXT) ps.$(OBJEXT) \
+	push.$(OBJEXT) reliable.$(OBJEXT) route.$(OBJEXT) \
+	schedule.$(OBJEXT) session_id.$(OBJEXT) shaper.$(OBJEXT) \
+	sig.$(OBJEXT) socket.$(OBJEXT) socks.$(OBJEXT) ssl.$(OBJEXT) \
+	status.$(OBJEXT) thread.$(OBJEXT) tun.$(OBJEXT) \
+	win32.$(OBJEXT) cryptoapi.$(OBJEXT)
+openvpn_OBJECTS = $(am_openvpn_OBJECTS)
 openvpn_LDADD = $(LDADD)
 openvpn_DEPENDENCIES = @LIBOBJS@
 SCRIPTS = $(dist_noinst_SCRIPTS)
@@ -110,13 +117,31 @@
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(openvpn_SOURCES) $(nodist_openvpn_SOURCES)
+SOURCES = $(openvpn_SOURCES)
 DIST_SOURCES = $(openvpn_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
 man8dir = $(mandir)/man8
 NROFF = nroff
-MANS = $(man_MANS)
+MANS = $(dist_man_MANS)
+am__dist_noinst_DATA_DIST = openvpn.spec COPYRIGHT.GPL PORTS \
+	INSTALL-win32.txt openvpn.8
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+nodist_htmlDATA_INSTALL = $(INSTALL_DATA)
+DATA = $(dist_noinst_DATA) $(nodist_html_DATA)
+HEADERS = $(dist_noinst_HEADERS)
 ETAGS = etags
 CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
 top_distdir = $(distdir)
@@ -161,6 +186,7 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
+MAN2HTML = @MAN2HTML@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -176,7 +202,12 @@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
+TAP_ID = @TAP_ID@
+TAP_WIN32_MIN_MAJOR = @TAP_WIN32_MIN_MAJOR@
+TAP_WIN32_MIN_MINOR = @TAP_WIN32_MIN_MINOR@
 VERSION = @VERSION@
+WIN32_FALSE = @WIN32_FALSE@
+WIN32_TRUE = @WIN32_TRUE@
 ac_ct_CC = @ac_ct_CC@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
@@ -224,13 +255,49 @@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
+win32datadir = @win32datadir@
+LDADD = @LIBOBJS@
 
 # This option prevents autoreconf from overriding our COPYING and
 # INSTALL targets:
 AUTOMAKE_OPTIONS = foreign
-nodist_openvpn_SOURCES = config.h
+MAINTAINERCLEANFILES = \
+	config.log config.status \
+	$(srcdir)/Makefile.in \
+	$(srcdir)/config.h.in $(srcdir)/config.h.in~ $(srcdir)/configure \
+	$(srcdir)/install-sh $(srcdir)/ltmain.sh $(srcdir)/missing \
+	$(srcdir)/depcomp $(srcdir)/aclocal.m4 \
+	$(srcdir)/config.guess $(srcdir)/config.sub \
+	$(srcdir)/config-win32.h $(srcdir)/openvpn.spec
+
+CLEANFILES = openvpn.8.html
+EXTRA_DIST = \
+	easy-rsa \
+	sample-config-files \
+	sample-keys \
+	sample-scripts \
+	suse \
+	tap-win32 \
+	contrib \
+	debug \
+	plugin
+
+SUBDIRS = \
+	images \
+	service-win32 \
+	install-win32
+
 TESTS = t_lpback.sh t_cltsrv.sh
-dist_noinst_SCRIPTS = $(TESTS)
+dist_noinst_HEADERS = \
+	config-win32.h
+
+dist_noinst_SCRIPTS = \
+	$(TESTS) \
+	doclean \
+	domake-win
+
+dist_noinst_DATA = openvpn.spec COPYRIGHT.GPL PORTS INSTALL-win32.txt \
+	$(am__append_1)
 openvpn_SOURCES = \
         base64.c base64.h \
 	basic.h \
@@ -271,11 +338,13 @@
 	otime.c otime.h \
 	packet_id.c packet_id.h \
 	perf.c perf.h \
+	pf.c pf.h pf-inline.h \
 	ping.c ping.h ping-inline.h \
 	plugin.c plugin.h \
 	pool.c pool.h \
 	proto.c proto.h \
 	proxy.c proxy.h \
+	ieproxy.h ieproxy.c \
         ps.c ps.h \
 	push.c push.h \
 	reliable.c reliable.h \
@@ -290,45 +359,14 @@
 	status.c status.h \
 	syshead.h \
 	thread.c thread.h \
-	tun.c tun.h
-
-LDADD = @LIBOBJS@
-man_MANS = openvpn.8
-EXTRA_DIST = \
-	doclean \
-	$(man_MANS) \
-	COPYRIGHT.GPL \
-	PORTS \
-	openvpn.spec \
-	easy-rsa \
-	sample-config-files \
-	sample-keys \
-	sample-scripts \
-	gentoo \
-	suse \
-	openvpn.spec.in \
-	config-win32.h \
-	win32.h \
-	win32.c \
-	cryptoapi.h \
-	cryptoapi.c \
-	makefile.w32 \
-        makefile.w32-vc \
-	INSTALL-win32.txt \
-	tap-win32 \
-	install-win32 \
-	service-win32 \
-	contrib \
-	debug \
-	plugin \
-        management \
-	images \
-	ieproxy.c \
-	ieproxy.h \
-	domake-win
+	tun.c tun.h \
+	win32.h win32.c \
+	cryptoapi.h cryptoapi.c
 
+@WIN32_TRUE@nodist_html_DATA = openvpn.8.html
+@WIN32_FALSE@dist_man_MANS = openvpn.8
 all: config.h
-	$(MAKE) $(AM_MAKEFLAGS) all-am
+	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
@@ -384,6 +422,8 @@
 	-rm -f config.h stamp-h1
 openvpn.spec: $(top_builddir)/config.status $(srcdir)/openvpn.spec.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
+config-win32.h: $(top_builddir)/config.status $(srcdir)/config-win32.h.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
 install-sbinPROGRAMS: $(sbin_PROGRAMS)
 	@$(NORMAL_INSTALL)
 	test -z "$(sbindir)" || $(mkdir_p) "$(DESTDIR)$(sbindir)"
@@ -421,6 +461,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/base64.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/buffer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/crypto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cryptoapi.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/error.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/event.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fdmisc.Po@am__quote@
@@ -428,6 +469,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fragment.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gremlin.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/helper.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ieproxy.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/init.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interval.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/list.Po@am__quote@
@@ -449,6 +491,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/otime.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/packet_id.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/perf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ping.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pkcs11.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plugin.Po@am__quote@
@@ -469,6 +512,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/status.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tun.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win32.Po@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
@@ -529,6 +573,94 @@
 	  echo " rm -f '$(DESTDIR)$(man8dir)/$$inst'"; \
 	  rm -f "$(DESTDIR)$(man8dir)/$$inst"; \
 	done
+install-nodist_htmlDATA: $(nodist_html_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(mkdir_p) "$(DESTDIR)$(htmldir)"
+	@list='$(nodist_html_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(nodist_htmlDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'"; \
+	  $(nodist_htmlDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(htmldir)/$$f"; \
+	done
+
+uninstall-nodist_htmlDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(nodist_html_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(htmldir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(htmldir)/$$f"; \
+	done
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -540,10 +672,23 @@
 	mkid -fID $$unique
 tags: TAGS
 
-TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
 	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
@@ -556,7 +701,7 @@
 	    $$tags $$unique; \
 	fi
 ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
@@ -654,7 +799,7 @@
 distdir: $(DISTFILES)
 	$(am__remove_distdir)
 	mkdir $(distdir)
-	$(mkdir_p) $(distdir)/.
+	$(mkdir_p) $(distdir)/. $(distdir)/install-win32
 	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
 	list='$(DISTFILES)'; for file in $$list; do \
@@ -681,6 +826,21 @@
 	    || exit 1; \
 	  fi; \
 	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
 	$(MAKE) $(AM_MAKEFLAGS) \
 	  top_distdir="$(top_distdir)" distdir="$(distdir)" \
 	  dist-hook
@@ -783,21 +943,23 @@
 	       exit 1; } >&2
 check-am: all-am
 	$(MAKE) $(AM_MAKEFLAGS) check-TESTS
-check: check-am
-all-am: Makefile $(PROGRAMS) $(SCRIPTS) $(MANS) config.h
-installdirs:
-	for dir in "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(man8dir)"; do \
+check: check-recursive
+all-am: Makefile $(PROGRAMS) $(SCRIPTS) $(MANS) $(DATA) $(HEADERS) \
+		config.h
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(man8dir)" "$(DESTDIR)$(htmldir)"; do \
 	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
 	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
 
 install-am: all-am
 	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
 
-installcheck: installcheck-am
+installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
 	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
@@ -806,6 +968,7 @@
 mostlyclean-generic:
 
 clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
 
 distclean-generic:
 	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
@@ -813,80 +976,89 @@
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
 	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+clean: clean-recursive
 
 clean-am: clean-generic clean-sbinPROGRAMS mostlyclean-am
 
-distclean: distclean-am
+distclean: distclean-recursive
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
 	-rm -rf $(DEPDIR) ./$(DEPDIR)
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-hdr distclean-tags
 
-dvi: dvi-am
+dvi: dvi-recursive
 
 dvi-am:
 
-html: html-am
+html: html-recursive
 
-info: info-am
+info: info-recursive
 
 info-am:
 
-install-data-am: install-man
+install-data-am: install-man install-nodist_htmlDATA
 
 install-exec-am: install-sbinPROGRAMS
 
-install-info: install-info-am
+install-info: install-info-recursive
 
 install-man: install-man8
 
 installcheck-am:
 
-maintainer-clean: maintainer-clean-am
+maintainer-clean: maintainer-clean-recursive
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
 	-rm -rf $(top_srcdir)/autom4te.cache
 	-rm -rf $(DEPDIR) ./$(DEPDIR)
 	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
-mostlyclean: mostlyclean-am
+mostlyclean: mostlyclean-recursive
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
-pdf: pdf-am
+pdf: pdf-recursive
 
 pdf-am:
 
-ps: ps-am
+ps: ps-recursive
 
 ps-am:
 
-uninstall-am: uninstall-info-am uninstall-man uninstall-sbinPROGRAMS
+uninstall-am: uninstall-info-am uninstall-man \
+	uninstall-nodist_htmlDATA uninstall-sbinPROGRAMS
+
+uninstall-info: uninstall-info-recursive
 
 uninstall-man: uninstall-man8
 
-.PHONY: CTAGS GTAGS all all-am am--refresh check check-TESTS check-am \
-	clean clean-generic clean-sbinPROGRAMS ctags dist dist-all \
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am am--refresh check \
+	check-TESTS check-am clean clean-generic clean-recursive \
+	clean-sbinPROGRAMS ctags ctags-recursive dist dist-all \
 	dist-bzip2 dist-gzip dist-hook dist-shar dist-tarZ dist-zip \
 	distcheck distclean distclean-compile distclean-generic \
-	distclean-hdr distclean-tags distcleancheck distdir \
-	distuninstallcheck dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-exec \
-	install-exec-am install-info install-info-am install-man \
-	install-man8 install-sbinPROGRAMS install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am uninstall-info-am uninstall-man uninstall-man8 \
+	distclean-hdr distclean-recursive distclean-tags \
+	distcleancheck distdir distuninstallcheck dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-man8 \
+	install-nodist_htmlDATA install-sbinPROGRAMS install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am uninstall-info-am \
+	uninstall-man uninstall-man8 uninstall-nodist_htmlDATA \
 	uninstall-sbinPROGRAMS
 
-
 .PHONY: plugin
 
 dist-hook:
 	cd $(distdir) && for i in $(EXTRA_DIST) ; do find $$i -name .svn -type d -prune -exec rm -rf '{}' ';' ; rm -f `find $$i -type f | grep -E '(^|\/)\.?\#|\~$$|\.s?o$$'` ; done
+@WIN32_TRUE@openvpn.8.html: $(srcdir)/openvpn.8
+@WIN32_TRUE@	$(MAN2HTML) < $(srcdir)/openvpn.8 > openvpn.8.html
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -urN openvpn-2.1_rc7/PORTS openvpn-2.1_rc9/PORTS
--- openvpn-2.1_rc7/PORTS	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/PORTS	2008-07-14 20:49:16.000000000 +0200
@@ -1,5 +1,5 @@
 OpenVPN
-Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
 
   OpenVPN has been written to try to avoid features
   that are not standardized well across different
diff -urN openvpn-2.1_rc7/README openvpn-2.1_rc9/README
--- openvpn-2.1_rc7/README	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/README	2008-07-14 20:37:56.000000000 +0200
@@ -1,6 +1,6 @@
 OpenVPN -- A Secure tunneling daemon
 
-Copyright (C) 2002-2005 OpenVPN Solutions LLC. This program is free software;
+Copyright (C) 2002-2008 Telethra, Inc. This program is free software;
 you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2
 as published by the Free Software Foundation.
diff -urN openvpn-2.1_rc7/acinclude.m4 openvpn-2.1_rc9/acinclude.m4
--- openvpn-2.1_rc7/acinclude.m4	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/acinclude.m4	2008-06-13 09:54:59.000000000 +0200
@@ -96,10 +96,19 @@
          for arg2 in "struct sockaddr" void; do
             for t in int size_t unsigned long "unsigned long"; do
                AC_TRY_COMPILE([
+                  #ifdef _WIN32
+                  #include <windows.h>
+                  #define PREFIX1 WINSOCK_API_LINKAGE
+                  #define PREFIX2 PASCAL
+                  #else
                   #include <sys/types.h>
                   #include <sys/socket.h>
+                  #define PREFIX1
+                  #define PREFIX2
+                  #define SOCKET int
+                  #endif
 
-                  int getpeername (int, $arg2 *, $t *);
+                  PREFIX1 int PREFIX2 getpeername (SOCKET, $arg2 *, $t *);
                ],[
                   $t len;
                   getpeername(0,0,&len);
diff -urN openvpn-2.1_rc7/base64.c openvpn-2.1_rc9/base64.c
--- openvpn-2.1_rc7/base64.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/base64.c	2008-07-26 08:18:08.000000000 +0200
@@ -31,15 +31,9 @@
  * SUCH DAMAGE.
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
-#ifdef ENABLE_HTTP_PROXY
+#if defined(ENABLE_HTTP_PROXY) || defined(ENABLE_PKCS11)
 
 #include "base64.h"
 
@@ -143,7 +137,7 @@
     return q - (unsigned char *) data;
 }
 
-#endif /* NTLM */
+#endif /* NTLM, PKCS#11 */
 
 #else
 static void dummy(void) {}
diff -urN openvpn-2.1_rc7/basic.h openvpn-2.1_rc9/basic.h
--- openvpn-2.1_rc7/basic.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/basic.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/buffer.c openvpn-2.1_rc9/buffer.c
--- openvpn-2.1_rc7/buffer.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/buffer.c	2008-07-27 05:43:22.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "common.h"
@@ -38,6 +32,22 @@
 
 #include "memdbg.h"
 
+size_t
+array_mult_safe (const size_t m1, const size_t m2)
+{
+  const size_t limit = 0xFFFFFFFF;
+  unsigned long long res = (unsigned long long)m1 * (unsigned long long)m2;
+  if (unlikely(m1 > limit) || unlikely(m2 > limit) || unlikely(res > (unsigned long long)limit))
+    msg (M_FATAL, "attemped allocation of excessively large array");
+  return (size_t) res;
+}
+
+void
+buf_size_error (size_t size)
+{
+  msg (M_FATAL, "fatal buffer size error, size=%lu", (unsigned long)size);
+}
+
 struct buffer
 #ifdef DMALLOC
 alloc_buf_debug (size_t size, const char *file, int line)
@@ -60,6 +70,8 @@
 #endif
 {
   struct buffer buf;
+  if (!buf_size_valid (size))
+    buf_size_error (size);
   buf.capacity = (int)size;
   buf.offset = 0;
   buf.len = 0;
@@ -178,9 +190,10 @@
 /*
  * printf append to a buffer with overflow check
  */
-void
+bool
 buf_printf (struct buffer *buf, const char *format, ...)
 {
+  int ret = false;
   if (buf_defined (buf))
     {
       va_list arglist;
@@ -189,13 +202,17 @@
 
       if (cap > 0)
 	{
+	  int stat;
 	  va_start (arglist, format);
-	  vsnprintf ((char *)ptr, cap, format, arglist);
+	  stat = vsnprintf ((char *)ptr, cap, format, arglist);
 	  va_end (arglist);
 	  *(buf->data + buf->capacity - 1) = 0; /* windows vsnprintf needs this */
 	  buf->len += (int) strlen ((char *)ptr);
+	  if (stat >= 0 && stat < cap)
+	    ret = true;
 	}
     }
+  return ret;
 }
 
 /*
@@ -218,6 +235,258 @@
 }
 
 /*
+ * A printf-like function (that only recognizes a subset of standard printf
+ * format operators) that prints arguments to an argv list instead
+ * of a standard string.  This is used to build up argv arrays for passing
+ * to execve.
+ */
+
+void
+argv_init (struct argv *a)
+{
+  a->argc = 0;
+  a->argv = NULL;
+}
+
+struct argv
+argv_new (void)
+{
+  struct argv ret;
+  argv_init (&ret);
+  return ret;
+}
+
+void
+argv_reset (struct argv *a)
+{
+  size_t i;
+  for (i = 0; i < a->argc; ++i)
+    free (a->argv[i]);
+  free (a->argv);
+  a->argc = 0;
+  a->argv = NULL;
+}
+
+size_t
+argv_argc (const char *format)
+{
+  char *term;
+  const char *f = format;
+  size_t argc = 0;
+
+  while ((term = argv_term (&f)) != NULL) 
+    {
+      ++argc;
+      free (term);
+    }
+  return argc;
+}
+
+struct argv
+argv_insert_head (const struct argv *a, const char *head)
+{
+  struct argv r;
+  size_t i;
+
+  r.argc = (a ? a->argc : 0) + 1;
+  ALLOC_ARRAY_CLEAR (r.argv, char *, r.argc + 1);
+  r.argv[0] = string_alloc (head, NULL);
+  if (a)
+    {
+      for (i = 0; i < a->argc; ++i)
+	r.argv[i+1] = string_alloc (a->argv[i], NULL);
+    }
+  return r;
+}
+
+char *
+argv_term (const char **f)
+{
+  const char *p = *f;
+  const char *term = NULL;
+  size_t termlen = 0;
+
+  if (*p == '\0')
+    return NULL;
+
+  while (true)
+    {
+      const int c = *p;
+      if (c == '\0')
+	break;
+      if (term)
+	{
+	  if (!isspace (c))
+	    ++termlen;
+	  else
+	    break;
+	}
+      else
+	{
+	  if (!isspace (c))
+	    {
+	      term = p;
+	      termlen = 1;
+	    }
+	}
+      ++p;
+    }
+  *f = p;
+
+  if (term)
+    {
+      char *ret;
+      ASSERT (termlen > 0);
+      ret = malloc (termlen + 1);
+      check_malloc_return (ret);
+      memcpy (ret, term, termlen);
+      ret[termlen] = '\0';
+      return ret;
+    }
+  else
+    return NULL;
+}
+
+const char *
+argv_str (const struct argv *a, struct gc_arena *gc, const unsigned int flags)
+{
+  if (a->argv)
+    return print_argv ((const char **)a->argv, gc, flags);
+  else
+    return "";
+}
+
+void
+argv_msg (const int msglev, const struct argv *a)
+{
+  struct gc_arena gc = gc_new ();
+  msg (msglev, "%s", argv_str (a, &gc, 0));
+  gc_free (&gc);
+}
+
+void
+argv_msg_prefix (const int msglev, const struct argv *a, const char *prefix)
+{
+  struct gc_arena gc = gc_new ();
+  msg (msglev, "%s: %s", prefix, argv_str (a, &gc, 0));
+  gc_free (&gc);
+}
+
+void
+argv_printf (struct argv *a, const char *format, ...)
+{
+  va_list arglist;
+  va_start (arglist, format);
+  argv_printf_arglist (a, format, 0, arglist);
+  va_end (arglist);
+ }
+
+void
+argv_printf_cat (struct argv *a, const char *format, ...)
+{
+  va_list arglist;
+  va_start (arglist, format);
+  argv_printf_arglist (a, format, APA_CAT, arglist);
+  va_end (arglist);
+}
+
+void
+argv_printf_arglist (struct argv *a, const char *format, const unsigned int flags, va_list arglist)
+{
+  char *term;
+  const char *f = format;
+  size_t argc = 0;
+
+  if (flags & APA_CAT)
+    {
+      char **old_argv = a->argv;
+      size_t i;
+      argc = a->argc;
+      a->argc += argv_argc (format);
+      ALLOC_ARRAY_CLEAR (a->argv, char *, a->argc + 1);
+      for (i = 0; i < argc; ++i)
+	a->argv[i] = old_argv[i];
+      free (old_argv);
+    }
+  else
+    {
+      argv_reset (a);
+      a->argc = argv_argc (format);
+      ALLOC_ARRAY_CLEAR (a->argv, char *, a->argc + 1);
+    }
+
+  while ((term = argv_term (&f)) != NULL) 
+    {
+      ASSERT (argc < a->argc);
+      if (term[0] == '%')
+	{
+	  if (!strcmp (term, "%s"))
+	    {
+	      char *s = va_arg (arglist, char *);
+	      if (!s)
+		s = "";
+	      a->argv[argc++] = string_alloc (s, NULL);
+	    }
+	  else if (!strcmp (term, "%d"))
+	    {
+	      char numstr[64];
+	      openvpn_snprintf (numstr, sizeof (numstr), "%d", va_arg (arglist, int));
+	      a->argv[argc++] = string_alloc (numstr, NULL);
+	    }
+	  else if (!strcmp (term, "%u"))
+	    {
+	      char numstr[64];
+	      openvpn_snprintf (numstr, sizeof (numstr), "%u", va_arg (arglist, unsigned int));
+	      a->argv[argc++] = string_alloc (numstr, NULL);
+	    }
+	  else if (!strcmp (term, "%s/%d"))
+	    {
+	      char numstr[64];
+	      char *s = va_arg (arglist, char *);
+
+	      if (!s)
+		s = "";
+
+	      openvpn_snprintf (numstr, sizeof (numstr), "%d", va_arg (arglist, int));
+
+	      {
+		const size_t len = strlen(s) + strlen(numstr) + 2;
+		char *combined = (char *) malloc (len);
+		check_malloc_return (combined);
+
+		strcpy (combined, s);
+		strcat (combined, "/");
+		strcat (combined, numstr);
+		a->argv[argc++] = combined;
+	      }
+	    }
+	  else if (!strcmp (term, "%s%s"))
+	    {
+	      char *s1 = va_arg (arglist, char *);
+	      char *s2 = va_arg (arglist, char *);
+	      char *combined;
+
+	      if (!s1) s1 = "";
+	      if (!s2) s2 = "";
+	      combined = (char *) malloc (strlen(s1) + strlen(s2) + 1);
+	      check_malloc_return (combined);
+	      strcpy (combined, s1);
+	      strcat (combined, s2);
+	      a->argv[argc++] = combined;
+	    }
+	  else
+	    ASSERT (0);
+	  free (term);
+	}
+      else
+	{
+	  a->argv[argc++] = term;
+	}
+    }
+  ASSERT (argc == a->argc);
+}
+
+/*
  * write a string to the end of a buffer that was
  * truncated by buf_printf
  */
@@ -321,6 +590,26 @@
 }
 
 /*
+ * Transfer src arena to dest, resetting src to an empty arena.
+ */
+void
+gc_transfer (struct gc_arena *dest, struct gc_arena *src)
+{
+  if (dest && src)
+    {
+      struct gc_entry *e = src->list;
+      if (e)
+	{
+	  while (e->next != NULL)
+	    e = e->next;
+	  e->next = dest->list;
+	  dest->list = src->list;
+	  src->list = NULL;
+	}
+    }
+}
+
+/*
  * Hex dump -- Output a binary buffer to a hex string and return it.
  */
 
@@ -430,6 +719,15 @@
 void
 chomp (char *str)
 {
+  rm_trailing_chars (str, "\r\n");
+}
+
+/*
+ * Remove trailing chars
+ */
+void
+rm_trailing_chars (char *str, const char *what_to_delete)
+{
   bool modified;
   do {
     const int len = strlen (str);
@@ -437,7 +735,7 @@
     if (len > 0)
       {
 	char *cp = str + (len - 1);
-	if (*cp == '\n' || *cp == '\r')
+	if (strchr (what_to_delete, *cp) != NULL)
 	  {
 	    *cp = '\0';
 	    modified = true;
@@ -771,6 +1069,20 @@
     return NULL;
 }
 
+void
+string_replace_leading (char *str, const char match, const char replace)
+{
+  ASSERT (match != '\0');
+  while (*str)
+    {
+      if (*str == match)
+	*str = replace;
+      else
+	break;
+      ++str;
+    }
+}
+
 #ifdef CHARACTER_CLASS_DEBUG
 
 #define CC_INCLUDE    (CC_PRINT)
@@ -816,3 +1128,130 @@
     }
 }
 #endif
+
+/*
+ * struct buffer_list
+ */
+
+#ifdef ENABLE_BUFFER_LIST
+
+struct buffer_list *
+buffer_list_new (const int max_size)
+{
+  struct buffer_list *ret;
+  ALLOC_OBJ_CLEAR (ret, struct buffer_list);
+  ret->max_size = max_size;
+  ret->size = 0;
+  return ret;
+}
+
+void
+buffer_list_free (struct buffer_list *ol)
+{
+  buffer_list_reset (ol);
+  free (ol);
+}
+
+bool
+buffer_list_defined (const struct buffer_list *ol)
+{
+  return ol->head != NULL;
+}
+
+void
+buffer_list_reset (struct buffer_list *ol)
+{
+  struct buffer_entry *e = ol->head;
+  while (e)
+    {
+      struct buffer_entry *next = e->next;
+      free_buf (&e->buf);
+      free (e);
+      e = next;
+    }
+  ol->head = ol->tail = NULL;
+  ol->size = 0;
+}
+
+void
+buffer_list_push (struct buffer_list *ol, const unsigned char *str)
+{
+  if (!ol->max_size || ol->size < ol->max_size)
+    {
+      struct buffer_entry *e;
+      ALLOC_OBJ_CLEAR (e, struct buffer_entry);
+
+      ++ol->size;
+      if (ol->tail)
+	{
+	  ASSERT (ol->head);
+	  ol->tail->next = e;
+	}
+      else
+	{
+	  ASSERT (!ol->head);
+	  ol->head = e;
+	}
+      e->buf = string_alloc_buf ((const char *) str, NULL);
+      ol->tail = e;
+    }
+}
+
+const struct buffer *
+buffer_list_peek (struct buffer_list *ol)
+{
+  if (ol->head)
+    return &ol->head->buf;
+  else
+    return NULL;
+}
+
+static void
+buffer_list_pop (struct buffer_list *ol)
+{
+  if (ol->head)
+    {
+      struct buffer_entry *e = ol->head->next;
+      free_buf (&ol->head->buf);
+      free (ol->head);
+      ol->head = e;
+      --ol->size;
+      if (!e)
+	ol->tail = NULL;
+    }
+}
+
+void
+buffer_list_advance (struct buffer_list *ol, int n)
+{
+  if (ol->head)
+    {
+      struct buffer *buf = &ol->head->buf;
+      ASSERT (buf_advance (buf, n));
+      if (!BLEN (buf))
+	buffer_list_pop (ol);
+    }
+}
+
+struct buffer_list *
+buffer_list_file (const char *fn, int max_line_len)
+{
+  FILE *fp = fopen (fn, "r");
+  struct buffer_list *bl = NULL;
+
+  if (fp)
+    {
+      char *line = (char *) malloc (max_line_len);
+      if (line)
+	{
+	  bl = buffer_list_new (0);
+	  while (fgets (line, max_line_len, fp) != NULL)
+	    buffer_list_push (bl, (unsigned char *)line);
+	  free (line);
+	}
+      fclose (fp);
+    }
+  return bl;
+}
+
+#endif
diff -urN openvpn-2.1_rc7/buffer.h openvpn-2.1_rc9/buffer.h
--- openvpn-2.1_rc7/buffer.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/buffer.h	2008-07-27 06:45:31.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -28,6 +28,8 @@
 #include "basic.h"
 #include "thread.h"
 
+#define BUF_SIZE_MAX 1000000
+
 /*
  * Define verify_align function, otherwise
  * it will be a noop.
@@ -56,6 +58,12 @@
 #endif
 };
 
+/* used by argv_x functions */
+struct argv {
+  size_t argc;
+  char **argv;
+};
+
 /* for garbage collection */
 
 struct gc_entry
@@ -68,12 +76,12 @@
   struct gc_entry *list;
 };
 
-#define BPTR(buf)  ((buf)->data + (buf)->offset)
-#define BEND(buf)  (BPTR(buf) + (buf)->len)
-#define BLAST(buf) (((buf)->data && (buf)->len) ? (BPTR(buf) + (buf)->len - 1) : NULL)
-#define BLEN(buf)  ((buf)->len)
-#define BDEF(buf)  ((buf)->data != NULL)
-#define BSTR(buf)  ((char *)BPTR(buf))
+#define BPTR(buf)  (buf_bptr(buf))
+#define BEND(buf)  (buf_bend(buf))
+#define BLAST(buf) (buf_blast(buf))
+#define BLEN(buf)  (buf_len(buf))
+#define BDEF(buf)  (buf_defined(buf))
+#define BSTR(buf)  (buf_str(buf))
 #define BCAP(buf)  (buf_forward_capacity (buf))
 
 void buf_clear (struct buffer *buf);
@@ -86,9 +94,13 @@
 void string_clear (char *str);
 int string_array_len (const char **array);
 
+size_t array_mult_safe (const size_t m1, const size_t m2);
+
 #define PA_BRACKET (1<<0)
 char *print_argv (const char **p, struct gc_arena *gc, const unsigned int flags);
 
+void buf_size_error (const size_t size);
+
 /* for dmalloc debugging */
 
 #ifdef DMALLOC
@@ -128,6 +140,69 @@
 
 /* inline functions */
 
+static inline bool
+buf_defined (const struct buffer *buf)
+{
+  return buf->data != NULL;
+}
+
+static inline bool
+buf_valid (const struct buffer *buf)
+{
+  return likely (buf->data != NULL) && likely (buf->len >= 0);
+}
+
+static inline uint8_t *
+buf_bptr (const struct buffer *buf)
+{
+  if (buf_valid (buf))
+    return buf->data + buf->offset;
+  else
+    return NULL;
+}
+
+static int
+buf_len (const struct buffer *buf)
+{
+  if (buf_valid (buf))
+    return buf->len;
+  else
+    return 0;
+}
+
+static inline uint8_t *
+buf_bend (const struct buffer *buf)
+{
+  return buf_bptr (buf) + buf_len (buf);
+}
+
+static inline uint8_t *
+buf_blast (const struct buffer *buf)
+{
+  if (buf_len (buf) > 0)
+    return buf_bptr (buf) + buf_len (buf) - 1;
+  else
+    return NULL;
+}
+
+static inline bool
+buf_size_valid (const size_t size)
+{
+  return likely (size < BUF_SIZE_MAX);
+}
+
+static inline bool
+buf_size_valid_signed (const int size)
+{
+  return likely (size >= -BUF_SIZE_MAX) && likely (size < BUF_SIZE_MAX);
+}
+
+static inline char *
+buf_str (const struct buffer *buf)
+{
+  return (char *)buf_bptr(buf);
+}
+
 static inline void
 buf_reset (struct buffer *buf)
 {
@@ -137,6 +212,13 @@
   buf->data = NULL;
 }
 
+static inline void
+buf_reset_len (struct buffer *buf)
+{
+  buf->len = 0;
+  buf->offset = 0;
+}
+
 static inline bool
 buf_init_dowork (struct buffer *buf, int offset)
 {
@@ -147,15 +229,11 @@
   return true;
 }
 
-static inline bool
-buf_defined (struct buffer *buf)
-{
-  return buf->data != NULL;
-}
-
 static inline void
 buf_set_write (struct buffer *buf, uint8_t *data, int size)
 {
+  if (!buf_size_valid (size))
+    buf_size_error (size);
   buf->len = 0;
   buf->offset = 0;
   buf->capacity = size;
@@ -167,6 +245,8 @@
 static inline void
 buf_set_read (struct buffer *buf, const uint8_t *data, int size)
 {
+  if (!buf_size_valid (size))
+    buf_size_error (size);
   buf->len = buf->capacity = size;
   buf->offset = 0;
   buf->data = (uint8_t *)data;
@@ -197,7 +277,7 @@
 /*
  * printf append to a buffer with overflow check
  */
-void buf_printf (struct buffer *buf, const char *format, ...)
+bool buf_printf (struct buffer *buf, const char *format, ...)
 #ifdef __GNUC__
     __attribute__ ((format (printf, 2, 3)))
 #endif
@@ -213,6 +293,37 @@
     ;
 
 /*
+ * A printf-like function (that only recognizes a subset of standard printf
+ * format operators) that prints arguments to an argv list instead
+ * of a standard string.  This is used to build up argv arrays for passing
+ * to execve.
+ */
+void argv_init (struct argv *a);
+struct argv argv_new (void);
+void argv_reset (struct argv *a);
+size_t argv_argc (const char *format);
+char *argv_term (const char **f);
+const char *argv_str (const struct argv *a, struct gc_arena *gc, const unsigned int flags);
+struct argv argv_insert_head (const struct argv *a, const char *head);
+void argv_msg (const int msglev, const struct argv *a);
+void argv_msg_prefix (const int msglev, const struct argv *a, const char *prefix);
+
+#define APA_CAT (1<<0) /* concatentate onto existing struct argv list */
+void argv_printf_arglist (struct argv *a, const char *format, const unsigned int flags, va_list arglist);
+
+void argv_printf (struct argv *a, const char *format, ...)
+#ifdef __GNUC__
+  __attribute__ ((format (printf, 2, 3)))
+#endif
+  ;
+
+void argv_printf_cat (struct argv *a, const char *format, ...)
+#ifdef __GNUC__
+  __attribute__ ((format (printf, 2, 3)))
+#endif
+  ;
+
+/*
  * remove/add trailing characters
  */
 
@@ -224,6 +335,7 @@
  * non-buffer string functions
  */
 void chomp (char *str);
+void rm_trailing_chars (char *str, const char *what_to_delete);
 const char *skip_leading_whitespace (const char *str);
 void string_null_terminate (char *str, int len, int capacity);
 
@@ -275,38 +387,57 @@
 static inline bool
 buf_safe (const struct buffer *buf, int len)
 {
-  return len >= 0 && buf->offset + buf->len + len <= buf->capacity;
+  return buf_valid (buf) && buf_size_valid (len)
+    && buf->offset + buf->len + len <= buf->capacity;
 }
 
 static inline bool
 buf_safe_bidir (const struct buffer *buf, int len)
 {
-  const int newlen = buf->len + len;
-  return newlen >= 0 && buf->offset + newlen <= buf->capacity;
+  if (buf_valid (buf) && buf_size_valid_signed (len))
+    {
+      const int newlen = buf->len + len;
+      return newlen >= 0 && buf->offset + newlen <= buf->capacity;
+    }
+  else
+    return false;
 }
 
 static inline int
 buf_forward_capacity (const struct buffer *buf)
 {
-  int ret = buf->capacity - (buf->offset + buf->len);
-  if (ret < 0)
-    ret = 0;
-  return ret;
+  if (buf_valid (buf))
+    {
+      int ret = buf->capacity - (buf->offset + buf->len);
+      if (ret < 0)
+	ret = 0;
+      return ret;
+    }
+  else
+    return 0;
 }
 
 static inline int
 buf_forward_capacity_total (const struct buffer *buf)
 {
-  int ret = buf->capacity - buf->offset;
-  if (ret < 0)
-    ret = 0;
-  return ret;
+  if (buf_valid (buf))
+    {
+      int ret = buf->capacity - buf->offset;
+      if (ret < 0)
+	ret = 0;
+      return ret;
+    }
+  else
+    return 0;
 }
 
 static inline int
 buf_reverse_capacity (const struct buffer *buf)
 {
-  return buf->offset;
+  if (buf_valid (buf))
+    return buf->offset;
+  else
+    return 0;
 }
 
 static inline bool
@@ -326,7 +457,7 @@
 static inline uint8_t *
 buf_prepend (struct buffer *buf, int size)
 {
-  if (size < 0 || size > buf->offset)
+  if (!buf_valid (buf) || size < 0 || size > buf->offset)
     return NULL;
   buf->offset -= size;
   buf->len += size;
@@ -336,7 +467,7 @@
 static inline bool
 buf_advance (struct buffer *buf, int size)
 {
-  if (size < 0 || buf->len < size)
+  if (!buf_valid (buf) || size < 0 || buf->len < size)
     return false;
   buf->offset += size;
   buf->len -= size;
@@ -605,6 +736,8 @@
 			      const char replace,
 			      struct gc_arena *gc);
 
+void string_replace_leading (char *str, const char match, const char replace);
+
 #ifdef CHARACTER_CLASS_DEBUG
 void character_class_debug (void);
 #endif
@@ -624,6 +757,8 @@
  * char ptrs to malloced strings.
  */
 
+void gc_transfer (struct gc_arena *dest, struct gc_arena *src);
+
 void x_gc_free (struct gc_arena *a);
 
 static inline void
@@ -678,23 +813,23 @@
 
 #define ALLOC_ARRAY(dptr, type, n) \
 { \
-  check_malloc_return ((dptr) = (type *) malloc (sizeof (type) * (n))); \
+  check_malloc_return ((dptr) = (type *) malloc (array_mult_safe (sizeof (type), (n)))); \
 }
 
 #define ALLOC_ARRAY_GC(dptr, type, n, gc) \
 { \
-  (dptr) = (type *) gc_malloc (sizeof (type) * (n), false, (gc)); \
+  (dptr) = (type *) gc_malloc (array_mult_safe (sizeof (type), (n)), false, (gc)); \
 }
 
 #define ALLOC_ARRAY_CLEAR(dptr, type, n) \
 { \
   ALLOC_ARRAY (dptr, type, n); \
-  memset ((dptr), 0, (sizeof(type) * (n))); \
+  memset ((dptr), 0, (array_mult_safe (sizeof(type), (n)))); \
 }
 
 #define ALLOC_ARRAY_CLEAR_GC(dptr, type, n, gc) \
 { \
-  (dptr) = (type *) gc_malloc (sizeof (type) * (n), true, (gc)); \
+  (dptr) = (type *) gc_malloc (array_mult_safe (sizeof (type), (n)), true, (gc)); \
 }
 
 #define ALLOC_OBJ_GC(dptr, type, gc) \
@@ -715,4 +850,38 @@
     out_of_memory ();
 }
 
+/*
+ * Manage lists of buffers
+ */
+
+#ifdef ENABLE_BUFFER_LIST
+
+struct buffer_entry
+{
+  struct buffer buf;
+  struct buffer_entry *next;
+};
+
+struct buffer_list
+{
+  struct buffer_entry *head; /* next item to pop/peek */
+  struct buffer_entry *tail; /* last item pushed */
+  int size;                  /* current number of entries */
+  int max_size;              /* maximum size list should grow to */
+};
+
+struct buffer_list *buffer_list_new (const int max_size);
+void buffer_list_free (struct buffer_list *ol);
+
+bool buffer_list_defined (const struct buffer_list *ol);
+void buffer_list_reset (struct buffer_list *ol);
+
+void buffer_list_push (struct buffer_list *ol, const unsigned char *str);
+const struct buffer *buffer_list_peek (struct buffer_list *ol);
+void buffer_list_advance (struct buffer_list *ol, int n);
+
+struct buffer_list *buffer_list_file (const char *fn, int max_line_len);
+
+#endif
+
 #endif /* BUFFER_H */
diff -urN openvpn-2.1_rc7/circ_list.h openvpn-2.1_rc9/circ_list.h
--- openvpn-2.1_rc7/circ_list.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/circ_list.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/common.h openvpn-2.1_rc9/common.h
--- openvpn-2.1_rc7/common.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/common.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/config-win32.h openvpn-2.1_rc9/config-win32.h
--- openvpn-2.1_rc7/config-win32.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/config-win32.h	2008-07-31 19:46:27.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -62,6 +62,7 @@
  *
  * The TAP-Win32 version number is defined in tap-win32/SOURCES
  */
+#define TAP_ID tap0901
 #define TAP_WIN32_MIN_MAJOR 9
 #define TAP_WIN32_MIN_MINOR 1
 
@@ -215,19 +216,19 @@
 #define HAVE_GETPASS 1
 
 /* Name of package */
-#define PACKAGE PRODUCT_UNIX_NAME
+#define PACKAGE openvpn
 
 /* Define to the address where bug reports for this package should be sent. */
 //#define PACKAGE_BUGREPORT "openvpn-users@lists.sourceforge.net"
 
 /* Define to the full name of this package. */
-#define PACKAGE_NAME PRODUCT_NAME
+#define PACKAGE_NAME OpenVPN
 
 /* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME PACKAGE
+#define PACKAGE_TARNAME openvpn
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION PRODUCT_VERSION
+#define PACKAGE_VERSION 2.1_rc9
 
 /* Define to the full name and version of this package. */
 #ifdef DEBUG_LABEL
@@ -318,4 +319,8 @@
 #define S_IWUSR 0
 typedef int intptr_t;
 #undef S_NORMAL
+/* Visual Studio 2005 supports vararg macros */
+#if _MSC_VER >= 1400
+#define HAVE_CPP_VARARG_MACRO_ISO 1
+#endif
 #endif
diff -urN openvpn-2.1_rc7/config-win32.h.in openvpn-2.1_rc9/config-win32.h.in
--- openvpn-2.1_rc7/config-win32.h.in	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/config-win32.h.in	2008-07-14 20:49:15.000000000 +0200
@@ -0,0 +1,326 @@
+/*
+ *  OpenVPN -- An application to securely tunnel IP networks
+ *             over a single UDP port, with support for SSL/TLS-based
+ *             session authentication and key exchange,
+ *             packet encryption, packet authentication, and
+ *             packet compression.
+ *
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program (see the file COPYING included with this
+ *  distribution); if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Configuration header for Win32 using the mingw environment.
+ * Manually edited based on linux version as generated by autoconf.
+ *
+ * config-win32.h is normally generated by copying
+ * config-win32.h.in -> config-win32.h and replacing
+ * [ampersand] VERSION [ampersand]
+ * with the appropriate version #.  This is normally
+ * done automatically by configure.ac
+ */
+
+#include <windows.h>
+#include <winsock2.h>
+#include "autodefs/defs.h"
+
+#define sleep(x) Sleep((x)*1000)
+
+#define random rand
+#define srandom srand
+
+typedef unsigned long in_addr_t;
+
+#ifndef _SSIZE_T_
+#define _SSIZE_T_
+ typedef unsigned int ssize_t;
+#endif
+
+/* Append a label to program startup title */
+/*#define DEBUG_LABEL "DEBUG1"*/
+
+/* Should we print debug info from driver? */
+#ifdef PRODUCT_TAP_DEBUG
+#define TAP_WIN32_DEBUG
+#endif
+
+/*
+ * Minimum TAP-Win32 version number expected by userspace
+ *
+ * The TAP-Win32 version number is defined in tap-win32/SOURCES
+ */
+#define TAP_ID @TAP_ID@
+#define TAP_WIN32_MIN_MAJOR @TAP_WIN32_MIN_MAJOR@
+#define TAP_WIN32_MIN_MINOR @TAP_WIN32_MIN_MINOR@
+
+/* Enable client/server capability */
+#define ENABLE_CLIENT_SERVER 1
+
+/* Enable client capability only */
+/* #undef ENABLE_CLIENT_ONLY */
+
+/* Enable management server capability */
+#define ENABLE_MANAGEMENT 1
+
+/* Enable PKCS#11 support */
+#define USE_PKCS11 1
+
+/* Enable HTTP proxy support */
+#define ENABLE_HTTP_PROXY 1
+
+/* Enable Socks proxy support */
+#define ENABLE_SOCKS 1
+
+/* Enable internal fragmentation support */
+#define ENABLE_FRAGMENT 1
+
+/* Enable smaller executable size */
+/* #undef ENABLE_SMALL */
+
+/* Enable debugging support */
+#define ENABLE_DEBUG 1
+
+/* if defined, will allow usage of the --plugin directive */
+#define USE_LOAD_LIBRARY
+
+/* Dimension size to use for empty array declaration */
+#define EMPTY_ARRAY_SIZE 0
+
+/* Define to 1 if you have the `getsockname' function. */
+#define HAVE_GETSOCKNAME 1
+
+/* Define to 1 if you have the <openssl/engine.h> header file. */
+#define HAVE_OPENSSL_ENGINE_H 1
+
+/* Define to 1 if you have the `ENGINE_load_builtin_engines' function. */
+#define HAVE_ENGINE_LOAD_BUILTIN_ENGINES 1
+
+/* Define to 1 if you have the `ENGINE_register_all_complete' function. */
+#define HAVE_ENGINE_REGISTER_ALL_COMPLETE 1
+
+/* Define to 1 if you have the `ENGINE_cleanup' function. */
+#define HAVE_ENGINE_CLEANUP 1
+
+/* gettimeofday() is implemented in otime.c for Windows */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the 'chsize' function. */
+#define HAVE_CHSIZE 1
+
+/* Define to 1 if you have the `chdir' function. */
+#define HAVE_CHDIR 1
+
+/* Define to 1 if your compiler supports GNU GCC-style variadic macros */
+#ifndef _MSC_VER /* Defines MSFT compiler version. Defined as 1200 for MSVC++ 6.0. */
+#define HAVE_CPP_VARARG_MACRO_GCC 1
+#endif
+
+/* Define to 1 if you have the <ctype.h> header file. */
+#define HAVE_CTYPE_H 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define to 1 if you have the `EVP_CIPHER_CTX_set_key_length' function. */
+#define HAVE_EVP_CIPHER_CTX_SET_KEY_LENGTH 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `getsockopt' function. */
+#define HAVE_GETSOCKOPT 1
+
+/* Define to 1 if you have the `inet_ntoa' function. */
+#define HAVE_INET_NTOA 1
+
+/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
+   to 0 otherwise. */
+#define HAVE_MALLOC 1
+
+/* Define to 1 if you have the `memset' function. */
+#define HAVE_MEMSET 1
+
+/* Define to 1 if you have the `setsockopt' function. */
+#define HAVE_SETSOCKOPT 1
+
+/* Define to 1 if you have the `socket' function. */
+#define HAVE_SOCKET 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#ifndef _MSC_VER
+#define HAVE_STDINT_H 1
+#endif
+
+/* Define to 1 if you have the <stdio.h> header file. */
+#define HAVE_STDIO_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `system' function. */
+#define HAVE_SYSTEM 1
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#ifndef _MSC_VER
+#define HAVE_SYS_FILE_H 1
+#endif
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#ifndef _MSC_VER
+#define HAVE_SYS_TIME_H 1
+#endif
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the `time' function. */
+#define HAVE_TIME 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#ifndef _MSC_VER
+#define HAVE_UNISTD_H 1
+#endif
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Special Windows version of getpass() defined in io.c */
+#define HAVE_GETPASS 1
+
+/* Name of package */
+#define PACKAGE @PACKAGE@
+
+/* Define to the address where bug reports for this package should be sent. */
+//#define PACKAGE_BUGREPORT "openvpn-users@lists.sourceforge.net"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME @PACKAGE_NAME@
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME @PACKAGE_TARNAME@
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION @PACKAGE_VERSION@
+
+/* Define to the full name and version of this package. */
+#ifdef DEBUG_LABEL
+#define PACKAGE_STRING PACKAGE_NAME " " PACKAGE_VERSION " " DEBUG_LABEL
+#else
+#define PACKAGE_STRING PACKAGE_NAME " " PACKAGE_VERSION
+#endif
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* The size of a `unsigned int', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_INT 4
+
+/* The size of a `unsigned long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG 4
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* A string representing our target */
+#ifdef _MSC_VER
+#define TARGET_ALIAS "Win32-MSVC++"
+#else
+#define TARGET_ALIAS "Win32-MinGW"
+#endif
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#ifndef _MSC_VER
+#define TIME_WITH_SYS_TIME 1
+#endif
+
+/* Use OpenSSL crypto library */
+#define USE_CRYPTO 1
+
+/* Use LZO compression library */
+#define USE_LZO 1
+
+/* LZO version number */
+#define LZO_VERSION_NUM "2"
+
+/* Use lzo/ directory prefix for LZO header files (for LZO 2.0) */
+#define LZO_HEADER_DIR 1
+
+/* Use OpenSSL SSL library */
+#define USE_SSL 1
+
+/* Version number of package */
+#define VERSION PACKAGE_VERSION
+
+/* Define as `__inline' if that's what the C compiler calls it, or to nothing
+   if it is not supported. */
+#define inline __inline
+
+/* type to use in place of socklen_t if not defined */
+#define socklen_t unsigned int
+
+/* 32-bit unsigned type */
+#define uint32_t unsigned int
+
+/* 16-bit unsigned type */
+#define uint16_t unsigned short
+
+/* 8-bit unsigned type */
+#define uint8_t unsigned char
+
+/* Route command */
+#define ROUTE_PATH "route"
+
+/* Windows doesn't support PTHREAD yet */
+#ifdef USE_PTHREAD
+#error The Windows version of OpenVPN does not support PTHREAD yet
+#endif
+
+#ifdef _MSC_VER
+/* MSVC++ hacks */
+#include <io.h>
+#include <direct.h>
+#define vsnprintf _vsnprintf
+#define vsnwprintf _vsnwprintf
+#define snwprintf _snwprintf
+#define write _write
+#define open _open
+#define read _read
+#define close _close
+#define chdir _chdir
+#define S_IRUSR 0
+#define S_IWUSR 0
+typedef int intptr_t;
+#undef S_NORMAL
+/* Visual Studio 2005 supports vararg macros */
+#if _MSC_VER >= 1400
+#define HAVE_CPP_VARARG_MACRO_ISO 1
+#endif
+#endif
diff -urN openvpn-2.1_rc7/config.h.in openvpn-2.1_rc9/config.h.in
--- openvpn-2.1_rc7/config.h.in	2008-01-30 00:56:30.000000000 +0100
+++ openvpn-2.1_rc9/config.h.in	2008-07-31 19:45:19.000000000 +0200
@@ -99,7 +99,7 @@
 /* Define to 1 if you have the `ENGINE_register_all_complete' function. */
 #undef HAVE_ENGINE_REGISTER_ALL_COMPLETE
 
-/* Define to 1 if you have the `epoll_create' function. */
+/* epoll_create function is defined */
 #undef HAVE_EPOLL_CREATE
 
 /* Define to 1 if you have the <errno.h> header file. */
@@ -111,6 +111,9 @@
 /* Define to 1 if you have the `EVP_CIPHER_CTX_set_key_length' function. */
 #undef HAVE_EVP_CIPHER_CTX_SET_KEY_LENGTH
 
+/* Define to 1 if you have the `execve' function. */
+#undef HAVE_EXECVE
+
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
@@ -219,6 +222,9 @@
 /* Define to 1 if you have the <net/if_tun.h> header file. */
 #undef HAVE_NET_IF_TUN_H
 
+/* Define to 1 if you have the <net/tun/if_tun.h> header file. */
+#undef HAVE_NET_TUN_IF_TUN_H
+
 /* Define to 1 if you have the `nice' function. */
 #undef HAVE_NICE
 
@@ -255,6 +261,9 @@
 /* Define to 1 if you have the <resolv.h> header file. */
 #undef HAVE_RESOLV_H
 
+/* Indicates if res_init is available */
+#undef HAVE_RES_INIT
+
 /* Define to 1 if you have the `select' function. */
 #undef HAVE_SELECT
 
@@ -448,12 +457,24 @@
 /* Enable strict options check between peers */
 #undef STRICT_OPTIONS_CHECK
 
+/* The TAP-Win32 id defined in tap-win32/SOURCES */
+#undef TAP_ID
+
+/* The TAP-Win32 version number is defined in tap-win32/SOURCES */
+#undef TAP_WIN32_MIN_MAJOR
+
+/* The TAP-Win32 version number is defined in tap-win32/SOURCES */
+#undef TAP_WIN32_MIN_MINOR
+
 /* A string representing our target */
 #undef TARGET_ALIAS
 
 /* Are we running on Mac OS X? */
 #undef TARGET_DARWIN
 
+/* Are we running on DragonFlyBSD? */
+#undef TARGET_DRAGONFLY
+
 /* Are we running on FreeBSD? */
 #undef TARGET_FREEBSD
 
@@ -469,6 +490,9 @@
 /* Are we running on Solaris? */
 #undef TARGET_SOLARIS
 
+/* Are we running WIN32? */
+#undef TARGET_WIN32
+
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #undef TIME_WITH_SYS_TIME
 
@@ -478,6 +502,9 @@
 /* Use libdl for dynamic library loading */
 #undef USE_LIBDL
 
+/* Use LoadLibrary to load DLLs on Windows */
+#undef USE_LOAD_LIBRARY
+
 /* Use LZO compression library */
 #undef USE_LZO
 
diff -urN openvpn-2.1_rc7/configure openvpn-2.1_rc9/configure
--- openvpn-2.1_rc7/configure	2008-01-30 00:55:44.000000000 +0100
+++ openvpn-2.1_rc9/configure	2008-07-31 19:45:19.000000000 +0200
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.61 for OpenVPN 2.1_rc7.
+# Generated by GNU Autoconf 2.61 for OpenVPN 2.1_rc9.
 #
 # Report bugs to <openvpn-users@lists.sourceforge.net>.
 #
@@ -574,8 +574,8 @@
 # Identity of this package.
 PACKAGE_NAME='OpenVPN'
 PACKAGE_TARNAME='openvpn'
-PACKAGE_VERSION='2.1_rc7'
-PACKAGE_STRING='OpenVPN 2.1_rc7'
+PACKAGE_VERSION='2.1_rc9'
+PACKAGE_STRING='OpenVPN 2.1_rc9'
 PACKAGE_BUGREPORT='openvpn-users@lists.sourceforge.net'
 
 ac_unique_file="syshead.h"
@@ -652,9 +652,6 @@
 build_alias
 host_alias
 target_alias
-IFCONFIG
-IPROUTE
-ROUTE
 build
 build_cpu
 build_vendor
@@ -688,6 +685,9 @@
 AMTAR
 am__tar
 am__untar
+IFCONFIG
+IPROUTE
+ROUTE
 CC
 CFLAGS
 LDFLAGS
@@ -707,10 +707,17 @@
 CPP
 GREP
 EGREP
+MAN2HTML
 LIBOBJS
 PTHREAD_CC
 PTHREAD_LIBS
 PTHREAD_CFLAGS
+TAP_ID
+TAP_WIN32_MIN_MAJOR
+TAP_WIN32_MIN_MINOR
+win32datadir
+WIN32_TRUE
+WIN32_FALSE
 LTLIBOBJS'
 ac_subst_files=''
       ac_precious_vars='build_alias
@@ -721,7 +728,8 @@
 LDFLAGS
 LIBS
 CPPFLAGS
-CPP'
+CPP
+MAN2HTML'
 
 
 # Initialize some variables set by options.
@@ -1224,7 +1232,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures OpenVPN 2.1_rc7 to adapt to many kinds of systems.
+\`configure' configures OpenVPN 2.1_rc9 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1295,7 +1303,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of OpenVPN 2.1_rc7:";;
+     short | recursive ) echo "Configuration of OpenVPN 2.1_rc9:";;
    esac
   cat <<\_ACEOF
 
@@ -1330,10 +1338,13 @@
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-cygwin-native              Compile native win32
   --with-ssl-headers=DIR  Crypto/SSL Include files location
   --with-ssl-lib=DIR      Crypto/SSL Library location
   --with-lzo-headers=DIR  LZO Include files location
   --with-lzo-lib=DIR      LZO Library location
+  --with-pkcs11-helper-headers=DIR pkcs11-helper Include files location
+  --with-pkcs11-helper-lib=DIR     pkcs11-helper Library location
   --with-ifconfig-path=PATH   Path to ifconfig tool
   --with-iproute-path=PATH    Path to iproute tool
   --with-route-path=PATH  Path to route tool
@@ -1348,6 +1359,7 @@
   CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
   CPP         C preprocessor
+  MAN2HTML    man2html utility
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
@@ -1413,7 +1425,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-OpenVPN configure 2.1_rc7
+OpenVPN configure 2.1_rc9
 generated by GNU Autoconf 2.61
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
@@ -1427,7 +1439,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by OpenVPN $as_me 2.1_rc7, which was
+It was created by OpenVPN $as_me 2.1_rc9, which was
 generated by GNU Autoconf 2.61.  Invocation command line was
 
   $ $0 $@
@@ -1784,266 +1796,503 @@
 
 
 
-# Check whether --enable-lzo was given.
-if test "${enable_lzo+set}" = set; then
-  enableval=$enable_lzo; LZO="$enableval"
-else
-  LZO="yes"
-
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
+echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
+   { (exit 1); exit 1; }; }
 fi
 
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
 
-# Check whether --enable-crypto was given.
-if test "${enable_crypto+set}" = set; then
-  enableval=$enable_crypto; CRYPTO="$enableval"
-else
-  CRYPTO="yes"
-
-fi
 
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
+echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
+   { (exit 1); exit 1; }; }
 
-# Check whether --enable-ssl was given.
-if test "${enable_ssl+set}" = set; then
-  enableval=$enable_ssl; SSL="$enableval"
+{ echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6; }
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  SSL="yes"
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
+echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
 
 fi
+{ echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) { { echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
+echo "$as_me: error: invalid value of canonical build" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
 
 
-# Check whether --enable-multi was given.
-if test "${enable_multi+set}" = set; then
-  enableval=$enable_multi; MULTI="$enableval"
+{ echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6; }
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  MULTI="yes"
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
+echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+fi
 
 fi
+{ echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) { { echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
+echo "$as_me: error: invalid value of canonical host" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
-# Check whether --enable-server was given.
-if test "${enable_server+set}" = set; then
-  enableval=$enable_server; MULTI_SERVER="$enableval"
+{ echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6; }
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  MULTI_SERVER="yes"
+  if test "x$target_alias" = x; then
+  ac_cv_target=$ac_cv_host
+else
+  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
+    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&5
+echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+fi
 
 fi
+{ echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6; }
+case $ac_cv_target in
+*-*-*) ;;
+*) { { echo "$as_me:$LINENO: error: invalid value of canonical target" >&5
+echo "$as_me: error: invalid value of canonical target" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+target=$ac_cv_target
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_target
+shift
+target_cpu=$1
+target_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+target_os=$*
+IFS=$ac_save_IFS
+case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
 
 
-# Check whether --enable-plugins was given.
-if test "${enable_plugins+set}" = set; then
-  enableval=$enable_plugins; PLUGINS="$enableval"
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+am__api_version="1.9"
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+{ echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  PLUGINS="yes"
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+IFS=$as_save_IFS
 
-fi
 
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6; }
 
-# Check whether --enable-management was given.
-if test "${enable_management+set}" = set; then
-  enableval=$enable_management; MANAGEMENT="$enableval"
-else
-  MANAGEMENT="yes"
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
 
-fi
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
 
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
-# Check whether --enable-pkcs11 was given.
-if test "${enable_pkcs11+set}" = set; then
-  enableval=$enable_pkcs11; PKCS11="$enableval"
-else
-  PKCS11="yes"
-
-fi
+{ echo "$as_me:$LINENO: checking whether build environment is sane" >&5
+echo $ECHO_N "checking whether build environment is sane... $ECHO_C" >&6; }
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$*" != "X $srcdir/configure conftest.file" \
+      && test "$*" != "X conftest.file $srcdir/configure"; then
 
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      { { echo "$as_me:$LINENO: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" >&5
+echo "$as_me: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" >&2;}
+   { (exit 1); exit 1; }; }
+   fi
 
-# Check whether --enable-socks was given.
-if test "${enable_socks+set}" = set; then
-  enableval=$enable_socks; SOCKS="$enableval"
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
 else
-  SOCKS="yes"
-
+   { { echo "$as_me:$LINENO: error: newly created file is older than distributed files!
+Check your system clock" >&5
+echo "$as_me: error: newly created file is older than distributed files!
+Check your system clock" >&2;}
+   { (exit 1); exit 1; }; }
 fi
+{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.  echo might interpret backslashes.
+# By default was `s,x,x', remove it if useless.
+cat <<\_ACEOF >conftest.sed
+s/[\\$]/&&/g;s/;s,x,x,$//
+_ACEOF
+program_transform_name=`echo $program_transform_name | sed -f conftest.sed`
+rm -f conftest.sed
 
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
 
-# Check whether --enable-http was given.
-if test "${enable_http+set}" = set; then
-  enableval=$enable_http; HTTP_PROXY="$enableval"
+test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
 else
-  HTTP_PROXY="yes"
-
+  am_missing_run=
+  { echo "$as_me:$LINENO: WARNING: \`missing' script is too old or missing" >&5
+echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
 fi
 
-
-# Check whether --enable-fragment was given.
-if test "${enable_fragment+set}" = set; then
-  enableval=$enable_fragment; FRAGMENT="$enableval"
+if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+  # We used to keeping the `.' as first argument, in order to
+  # allow $(mkdir_p) to be used without argument.  As in
+  #   $(mkdir_p) $(somedir)
+  # where $(somedir) is conditionally defined.  However this is wrong
+  # for two reasons:
+  #  1. if the package is installed by a user who cannot write `.'
+  #     make install will fail,
+  #  2. the above comment should most certainly read
+  #     $(mkdir_p) $(DESTDIR)$(somedir)
+  #     so it does not work when $(somedir) is undefined and
+  #     $(DESTDIR) is not.
+  #  To support the latter case, we have to write
+  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
+  #  so the `.' trick is pointless.
+  mkdir_p='mkdir -p --'
 else
-  FRAGMENT="yes"
-
+  # On NextStep and OpenStep, the `mkdir' command does not
+  # recognize any option.  It will interpret all options as
+  # directories to create, and then abort because `.' already
+  # exists.
+  for d in ./-p ./--version;
+  do
+    test -d $d && rmdir $d
+  done
+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
+  if test -f "$ac_aux_dir/mkinstalldirs"; then
+    mkdir_p='$(mkinstalldirs)'
+  else
+    mkdir_p='$(install_sh) -d'
+  fi
 fi
 
-
-# Check whether --enable-multihome was given.
-if test "${enable_multihome+set}" = set; then
-  enableval=$enable_multihome; MULTIHOME="$enableval"
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_AWK+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  MULTIHOME="yes"
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AWK="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
 
 fi
-
-
-# Check whether --enable-port-share was given.
-if test "${enable_port_share+set}" = set; then
-  enableval=$enable_port_share; PORT_SHARE="$enableval"
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { echo "$as_me:$LINENO: result: $AWK" >&5
+echo "${ECHO_T}$AWK" >&6; }
 else
-  PORT_SHARE="yes"
-
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
 fi
 
 
-# Check whether --enable-debug was given.
-if test "${enable_debug+set}" = set; then
-  enableval=$enable_debug; DEBUG="$enableval"
-else
-  DEBUG="yes"
+  test -n "$AWK" && break
+done
 
+{ echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6; }
+set x ${MAKE-make}; ac_make=`echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
 fi
-
-
-# Check whether --enable-small was given.
-if test "${enable_small+set}" = set; then
-  enableval=$enable_small; SMALL="$enableval"
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+  SET_MAKE=
 else
-  SMALL="no"
-
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
 fi
 
-
-# Check whether --enable-pthread was given.
-if test "${enable_pthread+set}" = set; then
-  enableval=$enable_pthread; PTHREAD="$enableval"
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
 else
-  PTHREAD="no"
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
 
+# test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" &&
+   test -f $srcdir/config.status; then
+  { { echo "$as_me:$LINENO: error: source directory already configured; run \"make distclean\" there first" >&5
+echo "$as_me: error: source directory already configured; run \"make distclean\" there first" >&2;}
+   { (exit 1); exit 1; }; }
 fi
 
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
 
-# Check whether --enable-password-save was given.
-if test "${enable_password_save+set}" = set; then
-  enableval=$enable_password_save; PASSWORD_SAVE="$enableval"
-else
-  PASSWORD_SAVE="no"
 
-fi
+# Define the identity of the package.
+ PACKAGE=openvpn
+ VERSION=$PACKAGE_VERSION
 
 
-# Check whether --enable-iproute2 was given.
-if test "${enable_iproute2+set}" = set; then
-  enableval=$enable_iproute2; test $enableval = "yes" &&
-cat >>confdefs.h <<\_ACEOF
-#define CONFIG_FEATURE_IPROUTE 1
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE "$PACKAGE"
 _ACEOF
 
 
-fi
+cat >>confdefs.h <<_ACEOF
+#define VERSION "$VERSION"
+_ACEOF
 
+# Some tools Automake needs.
 
-# Check whether --enable-strict was given.
-if test "${enable_strict+set}" = set; then
-  enableval=$enable_strict; STRICT="$enableval"
-else
-  STRICT="no"
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
 
-fi
-
-
-# Check whether --enable-pedantic was given.
-if test "${enable_pedantic+set}" = set; then
-  enableval=$enable_pedantic; PEDANTIC="$enableval"
-else
-  PEDANTIC="no"
-
-fi
-
-
-# Check whether --enable-profiling was given.
-if test "${enable_profiling+set}" = set; then
-  enableval=$enable_profiling; PROFILE="$enableval"
-else
-  PROFILE="no"
-
-fi
-
-
-# Check whether --enable-strict-options was given.
-if test "${enable_strict_options+set}" = set; then
-  enableval=$enable_strict_options; STRICT_OPTIONS="$enableval"
-else
-  STRICT_OPTIONS="no"
-
-fi
-
-
-
-# Check whether --with-ssl-headers was given.
-if test "${with_ssl_headers+set}" = set; then
-  withval=$with_ssl_headers; CS_HDR_DIR="$withval"
-   CPPFLAGS="$CPPFLAGS -I$withval"
-
-fi
 
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
 
 
-# Check whether --with-ssl-lib was given.
-if test "${with_ssl_lib+set}" = set; then
-  withval=$with_ssl_lib; LDFLAGS="$LDFLAGS -L$withval"
-
-fi
-
-
-
-# Check whether --with-lzo-headers was given.
-if test "${with_lzo_headers+set}" = set; then
-  withval=$with_lzo_headers; LZO_HDR_DIR="$withval"
-   CPPFLAGS="$CPPFLAGS -I$withval"
-
-fi
-
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
 
 
-# Check whether --with-lzo-lib was given.
-if test "${with_lzo_lib+set}" = set; then
-  withval=$with_lzo_lib; LDFLAGS="$LDFLAGS -L$withval"
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
 
-fi
 
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
 
+install_sh=${install_sh-"$am_aux_dir/install-sh"}
 
-# Check whether --with-ifconfig-path was given.
-if test "${with_ifconfig_path+set}" = set; then
-  withval=$with_ifconfig_path; IFCONFIG="$withval"
-else
-  # Extract the first word of "ifconfig", so it can be a program name with args.
-set dummy ifconfig; ac_word=$2
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
 { echo "$as_me:$LINENO: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_path_IFCONFIG+set}" = set; then
+if test "${ac_cv_prog_STRIP+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  case $IFCONFIG in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_IFCONFIG="$IFCONFIG" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-as_dummy="$PATH:/usr/local/sbin:/usr/sbin:/sbin"
-for as_dir in $as_dummy
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_IFCONFIG="$as_dir/$ac_word$ac_exec_ext"
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -2051,55 +2300,39 @@
 done
 IFS=$as_save_IFS
 
-  test -z "$ac_cv_path_IFCONFIG" && ac_cv_path_IFCONFIG="ifconfig"
-  ;;
-esac
 fi
-IFCONFIG=$ac_cv_path_IFCONFIG
-if test -n "$IFCONFIG"; then
-  { echo "$as_me:$LINENO: result: $IFCONFIG" >&5
-echo "${ECHO_T}$IFCONFIG" >&6; }
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { echo "$as_me:$LINENO: result: $STRIP" >&5
+echo "${ECHO_T}$STRIP" >&6; }
 else
   { echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6; }
 fi
 
 
-
 fi
-
-
-cat >>confdefs.h <<_ACEOF
-#define IFCONFIG_PATH "$IFCONFIG"
-_ACEOF
-
-
-
-# Check whether --with-iproute-path was given.
-if test "${with_iproute_path+set}" = set; then
-  withval=$with_iproute_path; IPROUTE="$withval"
-else
-  # Extract the first word of "ip", so it can be a program name with args.
-set dummy ip; ac_word=$2
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
 { echo "$as_me:$LINENO: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_path_IPROUTE+set}" = set; then
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  case $IPROUTE in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_IPROUTE="$IPROUTE" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-as_dummy="$PATH:/usr/local/sbin:/usr/sbin:/sbin"
-for as_dir in $as_dummy
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_IPROUTE="$as_dir/$ac_word$ac_exec_ext"
+    ac_cv_prog_ac_ct_STRIP="strip"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -2107,591 +2340,364 @@
 done
 IFS=$as_save_IFS
 
-  test -z "$ac_cv_path_IPROUTE" && ac_cv_path_IPROUTE="ip"
-  ;;
-esac
 fi
-IPROUTE=$ac_cv_path_IPROUTE
-if test -n "$IPROUTE"; then
-  { echo "$as_me:$LINENO: result: $IPROUTE" >&5
-echo "${ECHO_T}$IPROUTE" >&6; }
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+echo "${ECHO_T}$ac_ct_STRIP" >&6; }
 else
   { echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6; }
 fi
 
-
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&5
+echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
 
 fi
+INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
 
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.
 
-cat >>confdefs.h <<_ACEOF
-#define IPROUTE_PATH "$IPROUTE"
-_ACEOF
+AMTAR=${AMTAR-"${am_missing_run}tar"}
 
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
 
 
 
-# Check whether --with-route-path was given.
-if test "${with_route_path+set}" = set; then
-  withval=$with_route_path; ROUTE="$withval"
-else
-  # Extract the first word of "route", so it can be a program name with args.
-set dummy route; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_path_ROUTE+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+
+
+
+
+# Check whether --with-cygwin-native was given.
+if test "${with_cygwin_native+set}" = set; then
+  withval=$with_cygwin_native; CYGWIN_NATIVE="${withval}"
 else
-  case $ROUTE in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_ROUTE="$ROUTE" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-as_dummy="$PATH:/usr/local/sbin:/usr/sbin:/sbin"
-for as_dir in $as_dummy
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_ROUTE="$as_dir/$ac_word$ac_exec_ext"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
+  CYGWIN_NATIVE="no"
 
-  test -z "$ac_cv_path_ROUTE" && ac_cv_path_ROUTE="route"
-  ;;
-esac
 fi
-ROUTE=$ac_cv_path_ROUTE
-if test -n "$ROUTE"; then
-  { echo "$as_me:$LINENO: result: $ROUTE" >&5
-echo "${ECHO_T}$ROUTE" >&6; }
+
+
+WIN32="no"
+CYGWIN="no"
+case "${host}" in
+	*-mingw32*)
+		WIN32="yes"
+		cross_compiling="yes"
+	;;
+	*-cygwin*)
+		{ echo "$as_me:$LINENO: checking cygwin mode to use" >&5
+echo $ECHO_N "checking cygwin mode to use... $ECHO_C" >&6; }
+		if test "${CYGWIN_NATIVE}" = "yes"; then
+			{ echo "$as_me:$LINENO: result: Using native win32" >&5
+echo "${ECHO_T}Using native win32" >&6; }
+			CFLAGS="${CFLAGS} -mno-cygwin"
+			CYGWIN="yes"
+			WIN32="yes"
+		else
+			{ echo "$as_me:$LINENO: result: Using cygwin" >&5
+echo "${ECHO_T}Using cygwin" >&6; }
+		fi
+	;;
+	*)
+	;;
+esac
+
+# Check whether --enable-lzo was given.
+if test "${enable_lzo+set}" = set; then
+  enableval=$enable_lzo; LZO="$enableval"
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  LZO="yes"
+
 fi
 
 
+# Check whether --enable-crypto was given.
+if test "${enable_crypto+set}" = set; then
+  enableval=$enable_crypto; CRYPTO="$enableval"
+else
+  CRYPTO="yes"
 
 fi
 
 
-cat >>confdefs.h <<_ACEOF
-#define ROUTE_PATH "$ROUTE"
-_ACEOF
+# Check whether --enable-ssl was given.
+if test "${enable_ssl+set}" = set; then
+  enableval=$enable_ssl; SSL="$enableval"
+else
+  SSL="yes"
 
+fi
 
 
-# Check whether --with-mem-check was given.
-if test "${with_mem_check+set}" = set; then
-  withval=$with_mem_check; MEMCHECK="$withval"
+# Check whether --enable-multi was given.
+if test "${enable_multi+set}" = set; then
+  enableval=$enable_multi; MULTI="$enableval"
+else
+  MULTI="yes"
 
 fi
 
 
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
-echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
-   { (exit 1); exit 1; }; }
+# Check whether --enable-server was given.
+if test "${enable_server+set}" = set; then
+  enableval=$enable_server; MULTI_SERVER="$enableval"
+else
+  MULTI_SERVER="yes"
+
 fi
 
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
 
+# Check whether --enable-plugins was given.
+if test "${enable_plugins+set}" = set; then
+  enableval=$enable_plugins; PLUGINS="$enableval"
+else
+  PLUGINS="yes"
 
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  { { echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
-echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
-   { (exit 1); exit 1; }; }
+fi
 
-{ echo "$as_me:$LINENO: checking build system type" >&5
-echo $ECHO_N "checking build system type... $ECHO_C" >&6; }
-if test "${ac_cv_build+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+
+# Check whether --enable-management was given.
+if test "${enable_management+set}" = set; then
+  enableval=$enable_management; MANAGEMENT="$enableval"
 else
-  ac_build_alias=$build_alias
-test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
-test "x$ac_build_alias" = x &&
-  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
-echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
-   { (exit 1); exit 1; }; }
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
+  MANAGEMENT="yes"
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_build" >&5
-echo "${ECHO_T}$ac_cv_build" >&6; }
-case $ac_cv_build in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
-echo "$as_me: error: invalid value of canonical build" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
-build=$ac_cv_build
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_build
-shift
-build_cpu=$1
-build_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-build_os=$*
-IFS=$ac_save_IFS
-case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
 
 
-{ echo "$as_me:$LINENO: checking host system type" >&5
-echo $ECHO_N "checking host system type... $ECHO_C" >&6; }
-if test "${ac_cv_host+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "x$host_alias" = x; then
-  ac_cv_host=$ac_cv_build
+# Check whether --enable-pkcs11 was given.
+if test "${enable_pkcs11+set}" = set; then
+  enableval=$enable_pkcs11; PKCS11="$enableval"
 else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
-fi
+  PKCS11="yes"
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_host" >&5
-echo "${ECHO_T}$ac_cv_host" >&6; }
-case $ac_cv_host in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
-echo "$as_me: error: invalid value of canonical host" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
-host=$ac_cv_host
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_host
-shift
-host_cpu=$1
-host_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-host_os=$*
-IFS=$ac_save_IFS
-case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
-{ echo "$as_me:$LINENO: checking target system type" >&5
-echo $ECHO_N "checking target system type... $ECHO_C" >&6; }
-if test "${ac_cv_target+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "x$target_alias" = x; then
-  ac_cv_target=$ac_cv_host
+# Check whether --enable-socks was given.
+if test "${enable_socks+set}" = set; then
+  enableval=$enable_socks; SOCKS="$enableval"
 else
-  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
-    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
-fi
+  SOCKS="yes"
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_target" >&5
-echo "${ECHO_T}$ac_cv_target" >&6; }
-case $ac_cv_target in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical target" >&5
-echo "$as_me: error: invalid value of canonical target" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
-target=$ac_cv_target
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_target
-shift
-target_cpu=$1
-target_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-target_os=$*
-IFS=$ac_save_IFS
-case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
 
 
-# The aliases save the names the user supplied, while $host etc.
-# will get canonicalized.
-test -n "$target_alias" &&
-  test "$program_prefix$program_suffix$program_transform_name" = \
-    NONENONEs,x,x, &&
-  program_prefix=${target_alias}-
-am__api_version="1.9"
-# Find a good install program.  We prefer a C program (faster),
-# so one script is as good as another.  But avoid the broken or
-# incompatible versions:
-# SysV /etc/install, /usr/sbin/install
-# SunOS /usr/etc/install
-# IRIX /sbin/install
-# AIX /bin/install
-# AmigaOS /C/install, which installs bootblocks on floppy discs
-# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
-# AFS /usr/afsws/bin/install, which mishandles nonexistent args
-# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
-# OS/2's system install, which has a completely different semantic
-# ./install, which can be erroneously created by make from ./install.sh.
-{ echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
-echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6; }
-if test -z "$INSTALL"; then
-if test "${ac_cv_path_install+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+# Check whether --enable-http was given.
+if test "${enable_http+set}" = set; then
+  enableval=$enable_http; HTTP_PROXY="$enableval"
 else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  # Account for people who put trailing slashes in PATH elements.
-case $as_dir/ in
-  ./ | .// | /cC/* | \
-  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
-  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
-  /usr/ucb/* ) ;;
-  *)
-    # OSF1 and SCO ODT 3.0 have their own names for install.
-    # Don't use installbsd from OSF since it installs stuff as root
-    # by default.
-    for ac_prog in ginstall scoinst install; do
-      for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
-	  if test $ac_prog = install &&
-	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # AIX install.  It has an incompatible calling convention.
-	    :
-	  elif test $ac_prog = install &&
-	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # program-specific install script used by HP pwplus--don't use.
-	    :
-	  else
-	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
-	    break 3
-	  fi
-	fi
-      done
-    done
-    ;;
-esac
-done
-IFS=$as_save_IFS
-
+  HTTP_PROXY="yes"
 
 fi
-  if test "${ac_cv_path_install+set}" = set; then
-    INSTALL=$ac_cv_path_install
-  else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for INSTALL within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    INSTALL=$ac_install_sh
-  fi
-fi
-{ echo "$as_me:$LINENO: result: $INSTALL" >&5
-echo "${ECHO_T}$INSTALL" >&6; }
 
-# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
-# It thinks the first close brace ends the variable substitution.
-test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
 
-test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+# Check whether --enable-fragment was given.
+if test "${enable_fragment+set}" = set; then
+  enableval=$enable_fragment; FRAGMENT="$enableval"
+else
+  FRAGMENT="yes"
 
-test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+fi
 
-{ echo "$as_me:$LINENO: checking whether build environment is sane" >&5
-echo $ECHO_N "checking whether build environment is sane... $ECHO_C" >&6; }
-# Just in case
-sleep 1
-echo timestamp > conftest.file
-# Do `set' in a subshell so we don't clobber the current shell's
-# arguments.  Must try -L first in case configure is actually a
-# symlink; some systems play weird games with the mod time of symlinks
-# (eg FreeBSD returns the mod time of the symlink's containing
-# directory).
-if (
-   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
-   if test "$*" = "X"; then
-      # -L didn't work.
-      set X `ls -t $srcdir/configure conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$*" != "X $srcdir/configure conftest.file" \
-      && test "$*" != "X conftest.file $srcdir/configure"; then
 
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      { { echo "$as_me:$LINENO: error: ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" >&5
-echo "$as_me: error: ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" >&2;}
-   { (exit 1); exit 1; }; }
-   fi
+# Check whether --enable-multihome was given.
+if test "${enable_multihome+set}" = set; then
+  enableval=$enable_multihome; MULTIHOME="$enableval"
+else
+  MULTIHOME="yes"
 
-   test "$2" = conftest.file
-   )
-then
-   # Ok.
-   :
+fi
+
+
+# Check whether --enable-port-share was given.
+if test "${enable_port_share+set}" = set; then
+  enableval=$enable_port_share; PORT_SHARE="$enableval"
 else
-   { { echo "$as_me:$LINENO: error: newly created file is older than distributed files!
-Check your system clock" >&5
-echo "$as_me: error: newly created file is older than distributed files!
-Check your system clock" >&2;}
-   { (exit 1); exit 1; }; }
+  PORT_SHARE="yes"
+
 fi
-{ echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
-test "$program_prefix" != NONE &&
-  program_transform_name="s&^&$program_prefix&;$program_transform_name"
-# Use a double $ so make ignores it.
-test "$program_suffix" != NONE &&
-  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
-# Double any \ or $.  echo might interpret backslashes.
-# By default was `s,x,x', remove it if useless.
-cat <<\_ACEOF >conftest.sed
-s/[\\$]/&&/g;s/;s,x,x,$//
-_ACEOF
-program_transform_name=`echo $program_transform_name | sed -f conftest.sed`
-rm -f conftest.sed
 
-# expand $ac_aux_dir to an absolute path
-am_aux_dir=`cd $ac_aux_dir && pwd`
 
-test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
-# Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
+# Check whether --enable-debug was given.
+if test "${enable_debug+set}" = set; then
+  enableval=$enable_debug; DEBUG="$enableval"
 else
-  am_missing_run=
-  { echo "$as_me:$LINENO: WARNING: \`missing' script is too old or missing" >&5
-echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+  DEBUG="yes"
+
 fi
 
-if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
-  # We used to keeping the `.' as first argument, in order to
-  # allow $(mkdir_p) to be used without argument.  As in
-  #   $(mkdir_p) $(somedir)
-  # where $(somedir) is conditionally defined.  However this is wrong
-  # for two reasons:
-  #  1. if the package is installed by a user who cannot write `.'
-  #     make install will fail,
-  #  2. the above comment should most certainly read
-  #     $(mkdir_p) $(DESTDIR)$(somedir)
-  #     so it does not work when $(somedir) is undefined and
-  #     $(DESTDIR) is not.
-  #  To support the latter case, we have to write
-  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
-  #  so the `.' trick is pointless.
-  mkdir_p='mkdir -p --'
+
+# Check whether --enable-small was given.
+if test "${enable_small+set}" = set; then
+  enableval=$enable_small; SMALL="$enableval"
 else
-  # On NextStep and OpenStep, the `mkdir' command does not
-  # recognize any option.  It will interpret all options as
-  # directories to create, and then abort because `.' already
-  # exists.
-  for d in ./-p ./--version;
-  do
-    test -d $d && rmdir $d
-  done
-  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
-  if test -f "$ac_aux_dir/mkinstalldirs"; then
-    mkdir_p='$(mkinstalldirs)'
-  else
-    mkdir_p='$(install_sh) -d'
-  fi
+  SMALL="no"
+
 fi
 
-for ac_prog in gawk mawk nawk awk
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_AWK+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+
+# Check whether --enable-pthread was given.
+if test "${enable_pthread+set}" = set; then
+  enableval=$enable_pthread; PTHREAD="$enableval"
 else
-  if test -n "$AWK"; then
-  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+  PTHREAD="no"
+
+fi
+
+
+# Check whether --enable-password-save was given.
+if test "${enable_password_save+set}" = set; then
+  enableval=$enable_password_save; PASSWORD_SAVE="$enableval"
 else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_AWK="$ac_prog"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
+  PASSWORD_SAVE="no"
 
 fi
+
+
+# Check whether --enable-iproute2 was given.
+if test "${enable_iproute2+set}" = set; then
+  enableval=$enable_iproute2; test $enableval = "yes" &&
+cat >>confdefs.h <<\_ACEOF
+#define CONFIG_FEATURE_IPROUTE 1
+_ACEOF
+
+
 fi
-AWK=$ac_cv_prog_AWK
-if test -n "$AWK"; then
-  { echo "$as_me:$LINENO: result: $AWK" >&5
-echo "${ECHO_T}$AWK" >&6; }
+
+
+# Check whether --enable-strict was given.
+if test "${enable_strict+set}" = set; then
+  enableval=$enable_strict; STRICT="$enableval"
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
+  STRICT="no"
 
+fi
 
-  test -n "$AWK" && break
-done
 
-{ echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
-echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6; }
-set x ${MAKE-make}; ac_make=`echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+# Check whether --enable-pedantic was given.
+if test "${enable_pedantic+set}" = set; then
+  enableval=$enable_pedantic; PEDANTIC="$enableval"
 else
-  cat >conftest.make <<\_ACEOF
-SHELL = /bin/sh
-all:
-	@echo '@@@%%%=$(MAKE)=@@@%%%'
-_ACEOF
-# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
-case `${MAKE-make} -f conftest.make 2>/dev/null` in
-  *@@@%%%=?*=@@@%%%*)
-    eval ac_cv_prog_make_${ac_make}_set=yes;;
-  *)
-    eval ac_cv_prog_make_${ac_make}_set=no;;
-esac
-rm -f conftest.make
+  PEDANTIC="no"
+
 fi
-if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
-  SET_MAKE=
+
+
+# Check whether --enable-profiling was given.
+if test "${enable_profiling+set}" = set; then
+  enableval=$enable_profiling; PROFILE="$enableval"
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-  SET_MAKE="MAKE=${MAKE-make}"
+  PROFILE="no"
+
 fi
 
-rm -rf .tst 2>/dev/null
-mkdir .tst 2>/dev/null
-if test -d .tst; then
-  am__leading_dot=.
+
+# Check whether --enable-strict-options was given.
+if test "${enable_strict_options+set}" = set; then
+  enableval=$enable_strict_options; STRICT_OPTIONS="$enableval"
 else
-  am__leading_dot=_
+  STRICT_OPTIONS="no"
+
 fi
-rmdir .tst 2>/dev/null
 
-# test to see if srcdir already configured
-if test "`cd $srcdir && pwd`" != "`pwd`" &&
-   test -f $srcdir/config.status; then
-  { { echo "$as_me:$LINENO: error: source directory already configured; run \"make distclean\" there first" >&5
-echo "$as_me: error: source directory already configured; run \"make distclean\" there first" >&2;}
-   { (exit 1); exit 1; }; }
+
+
+# Check whether --with-ssl-headers was given.
+if test "${with_ssl_headers+set}" = set; then
+  withval=$with_ssl_headers; CS_HDR_DIR="$withval"
+   CPPFLAGS="$CPPFLAGS -I$withval"
+
 fi
 
-# test whether we have cygpath
-if test -z "$CYGPATH_W"; then
-  if (cygpath --version) >/dev/null 2>/dev/null; then
-    CYGPATH_W='cygpath -w'
-  else
-    CYGPATH_W=echo
-  fi
+
+
+# Check whether --with-ssl-lib was given.
+if test "${with_ssl_lib+set}" = set; then
+  withval=$with_ssl_lib; LDFLAGS="$LDFLAGS -L$withval"
+
 fi
 
 
-# Define the identity of the package.
- PACKAGE=openvpn
- VERSION=$PACKAGE_VERSION
 
+# Check whether --with-lzo-headers was given.
+if test "${with_lzo_headers+set}" = set; then
+  withval=$with_lzo_headers; LZO_HDR_DIR="$withval"
+   CPPFLAGS="$CPPFLAGS -I$withval"
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE "$PACKAGE"
-_ACEOF
+fi
 
 
-cat >>confdefs.h <<_ACEOF
-#define VERSION "$VERSION"
-_ACEOF
 
-# Some tools Automake needs.
+# Check whether --with-lzo-lib was given.
+if test "${with_lzo_lib+set}" = set; then
+  withval=$with_lzo_lib; LDFLAGS="$LDFLAGS -L$withval"
 
-ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+fi
 
 
-AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
 
+# Check whether --with-pkcs11-helper-headers was given.
+if test "${with_pkcs11_helper_headers+set}" = set; then
+  withval=$with_pkcs11_helper_headers; PKCS11_HELPER_HDR_DIR="$withval"
+   CPPFLAGS="$CPPFLAGS -I$withval"
 
-AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+fi
 
 
-AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
 
+# Check whether --with-pkcs11-helper-lib was given.
+if test "${with_pkcs11_helper_lib+set}" = set; then
+  withval=$with_pkcs11_helper_lib; LDFLAGS="$LDFLAGS -L$withval"
 
-MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+fi
 
-install_sh=${install_sh-"$am_aux_dir/install-sh"}
 
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
-# tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-if test "$cross_compiling" != no; then
-  if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
+
+# Check whether --with-ifconfig-path was given.
+if test "${with_ifconfig_path+set}" = set; then
+  withval=$with_ifconfig_path; IFCONFIG="$withval"
+else
+  # Extract the first word of "ifconfig", so it can be a program name with args.
+set dummy ifconfig; ac_word=$2
 { echo "$as_me:$LINENO: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then
+if test "${ac_cv_path_IFCONFIG+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
+  case $IFCONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_IFCONFIG="$IFCONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_dummy="$PATH:/usr/local/sbin:/usr/sbin:/sbin"
+for as_dir in $as_dummy
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    ac_cv_path_IFCONFIG="$as_dir/$ac_word$ac_exec_ext"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -2699,39 +2705,55 @@
 done
 IFS=$as_save_IFS
 
+  test -z "$ac_cv_path_IFCONFIG" && ac_cv_path_IFCONFIG="ifconfig"
+  ;;
+esac
 fi
-fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { echo "$as_me:$LINENO: result: $STRIP" >&5
-echo "${ECHO_T}$STRIP" >&6; }
+IFCONFIG=$ac_cv_path_IFCONFIG
+if test -n "$IFCONFIG"; then
+  { echo "$as_me:$LINENO: result: $IFCONFIG" >&5
+echo "${ECHO_T}$IFCONFIG" >&6; }
 else
   { echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6; }
 fi
 
 
+
 fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
+
+
+cat >>confdefs.h <<_ACEOF
+#define IFCONFIG_PATH "$IFCONFIG"
+_ACEOF
+
+
+
+# Check whether --with-iproute-path was given.
+if test "${with_iproute_path+set}" = set; then
+  withval=$with_iproute_path; IPROUTE="$withval"
+else
+  # Extract the first word of "ip", so it can be a program name with args.
+set dummy ip; ac_word=$2
 { echo "$as_me:$LINENO: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
+if test "${ac_cv_path_IPROUTE+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
+  case $IPROUTE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_IPROUTE="$IPROUTE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_dummy="$PATH:/usr/local/sbin:/usr/sbin:/sbin"
+for as_dir in $as_dummy
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
+    ac_cv_path_IPROUTE="$as_dir/$ac_word$ac_exec_ext"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -2739,50 +2761,92 @@
 done
 IFS=$as_save_IFS
 
+  test -z "$ac_cv_path_IPROUTE" && ac_cv_path_IPROUTE="ip"
+  ;;
+esac
 fi
-fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
-echo "${ECHO_T}$ac_ct_STRIP" >&6; }
+IPROUTE=$ac_cv_path_IPROUTE
+if test -n "$IPROUTE"; then
+  { echo "$as_me:$LINENO: result: $IPROUTE" >&5
+echo "${ECHO_T}$IPROUTE" >&6; }
 else
   { echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6; }
 fi
 
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
+
+
+fi
+
+
+cat >>confdefs.h <<_ACEOF
+#define IPROUTE_PATH "$IPROUTE"
+_ACEOF
+
+
+
+
+# Check whether --with-route-path was given.
+if test "${with_route_path+set}" = set; then
+  withval=$with_route_path; ROUTE="$withval"
+else
+  # Extract the first word of "route", so it can be a program name with args.
+set dummy route; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_path_ROUTE+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $ROUTE in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_ROUTE="$ROUTE" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_dummy="$PATH:/usr/local/sbin:/usr/sbin:/sbin"
+for as_dir in $as_dummy
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_ROUTE="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
   fi
+done
+done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_ROUTE" && ac_cv_path_ROUTE="route"
+  ;;
+esac
+fi
+ROUTE=$ac_cv_path_ROUTE
+if test -n "$ROUTE"; then
+  { echo "$as_me:$LINENO: result: $ROUTE" >&5
+echo "${ECHO_T}$ROUTE" >&6; }
 else
-  STRIP="$ac_cv_prog_STRIP"
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
 fi
 
-fi
-INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
 
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
-# Always define AMTAR for backward compatibility.
 
-AMTAR=${AMTAR-"${am_missing_run}tar"}
+fi
 
-am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+
+cat >>confdefs.h <<_ACEOF
+#define ROUTE_PATH "$ROUTE"
+_ACEOF
 
 
 
+# Check whether --with-mem-check was given.
+if test "${with_mem_check+set}" = set; then
+  withval=$with_mem_check; MEMCHECK="$withval"
 
+fi
 
 
 CPPFLAGS="$CPPFLAGS -I${srcdir}"
@@ -2844,15 +2908,35 @@
 	CPPFLAGS="$CPPFLAGS -no-cpp-precomp"
 	;;
 *mingw*)
-	{ echo "$as_me:$LINENO: result: WARNING: configure support for mingw is incomplete" >&5
-echo "${ECHO_T}WARNING: configure support for mingw is incomplete" >&6; }
-	{ echo "$as_me:$LINENO: result: WARNING: use makefile.w32 instead" >&5
-echo "${ECHO_T}WARNING: use makefile.w32 instead" >&6; }
+
+cat >>confdefs.h <<\_ACEOF
+#define TARGET_WIN32 1
+_ACEOF
+
 
   LIBS="-lgdi32 $LIBS"
 
 
-  LIBS="-lwsock32 $LIBS"
+  LIBS="-lws2_32 $LIBS"
+
+
+  LIBS="-lwininet $LIBS"
+
+
+  LIBS="-lcrypt32 $LIBS"
+
+
+  LIBS="-liphlpapi $LIBS"
+
+
+  LIBS="-lwinmm $LIBS"
+
+	;;
+*dragonfly*)
+
+cat >>confdefs.h <<\_ACEOF
+#define TARGET_DRAGONFLY 1
+_ACEOF
 
 	;;
 
@@ -4476,6 +4560,55 @@
 fi
 
 
+if test "${WIN32}" = "yes"; then
+
+	for ac_prog in man2html
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_MAN2HTML+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$MAN2HTML"; then
+  ac_cv_prog_MAN2HTML="$MAN2HTML" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_MAN2HTML="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+MAN2HTML=$ac_cv_prog_MAN2HTML
+if test -n "$MAN2HTML"; then
+  { echo "$as_me:$LINENO: result: $MAN2HTML" >&5
+echo "${ECHO_T}$MAN2HTML" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+  test -n "$MAN2HTML" && break
+done
+
+	test -z "${MAN2HTML}" && { { echo "$as_me:$LINENO: error: man2html is required for win32" >&5
+echo "$as_me: error: man2html is required for win32" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
 { echo "$as_me:$LINENO: checking for ANSI C header files" >&5
 echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6; }
 if test "${ac_cv_header_stdc+set}" = set; then
@@ -5182,6 +5315,159 @@
 
 fi
 
+
+   { echo "$as_me:$LINENO: checking for socklen_t" >&5
+echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6; }
+if test "${ac_cv_type_socklen_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/socket.h>
+
+typedef socklen_t ac__type_new_;
+int
+main ()
+{
+if ((ac__type_new_ *) 0)
+  return 0;
+if (sizeof (ac__type_new_))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_type_socklen_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_socklen_t=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
+echo "${ECHO_T}$ac_cv_type_socklen_t" >&6; }
+if test $ac_cv_type_socklen_t = yes; then
+  :
+else
+
+      { echo "$as_me:$LINENO: checking for socklen_t equivalent" >&5
+echo $ECHO_N "checking for socklen_t equivalent... $ECHO_C" >&6; }
+      if test "${curl_cv_socklen_t_equiv+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+         # Systems have either "struct sockaddr *" or
+         # "void *" as the second argument to getpeername
+         curl_cv_socklen_t_equiv=
+         for arg2 in "struct sockaddr" void; do
+            for t in int size_t unsigned long "unsigned long"; do
+               cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+                  #ifdef _WIN32
+                  #include <windows.h>
+                  #define PREFIX1 WINSOCK_API_LINKAGE
+                  #define PREFIX2 PASCAL
+                  #else
+                  #include <sys/types.h>
+                  #include <sys/socket.h>
+                  #define PREFIX1
+                  #define PREFIX2
+                  #define SOCKET int
+                  #endif
+
+                  PREFIX1 int PREFIX2 getpeername (SOCKET, $arg2 *, $t *);
+
+int
+main ()
+{
+
+                  $t len;
+                  getpeername(0,0,&len);
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+
+                  curl_cv_socklen_t_equiv="$t"
+                  break
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+            done
+         done
+
+         if test "x$curl_cv_socklen_t_equiv" = x; then
+            { { echo "$as_me:$LINENO: error: Cannot find a type to use in place of socklen_t" >&5
+echo "$as_me: error: Cannot find a type to use in place of socklen_t" >&2;}
+   { (exit 1); exit 1; }; }
+         fi
+
+fi
+
+      { echo "$as_me:$LINENO: result: $curl_cv_socklen_t_equiv" >&5
+echo "${ECHO_T}$curl_cv_socklen_t_equiv" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define socklen_t $curl_cv_socklen_t_equiv
+_ACEOF
+
+fi
+
+
 { echo "$as_me:$LINENO: checking whether time.h and sys/time.h may both be included" >&5
 echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6; }
 if test "${ac_cv_header_time+set}" = set; then
@@ -5378,55 +5664,209 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 
-        cat >conftest.$ac_ext <<_ACEOF
-
-	        struct { int foo; int bar[]; } mystruct;
+        cat >conftest.$ac_ext <<_ACEOF
+
+	        struct { int foo; int bar[]; } mystruct;
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+
+
+cat >>confdefs.h <<_ACEOF
+#define EMPTY_ARRAY_SIZE
+_ACEOF
+
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+	        { { echo "$as_me:$LINENO: error: C compiler is unable to creaty empty arrays" >&5
+echo "$as_me: error: C compiler is unable to creaty empty arrays" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in fcntl.h stdlib.h 		 stdarg.h stdio.h string.h 		 strings.h ctype.h errno.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  { echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+ac_res=`eval echo '${'$as_ac_Header'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6; }
 
+# Is the header present?
+{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-
-
-cat >>confdefs.h <<_ACEOF
-#define EMPTY_ARRAY_SIZE
-_ACEOF
-
-
+       }; then
+  ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+  ac_header_preproc=no
+fi
 
-	        { { echo "$as_me:$LINENO: error: C compiler is unable to creaty empty arrays" >&5
-echo "$as_me: error: C compiler is unable to creaty empty arrays" >&2;}
-   { (exit 1); exit 1; }; }
+rm -f conftest.err conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6; }
 
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    ( cat <<\_ASBOX
+## -------------------------------------------------- ##
+## Report this to openvpn-users@lists.sourceforge.net ##
+## -------------------------------------------------- ##
+_ASBOX
+     ) | sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+{ echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_res=`eval echo '${'$as_ac_Header'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
 
 fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
 
+done
 
 
-{ echo "$as_me:$LINENO: checking for sys/wait.h that is POSIX.1 compatible" >&5
+if test "${WIN32}" != "yes"; then
+   { echo "$as_me:$LINENO: checking for sys/wait.h that is POSIX.1 compatible" >&5
 echo $ECHO_N "checking for sys/wait.h that is POSIX.1 compatible... $ECHO_C" >&6; }
 if test "${ac_cv_header_sys_wait_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -5528,7 +5968,8 @@
 
 
 
-for ac_header in sys/time.h sys/socket.h sys/ioctl.h sys/stat.h 		 sys/mman.h fcntl.h sys/file.h stdlib.h stdint.h 		 stdarg.h unistd.h signal.h stdio.h string.h 		 strings.h ctype.h errno.h syslog.h pwd.h grp.h 		 net/if_tun.h stropts.h sys/sockio.h 		 netinet/in.h netinet/in_systm.h 		 netinet/tcp.h arpa/inet.h 		 netdb.h sys/uio.h linux/if_tun.h linux/sockios.h 		 linux/types.h sys/poll.h sys/epoll.h err.h
+
+for ac_header in sys/time.h sys/socket.h sys/ioctl.h sys/stat.h 		 sys/mman.h fcntl.h sys/file.h stdlib.h stdint.h 		 stdarg.h unistd.h signal.h stdio.h string.h 		 strings.h ctype.h errno.h syslog.h pwd.h grp.h 		 net/if_tun.h net/tun/if_tun.h stropts.h sys/sockio.h 		 netinet/in.h netinet/in_systm.h 		 netinet/tcp.h arpa/inet.h 		 netdb.h sys/uio.h linux/if_tun.h linux/sockios.h 		 linux/types.h sys/poll.h sys/epoll.h err.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
@@ -5989,6 +6430,8 @@
 
 done
 
+fi
+
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -7643,107 +8086,101 @@
 rm -f confcache
 
 
-   { echo "$as_me:$LINENO: checking for socklen_t" >&5
-echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6; }
-if test "${ac_cv_type_socklen_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/socket.h>
 
-typedef socklen_t ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_type_socklen_t=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_socklen_t=no
-fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
-echo "${ECHO_T}$ac_cv_type_socklen_t" >&6; }
-if test $ac_cv_type_socklen_t = yes; then
-  :
-else
 
-      { echo "$as_me:$LINENO: checking for socklen_t equivalent" >&5
-echo $ECHO_N "checking for socklen_t equivalent... $ECHO_C" >&6; }
-      if test "${curl_cv_socklen_t_equiv+set}" = set; then
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_func in daemon chroot getpwnam setuid nice system getpid dup dup2 	       getpass strerror syslog openlog mlockall getgrnam setgid 	       setgroups stat flock readv writev setsockopt getsockopt 	       setsid chdir putenv getpeername unlink 	       poll chsize ftruncate sendmsg recvmsg getsockname 	       execve
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-
-         # Systems have either "struct sockaddr *" or
-         # "void *" as the second argument to getpeername
-         curl_cv_socklen_t_equiv=
-         for arg2 in "struct sockaddr" void; do
-            for t in int size_t unsigned long "unsigned long"; do
-               cat >conftest.$ac_ext <<_ACEOF
+  cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
 
-                  #include <sys/types.h>
-                  #include <sys/socket.h>
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
 
-                  int getpeername (int, $arg2 *, $t *);
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
 
 int
 main ()
 {
-
-                  $t len;
-                  getpeername(0,0,&len);
-
+return $ac_func ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+  (eval "$ac_link") 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
@@ -7752,41 +8189,115 @@
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-
-                  curl_cv_socklen_t_equiv="$t"
-                  break
-
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+	eval "$as_ac_var=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval echo '${'$as_ac_var'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
 fi
+done
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-            done
-         done
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
 
-         if test "x$curl_cv_socklen_t_equiv" = x; then
-            { { echo "$as_me:$LINENO: error: Cannot find a type to use in place of socklen_t" >&5
-echo "$as_me: error: Cannot find a type to use in place of socklen_t" >&2;}
-   { (exit 1); exit 1; }; }
-         fi
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
+echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      *) $as_unset $ac_var ;;
+      esac ;;
+    esac
+  done
 
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { echo "$as_me:$LINENO: updating cache $cache_file" >&5
+echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
+echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
 fi
+rm -f confcache
 
-      { echo "$as_me:$LINENO: result: $curl_cv_socklen_t_equiv" >&5
-echo "${ECHO_T}$curl_cv_socklen_t_equiv" >&6; }
+if test "${WIN32}" = "yes"; then
 
-cat >>confdefs.h <<_ACEOF
-#define socklen_t $curl_cv_socklen_t_equiv
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETTIMEOFDAY 1
 _ACEOF
 
-fi
 
+else
 
-{ echo "$as_me:$LINENO: checking return type of signal handlers" >&5
+		{ echo "$as_me:$LINENO: checking return type of signal handlers" >&5
 echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6; }
 if test "${ac_cv_type_signal+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -7844,7 +8355,7 @@
 
 
 
-{ echo "$as_me:$LINENO: checking for library containing socket" >&5
+		{ echo "$as_me:$LINENO: checking for library containing socket" >&5
 echo $ECHO_N "checking for library containing socket... $ECHO_C" >&6; }
 if test "${ac_cv_search_socket+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -7928,7 +8439,7 @@
 fi
 
 
-{ echo "$as_me:$LINENO: checking for library containing inet_ntoa" >&5
+		{ echo "$as_me:$LINENO: checking for library containing inet_ntoa" >&5
 echo $ECHO_N "checking for library containing inet_ntoa... $ECHO_C" >&6; }
 if test "${ac_cv_search_inet_ntoa+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -8012,7 +8523,7 @@
 fi
 
 
-{ echo "$as_me:$LINENO: checking for library containing gethostbyname" >&5
+		{ echo "$as_me:$LINENO: checking for library containing gethostbyname" >&5
 echo $ECHO_N "checking for library containing gethostbyname... $ECHO_C" >&6; }
 if test "${ac_cv_search_gethostbyname+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -8589,14 +9100,98 @@
 
 
 
+for ac_func in gettimeofday
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
 
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
 
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 
+#undef $ac_func
 
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
 
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
+	eval "$as_ac_var=no"
+fi
 
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval echo '${'$as_ac_var'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
+fi
+done
 
 
 
@@ -8616,13 +9211,7 @@
 
 
 
-
-
-
-
-
-
-for ac_func in daemon chroot getpwnam setuid nice system getpid dup dup2 	       getpass strerror syslog openlog mlockall getgrnam setgid 	       setgroups stat flock readv writev setsockopt getsockopt 	       setsid chdir gettimeofday putenv getpeername unlink                poll chsize ftruncate sendmsg recvmsg getsockname
+for ac_func in socket recv recvfrom send sendto listen 		       accept connect bind select gethostbyname 		       inet_ntoa time ctime memset vsnprintf strdup
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 { echo "$as_me:$LINENO: checking for $ac_func" >&5
@@ -8712,82 +9301,15 @@
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
+else
+  { { echo "$as_me:$LINENO: error: Required library function not found" >&5
+echo "$as_me: error: Required library function not found" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+done
+
+
 fi
-done
-
-cat >confcache <<\_ACEOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs, see configure's option --config-cache.
-# It is not useful on other systems.  If it contains results you don't
-# want to keep, you may remove or edit it.
-#
-# config.status only pays attention to the cache file if you give it
-# the --recheck option to rerun configure.
-#
-# `ac_cv_env_foo' variables (set or unset) will be overridden when
-# loading this file, other *unset* `ac_cv_foo' will be assigned the
-# following values.
-
-_ACEOF
-
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, we kill variables containing newlines.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-(
-  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      *) $as_unset $ac_var ;;
-      esac ;;
-    esac
-  done
-
-  (set) 2>&1 |
-    case $as_nl`(ac_space=' '; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      # `set' does not quote correctly, so add quotes (double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \).
-      sed -n \
-	"s/'/'\\\\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
-      ;; #(
-    *)
-      # `set' quotes correctly as required by POSIX, so do not add quotes.
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-) |
-  sed '
-     /^ac_cv_env_/b end
-     t clear
-     :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
-     t end
-     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
-     :end' >>confcache
-if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
-  if test -w "$cache_file"; then
-    test "x$cache_file" != "x/dev/null" &&
-      { echo "$as_me:$LINENO: updating cache $cache_file" >&5
-echo "$as_me: updating cache $cache_file" >&6;}
-    cat confcache >$cache_file
-  else
-    { echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
-echo "$as_me: not updating unwritable cache $cache_file" >&6;}
-  fi
-fi
-rm -f confcache
 
 { echo "$as_me:$LINENO: checking for working memcmp" >&5
 echo $ECHO_N "checking for working memcmp... $ECHO_C" >&6; }
@@ -8880,72 +9402,21 @@
 
 
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-for ac_func in socket recv recvfrom send sendto listen 	       accept connect bind select gethostbyname                inet_ntoa time ctime memset vsnprintf strdup
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
 
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
+    #include <resolv.h>
 
 int
 main ()
 {
-return $ac_func ();
+
+    res_init ();
+
   ;
   return 0;
 }
@@ -8968,45 +9439,36 @@
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext &&
        $as_test_x conftest$ac_exeext; then
-  eval "$as_ac_var=yes"
+
+    { echo "$as_me:$LINENO: result: res_init DEFINED" >&5
+echo "${ECHO_T}res_init DEFINED" >&6; }
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_RES_INIT 1
+_ACEOF
+
+
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
-fi
 
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+    { echo "$as_me:$LINENO: result: res_init UNDEFINED" >&5
+echo "${ECHO_T}res_init UNDEFINED" >&6; }
 
-else
-  { { echo "$as_me:$LINENO: error: Required library function not found" >&5
-echo "$as_me: error: Required library function not found" >&2;}
-   { (exit 1); exit 1; }; }
 fi
-done
 
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
 
 
 { echo "$as_me:$LINENO: checking for working epoll implementation..." >&5
 echo "$as_me: checking for working epoll implementation..." >&6;}
 OLDLDFLAGS="$LDFLAGS"
 LDFLAGS="$LDFLAGS -Wl,--fatal-warnings"
-
-for ac_func in epoll_create
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+{ echo "$as_me:$LINENO: checking for epoll_create" >&5
+echo $ECHO_N "checking for epoll_create... $ECHO_C" >&6; }
+if test "${ac_cv_func_epoll_create+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -9015,12 +9477,12 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+/* Define epoll_create to an innocuous variant, in case <limits.h> declares epoll_create.
    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
+#define epoll_create innocuous_epoll_create
 
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
+    which can conflict with char epoll_create (); below.
     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
     <limits.h> exists even on freestanding compilers.  */
 
@@ -9030,7 +9492,7 @@
 # include <assert.h>
 #endif
 
-#undef $ac_func
+#undef epoll_create
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -9038,18 +9500,18 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char $ac_func ();
+char epoll_create ();
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
+#if defined __stub_epoll_create || defined __stub___epoll_create
 choke me
 #endif
 
 int
 main ()
 {
-return $ac_func ();
+return epoll_create ();
   ;
   return 0;
 }
@@ -9072,30 +9534,26 @@
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext &&
        $as_test_x conftest$ac_exeext; then
-  eval "$as_ac_var=yes"
+  ac_cv_func_epoll_create=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
+	ac_cv_func_epoll_create=no
 fi
 
 rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
       conftest$ac_exeext conftest.$ac_ext
 fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
- cat >>confdefs.h <<\_ACEOF
+{ echo "$as_me:$LINENO: result: $ac_cv_func_epoll_create" >&5
+echo "${ECHO_T}$ac_cv_func_epoll_create" >&6; }
+if test $ac_cv_func_epoll_create = yes; then
+
+cat >>confdefs.h <<\_ACEOF
 #define HAVE_EPOLL_CREATE 1
 _ACEOF
 
 fi
-done
 
 LDFLAGS="$OLDLDFLAGS"
 
@@ -9916,10 +10374,11 @@
 
 fi
 
-if test "$PLUGINS" = "yes"; then
-   { echo "$as_me:$LINENO: checking for libdl Library and Header files..." >&5
+if test "${WIN32}" != "yes"; then
+   if test "$PLUGINS" = "yes"; then
+      { echo "$as_me:$LINENO: checking for libdl Library and Header files..." >&5
 echo "$as_me: checking for libdl Library and Header files..." >&6;}
-   if test "${ac_cv_header_dlfcn_h+set}" = set; then
+      if test "${ac_cv_header_dlfcn_h+set}" = set; then
   { echo "$as_me:$LINENO: checking for dlfcn.h" >&5
 echo $ECHO_N "checking for dlfcn.h... $ECHO_C" >&6; }
 if test "${ac_cv_header_dlfcn_h+set}" = set; then
@@ -10225,6 +10684,70 @@
 fi
 
 
+   fi
+fi
+
+if test "${WIN32}" = "yes"; then
+   if test "$PLUGINS" = "yes"; then
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+	    #include <windows.h>
+
+int
+main ()
+{
+
+	    LoadLibrary (NULL);
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+
+	    { echo "$as_me:$LINENO: result: LoadLibrary DEFINED" >&5
+echo "${ECHO_T}LoadLibrary DEFINED" >&6; }
+
+cat >>confdefs.h <<\_ACEOF
+#define USE_LOAD_LIBRARY 1
+_ACEOF
+
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+	    { echo "$as_me:$LINENO: result: LoadLibrary UNDEFINED" >&5
+echo "${ECHO_T}LoadLibrary UNDEFINED" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+   fi
 fi
 
 
@@ -10823,7 +11346,7 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-		       #include "openssl/evp.h"
+		       #include <openssl/evp.h>
 		       #if SSLEAY_VERSION_NUMBER >= 0x00906000L
 		         yes
 		       #endif
@@ -10837,9 +11360,15 @@
 #define USE_CRYPTO 1
 _ACEOF
 
+                       if test "${WIN32}" = "yes"; then
+
+  LIBS="-leay32 $LIBS"
+
+                       else
 
   LIBS="-lcrypto $LIBS"
 
+                       fi
 
 for ac_func in EVP_CIPHER_CTX_set_key_length
 do
@@ -11689,9 +12218,15 @@
 #define USE_SSL 1
 _ACEOF
 
+      if test "${WIN32}" = "yes"; then
+
+  LIBS="-lssl32 $LIBS"
+
+      else
 
   LIBS="-lssl $LIBS"
 
+      fi
    fi
 fi
 
@@ -11997,7 +12532,7 @@
 fi
 
 if test "$STRICT" = "yes"; then
-   CFLAGS="$CFLAGS -Wall -Wpointer-arith -Wsign-compare -Wno-unused-parameter -Wno-unused-function"
+   CFLAGS="$CFLAGS -Wall -Wno-unused-parameter -Wno-unused-function"
 fi
 
 if test "$PEDANTIC" = "yes"; then
@@ -12024,7 +12559,53 @@
 
 fi
 
-ac_config_files="$ac_config_files Makefile openvpn.spec"
+TAP_ID="tap0901"
+TAP_WIN32_MIN_MAJOR="9"
+TAP_WIN32_MIN_MINOR="1"
+
+cat >>confdefs.h <<_ACEOF
+#define TAP_ID "${TAP_ID}"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define TAP_WIN32_MIN_MAJOR ${TAP_WIN32_MIN_MAJOR}
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define TAP_WIN32_MIN_MINOR ${TAP_WIN32_MIN_MINOR}
+_ACEOF
+
+
+
+
+
+win32datadir="\${datadir}/${PACKAGE}-win32"
+
+
+
+if test "${WIN32}" = "yes"; then
+  WIN32_TRUE=
+  WIN32_FALSE='#'
+else
+  WIN32_TRUE='#'
+  WIN32_FALSE=
+fi
+
+
+# workaround for <autoconf-2.60
+if test -z "${docdir}"; then
+	docdir="\$(datarootdir)/doc/\$(PACKAGE_NAME)"
+
+fi
+if test -z "${htmldir}"; then
+	htmldir="\$(docdir)"
+
+fi
+# end workaround
+
+ac_config_files="$ac_config_files Makefile openvpn.spec config-win32.h images/Makefile service-win32/Makefile install-win32/Makefile install-win32/settings"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -12136,6 +12717,13 @@
 Usually this means the macro was only invoked conditionally." >&2;}
    { (exit 1); exit 1; }; }
 fi
+if test -z "${WIN32_TRUE}" && test -z "${WIN32_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"WIN32\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"WIN32\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
 
 : ${CONFIG_STATUS=./config.status}
 ac_clean_files_save=$ac_clean_files
@@ -12436,7 +13024,7 @@
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by OpenVPN $as_me 2.1_rc7, which was
+This file was extended by OpenVPN $as_me 2.1_rc9, which was
 generated by GNU Autoconf 2.61.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -12489,7 +13077,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-OpenVPN config.status 2.1_rc7
+OpenVPN config.status 2.1_rc9
 configured by $0, generated by GNU Autoconf 2.61,
   with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
@@ -12606,6 +13194,11 @@
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
     "openvpn.spec") CONFIG_FILES="$CONFIG_FILES openvpn.spec" ;;
+    "config-win32.h") CONFIG_FILES="$CONFIG_FILES config-win32.h" ;;
+    "images/Makefile") CONFIG_FILES="$CONFIG_FILES images/Makefile" ;;
+    "service-win32/Makefile") CONFIG_FILES="$CONFIG_FILES service-win32/Makefile" ;;
+    "install-win32/Makefile") CONFIG_FILES="$CONFIG_FILES install-win32/Makefile" ;;
+    "install-win32/settings") CONFIG_FILES="$CONFIG_FILES install-win32/settings" ;;
 
   *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
 echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
@@ -12705,9 +13298,6 @@
 build_alias!$build_alias$ac_delim
 host_alias!$host_alias$ac_delim
 target_alias!$target_alias$ac_delim
-IFCONFIG!$IFCONFIG$ac_delim
-IPROUTE!$IPROUTE$ac_delim
-ROUTE!$ROUTE$ac_delim
 build!$build$ac_delim
 build_cpu!$build_cpu$ac_delim
 build_vendor!$build_vendor$ac_delim
@@ -12741,6 +13331,9 @@
 AMTAR!$AMTAR$ac_delim
 am__tar!$am__tar$ac_delim
 am__untar!$am__untar$ac_delim
+IFCONFIG!$IFCONFIG$ac_delim
+IPROUTE!$IPROUTE$ac_delim
+ROUTE!$ROUTE$ac_delim
 CC!$CC$ac_delim
 CFLAGS!$CFLAGS$ac_delim
 LDFLAGS!$LDFLAGS$ac_delim
@@ -12760,11 +13353,11 @@
 CPP!$CPP$ac_delim
 GREP!$GREP$ac_delim
 EGREP!$EGREP$ac_delim
+MAN2HTML!$MAN2HTML$ac_delim
 LIBOBJS!$LIBOBJS$ac_delim
 PTHREAD_CC!$PTHREAD_CC$ac_delim
 PTHREAD_LIBS!$PTHREAD_LIBS$ac_delim
 PTHREAD_CFLAGS!$PTHREAD_CFLAGS$ac_delim
-LTLIBOBJS!$LTLIBOBJS$ac_delim
 _ACEOF
 
   if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 97; then
@@ -12803,6 +13396,56 @@
 _ACEOF
 
 
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  cat >conf$$subs.sed <<_ACEOF
+TAP_ID!$TAP_ID$ac_delim
+TAP_WIN32_MIN_MAJOR!$TAP_WIN32_MIN_MAJOR$ac_delim
+TAP_WIN32_MIN_MINOR!$TAP_WIN32_MIN_MINOR$ac_delim
+win32datadir!$win32datadir$ac_delim
+WIN32_TRUE!$WIN32_TRUE$ac_delim
+WIN32_FALSE!$WIN32_FALSE$ac_delim
+LTLIBOBJS!$LTLIBOBJS$ac_delim
+_ACEOF
+
+  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 7; then
+    break
+  elif $ac_last_try; then
+    { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+ac_eof=`sed -n '/^CEOF[0-9]*$/s/CEOF/0/p' conf$$subs.sed`
+if test -n "$ac_eof"; then
+  ac_eof=`echo "$ac_eof" | sort -nru | sed 1q`
+  ac_eof=`expr $ac_eof + 1`
+fi
+
+cat >>$CONFIG_STATUS <<_ACEOF
+cat >"\$tmp/subs-2.sed" <<\CEOF$ac_eof
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b end
+_ACEOF
+sed '
+s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g
+s/^/s,@/; s/!/@,|#_!!_#|/
+:n
+t n
+s/'"$ac_delim"'$/,g/; t
+s/$/\\/; p
+N; s/^.*\n//; s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g; b n
+' >>$CONFIG_STATUS <conf$$subs.sed
+rm -f conf$$subs.sed
+cat >>$CONFIG_STATUS <<_ACEOF
+:end
+s/|#_!!_#|//g
+CEOF$ac_eof
+_ACEOF
+
+
 # VPATH may cause trouble with some makes, so we remove $(srcdir),
 # ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
 # trailing colons and then remove the whole line if VPATH becomes empty
@@ -13046,7 +13689,7 @@
 s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
 s&@INSTALL@&$ac_INSTALL&;t t
 $ac_datarootdir_hack
-" $ac_file_inputs | sed -f "$tmp/subs-1.sed" | sed 's/|#_!!_#|//g' >$tmp/out
+" $ac_file_inputs | sed -f "$tmp/subs-1.sed" | sed -f "$tmp/subs-2.sed" >$tmp/out
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
   { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
diff -urN openvpn-2.1_rc7/configure.ac openvpn-2.1_rc9/configure.ac
--- openvpn-2.1_rc7/configure.ac	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/configure.ac	2008-07-23 22:49:38.000000000 +0200
@@ -4,7 +4,7 @@
 dnl             packet encryption, packet authentication, and
 dnl             packet compression.
 dnl
-dnl  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+dnl  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
 dnl
 dnl  This program is free software; you can redistribute it and/or modify
 dnl  it under the terms of the GNU General Public License as published by
@@ -30,6 +30,39 @@
 AM_CONFIG_HEADER(config.h)
 AC_CONFIG_SRCDIR(syshead.h)
 
+dnl Guess host type.
+AC_CANONICAL_HOST
+AC_CANONICAL_SYSTEM
+AM_INIT_AUTOMAKE(openvpn, [$PACKAGE_VERSION])
+
+AC_ARG_WITH(cygwin-native,
+	[  --with-cygwin-native              Compile native win32],
+	[CYGWIN_NATIVE="${withval}"],
+	[CYGWIN_NATIVE="no"]
+)
+
+WIN32="no"
+CYGWIN="no"
+case "${host}" in
+	*-mingw32*)
+		WIN32="yes"
+		cross_compiling="yes"
+	;;
+	*-cygwin*)
+		AC_MSG_CHECKING([cygwin mode to use])
+		if test "${CYGWIN_NATIVE}" = "yes"; then
+			AC_MSG_RESULT([Using native win32])
+			CFLAGS="${CFLAGS} -mno-cygwin"
+			CYGWIN="yes"
+			WIN32="yes"
+		else
+			AC_MSG_RESULT([Using cygwin])
+		fi
+	;;
+	*)
+	;;
+esac
+
 AC_ARG_ENABLE(lzo,
    [  --disable-lzo           Disable LZO compression support],
    [LZO="$enableval"],
@@ -183,6 +216,17 @@
    [LDFLAGS="$LDFLAGS -L$withval"] 
 )
 
+AC_ARG_WITH(pkcs11-helper-headers,
+   [  --with-pkcs11-helper-headers=DIR pkcs11-helper Include files location],
+   [PKCS11_HELPER_HDR_DIR="$withval"]
+   [CPPFLAGS="$CPPFLAGS -I$withval"] 
+)
+
+AC_ARG_WITH(pkcs11-helper-lib,
+   [  --with-pkcs11-helper-lib=DIR     pkcs11-helper Library location],
+   [LDFLAGS="$LDFLAGS -L$withval"] 
+)
+
 AC_ARG_WITH(ifconfig-path,
    [  --with-ifconfig-path=PATH   Path to ifconfig tool],
    [IFCONFIG="$withval"],
@@ -210,11 +254,6 @@
    [MEMCHECK="$withval"]
 )
 
-dnl Guess host type.
-AC_CANONICAL_HOST
-AC_CANONICAL_SYSTEM
-AM_INIT_AUTOMAKE(openvpn, [$PACKAGE_VERSION])
-
 dnl fix search path, to allow compilers to find syshead.h
 CPPFLAGS="$CPPFLAGS -I${srcdir}"
 
@@ -250,10 +289,16 @@
 	CPPFLAGS="$CPPFLAGS -no-cpp-precomp"
 	;;
 *mingw*)
-	AC_MSG_RESULT([WARNING: configure support for mingw is incomplete])
-	AC_MSG_RESULT([WARNING: use makefile.w32 instead])
+	AC_DEFINE(TARGET_WIN32, 1, [Are we running WIN32?])
 	OPENVPN_ADD_LIBS(-lgdi32)
-	OPENVPN_ADD_LIBS(-lwsock32)
+	OPENVPN_ADD_LIBS(-lws2_32)
+	OPENVPN_ADD_LIBS(-lwininet)
+	OPENVPN_ADD_LIBS(-lcrypt32)
+	OPENVPN_ADD_LIBS(-liphlpapi)
+	OPENVPN_ADD_LIBS(-lwinmm)
+	;;
+*dragonfly*)
+	AC_DEFINE(TARGET_DRAGONFLY, 1, [Are we running on DragonFlyBSD?])
 	;;
 	
 esac
@@ -263,6 +308,12 @@
 AC_PROG_INSTALL
 AC_PROG_GCC_TRADITIONAL
 
+if test "${WIN32}" = "yes"; then
+	AC_ARG_VAR([MAN2HTML], [man2html utility])
+	AC_CHECK_PROGS([MAN2HTML], [man2html])
+	test -z "${MAN2HTML}" && AC_MSG_ERROR([man2html is required for win32])
+fi
+
 dnl Checks for header files.
 AC_HEADER_STDC
 
@@ -274,29 +325,36 @@
 AC_TYPE_PID_T
 AC_TYPE_SIZE_T
 AC_TYPE_UID_T
+TYPE_SOCKLEN_T
 AC_HEADER_TIME
 AX_CPP_VARARG_MACRO_ISO
 AX_CPP_VARARG_MACRO_GCC
 AX_EMPTY_ARRAY
 
 dnl Check for more header files.
-AC_HEADER_SYS_WAIT
-AC_CHECK_HEADERS(sys/time.h sys/socket.h sys/ioctl.h sys/stat.h dnl
+AC_CHECK_HEADERS(fcntl.h stdlib.h dnl
+		 stdarg.h stdio.h string.h dnl
+		 strings.h ctype.h errno.h dnl
+)
+
+if test "${WIN32}" != "yes"; then
+   AC_HEADER_SYS_WAIT
+   AC_CHECK_HEADERS(sys/time.h sys/socket.h sys/ioctl.h sys/stat.h dnl
 		 sys/mman.h fcntl.h sys/file.h stdlib.h stdint.h dnl
 		 stdarg.h unistd.h signal.h stdio.h string.h dnl
 		 strings.h ctype.h errno.h syslog.h pwd.h grp.h dnl
-		 net/if_tun.h stropts.h sys/sockio.h dnl
+		 net/if_tun.h net/tun/if_tun.h stropts.h sys/sockio.h dnl
 		 netinet/in.h netinet/in_systm.h dnl
 		 netinet/tcp.h arpa/inet.h dnl
 		 netdb.h sys/uio.h linux/if_tun.h linux/sockios.h dnl
 		 linux/types.h sys/poll.h sys/epoll.h err.h dnl
-)
-AC_CHECK_HEADERS(net/if.h,,,
+   )
+   AC_CHECK_HEADERS(net/if.h,,,
 		 [#ifdef HAVE_SYS_SOCKET_H 
 		  # include <sys/socket.h>
 		  #endif
 		 ])
-AC_CHECK_HEADERS(netinet/ip.h,,,
+   AC_CHECK_HEADERS(netinet/ip.h,,,
 		 [#ifdef HAVE_SYS_TYPES_H
 		  # include <sys/types.h>
 		  #endif
@@ -307,7 +365,7 @@
 		  # include <netinet/in_systm.h>
 		  #endif
 		 ])
-AC_CHECK_HEADERS(netinet/if_ether.h,,,
+   AC_CHECK_HEADERS(netinet/if_ether.h,,,
 		 [#ifdef HAVE_SYS_TYPES_H
 		  # include <sys/types.h>
 		  #endif
@@ -318,16 +376,18 @@
 		  # include <netinet/in.h>
 		  #endif
 		 ])
-AC_CHECK_HEADERS(resolv.h,,,
+   AC_CHECK_HEADERS(resolv.h,,,
 		 [#ifdef HAVE_NETINET_IN_H 
 		  # include <netinet/in.h>
 		  #endif
 		 ])
-AC_CHECK_HEADERS(linux/errqueue.h,,,
+   AC_CHECK_HEADERS(linux/errqueue.h,,,
 	[#ifdef HAVE_LINUX_TYPES_H
 	 # include <linux/types.h>
 	 #endif
 	])
+fi
+
 AC_CACHE_SAVE
 
 dnl check that in_addr_t is defined
@@ -398,35 +458,60 @@
 
 AC_CACHE_SAVE
 
-dnl check for other types
-TYPE_SOCKLEN_T
-AC_TYPE_SIGNAL
-
-dnl Check for libsocket
-AC_SEARCH_LIBS(socket, socket)
-
-dnl Check for libnsl
-AC_SEARCH_LIBS(inet_ntoa, nsl)
-
-dnl Check for libresolv
-AC_SEARCH_LIBS(gethostbyname, resolv nsl)
-
-dnl optional library functions
-AC_FUNC_FORK
 AC_CHECK_FUNCS(daemon chroot getpwnam setuid nice system getpid dup dup2 dnl
 	       getpass strerror syslog openlog mlockall getgrnam setgid dnl
 	       setgroups stat flock readv writev setsockopt getsockopt dnl
-	       setsid chdir gettimeofday putenv getpeername unlink dnl
-               poll chsize ftruncate sendmsg recvmsg getsockname)
+	       setsid chdir putenv getpeername unlink dnl
+	       poll chsize ftruncate sendmsg recvmsg getsockname dnl
+	       execve)
 AC_CACHE_SAVE
 
+if test "${WIN32}" = "yes"; then
+
+	AC_DEFINE([HAVE_GETTIMEOFDAY], [1], [We fake gettimeofday for win32 at otime.c])
+
+else
+
+	dnl check for other types
+	AC_TYPE_SIGNAL
+
+	dnl Check for libsocket
+	AC_SEARCH_LIBS(socket, socket)
+
+	dnl Check for libnsl
+	AC_SEARCH_LIBS(inet_ntoa, nsl)
+
+	dnl Check for libresolv
+	AC_SEARCH_LIBS(gethostbyname, resolv nsl)
+
+	dnl optional library functions
+	AC_FUNC_FORK
+
+	AC_CHECK_FUNCS(gettimeofday)
+
+	AC_CHECK_FUNCS(socket recv recvfrom send sendto listen dnl
+		       accept connect bind select gethostbyname dnl
+		       inet_ntoa time ctime memset vsnprintf strdup, [],
+		       [AC_MSG_ERROR([Required library function not found])])
+
+fi
+
 dnl Required library functions
 AC_FUNC_MEMCMP
 
-AC_CHECK_FUNCS(socket recv recvfrom send sendto listen dnl
-	       accept connect bind select gethostbyname dnl
-               inet_ntoa time ctime memset vsnprintf strdup, [],
-	       [AC_MSG_ERROR([Required library function not found])])
+dnl
+dnl Check for res_init
+dnl
+AC_TRY_LINK([
+    #include <resolv.h>
+  ], [
+    res_init ();
+  ], [
+    AC_MSG_RESULT([res_init DEFINED])
+    AC_DEFINE([HAVE_RES_INIT], 1, [Indicates if res_init is available])
+  ], [
+    AC_MSG_RESULT([res_init UNDEFINED])
+  ])
 
 dnl
 dnl check libraries
@@ -436,7 +521,7 @@
 AC_CHECKING([for working epoll implementation])
 OLDLDFLAGS="$LDFLAGS"
 LDFLAGS="$LDFLAGS -Wl,--fatal-warnings"
-AC_CHECK_FUNCS(epoll_create, AC_DEFINE([HAVE_EPOLL_CREATE], 1, []))
+AC_CHECK_FUNC(epoll_create, AC_DEFINE(HAVE_EPOLL_CREATE, 1, [epoll_create function is defined]))
 LDFLAGS="$OLDLDFLAGS"
 
 dnl
@@ -505,21 +590,41 @@
 dnl
 dnl Check for dlopen -- first try libc then libdl.
 dnl
-if test "$PLUGINS" = "yes"; then
-   AC_CHECKING([for libdl Library and Header files])
-   AC_CHECK_HEADER(dlfcn.h,
-        [AC_CHECK_FUNC(dlopen,
-            [AC_DEFINE(USE_LIBDL, 1, [Use libdl for dynamic library loading])],
-            [AC_CHECK_LIB(dl, dlopen,
-	        [
-                   OPENVPN_ADD_LIBS(-ldl)
-	           AC_DEFINE(USE_LIBDL, 1, [Use libdl for dynamic library loading])
-	        ],
-	        [AC_MSG_RESULT([libdl library not found.])]
-	    )],
-        )],
-        [AC_MSG_RESULT([libdl headers not found.])]
-   )
+if test "${WIN32}" != "yes"; then
+   if test "$PLUGINS" = "yes"; then
+      AC_CHECKING([for libdl Library and Header files])
+      AC_CHECK_HEADER(dlfcn.h,
+           [AC_CHECK_FUNC(dlopen,
+               [AC_DEFINE(USE_LIBDL, 1, [Use libdl for dynamic library loading])],
+               [AC_CHECK_LIB(dl, dlopen,
+	           [
+                      OPENVPN_ADD_LIBS(-ldl)
+	              AC_DEFINE(USE_LIBDL, 1, [Use libdl for dynamic library loading])
+	           ],
+	           [AC_MSG_RESULT([libdl library not found.])]
+	       )],
+           )],
+           [AC_MSG_RESULT([libdl headers not found.])]
+      )
+   fi
+fi
+
+dnl
+dnl Check if LoadLibrary exists on Windows
+dnl
+if test "${WIN32}" = "yes"; then
+   if test "$PLUGINS" = "yes"; then
+	AC_TRY_LINK([
+	    #include <windows.h>
+	  ], [
+	    LoadLibrary (NULL);
+	  ], [
+	    AC_MSG_RESULT([LoadLibrary DEFINED])
+	    AC_DEFINE(USE_LOAD_LIBRARY, 1, [Use LoadLibrary to load DLLs on Windows])
+	  ], [
+	    AC_MSG_RESULT([LoadLibrary UNDEFINED])
+	  ])
+   fi
 fi
 
 dnl
@@ -572,14 +677,18 @@
 		   AC_CHECKING([that OpenSSL Library is at least version 0.9.6])
 		   AC_EGREP_CPP(yes,
 		     [
-		       #include "openssl/evp.h"
+		       #include <openssl/evp.h>
 		       #if SSLEAY_VERSION_NUMBER >= 0x00906000L
 		         yes
 		       #endif
 		     ],
 		     [
                        AC_DEFINE(USE_CRYPTO, 1, [Use OpenSSL crypto library])
-                       OPENVPN_ADD_LIBS(-lcrypto)
+                       if test "${WIN32}" = "yes"; then
+                         OPENVPN_ADD_LIBS(-leay32)
+                       else
+                         OPENVPN_ADD_LIBS(-lcrypto)
+                       fi
                        AC_CHECK_FUNCS(EVP_CIPHER_CTX_set_key_length)
 
 		       dnl check for OpenSSL crypto acceleration capability
@@ -621,7 +730,11 @@
 	   [AC_MSG_ERROR([OpenSSL SSL headers not found.])]
       )
       AC_DEFINE(USE_SSL, 1, [Use OpenSSL SSL library])
-      OPENVPN_ADD_LIBS(-lssl)
+      if test "${WIN32}" = "yes"; then
+        OPENVPN_ADD_LIBS(-lssl32)
+      else
+        OPENVPN_ADD_LIBS(-lssl)
+      fi
    fi
 fi
 
@@ -692,7 +805,7 @@
 
 dnl enable strict compiler warnings
 if test "$STRICT" = "yes"; then
-   CFLAGS="$CFLAGS -Wall -Wpointer-arith -Wsign-compare -Wno-unused-parameter -Wno-unused-function"
+   CFLAGS="$CFLAGS -Wall -Wno-unused-parameter -Wno-unused-function"
 fi
 
 dnl enable pedantic compiler warnings
@@ -715,4 +828,37 @@
    AC_DEFINE(ENABLE_PASSWORD_SAVE, 1, [Allow --askpass and --auth-user-pass passwords to be read from a file])
 fi
 
-AC_OUTPUT(Makefile openvpn.spec)
+TAP_ID="PRODUCT_TAP_ID"
+TAP_WIN32_MIN_MAJOR="PRODUCT_TAP_WIN32_MIN_MAJOR"
+TAP_WIN32_MIN_MINOR="PRODUCT_TAP_WIN32_MIN_MINOR"
+AC_DEFINE_UNQUOTED(TAP_ID, "${TAP_ID}", [The TAP-Win32 id defined in tap-win32/SOURCES])
+AC_DEFINE_UNQUOTED(TAP_WIN32_MIN_MAJOR, ${TAP_WIN32_MIN_MAJOR}, [The TAP-Win32 version number is defined in tap-win32/SOURCES])
+AC_DEFINE_UNQUOTED(TAP_WIN32_MIN_MINOR, ${TAP_WIN32_MIN_MINOR}, [The TAP-Win32 version number is defined in tap-win32/SOURCES])
+AC_SUBST(TAP_ID)
+AC_SUBST(TAP_WIN32_MIN_MAJOR)
+AC_SUBST(TAP_WIN32_MIN_MINOR)
+
+win32datadir="\${datadir}/${PACKAGE}-win32"
+AC_SUBST(win32datadir)
+AM_CONDITIONAL(WIN32, test "${WIN32}" = "yes")
+
+# workaround for <autoconf-2.60
+if test -z "${docdir}"; then
+	docdir="\$(datarootdir)/doc/\$(PACKAGE_NAME)"
+	AC_SUBST([docdir])
+fi
+if test -z "${htmldir}"; then
+	htmldir="\$(docdir)"
+	AC_SUBST([htmldir])
+fi
+# end workaround
+
+AC_OUTPUT([
+	Makefile
+	openvpn.spec
+	config-win32.h
+	images/Makefile
+	service-win32/Makefile
+	install-win32/Makefile
+	install-win32/settings
+])
diff -urN openvpn-2.1_rc7/contrib/pull-resolv-conf/client.down openvpn-2.1_rc9/contrib/pull-resolv-conf/client.down
--- openvpn-2.1_rc7/contrib/pull-resolv-conf/client.down	2008-01-23 22:08:39.000000000 +0100
+++ openvpn-2.1_rc9/contrib/pull-resolv-conf/client.down	2008-07-14 20:37:55.000000000 +0200
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-# Copyright (c) 2005 by OpenVPN Solutions LLC
+# Copyright (c) 2005-2008 Telethra, Inc.
 # Licensed under the GPL version 2
 
 # First version by Jesse Adelman
diff -urN openvpn-2.1_rc7/contrib/pull-resolv-conf/client.up openvpn-2.1_rc9/contrib/pull-resolv-conf/client.up
--- openvpn-2.1_rc7/contrib/pull-resolv-conf/client.up	2008-01-23 22:08:39.000000000 +0100
+++ openvpn-2.1_rc9/contrib/pull-resolv-conf/client.up	2008-07-14 20:37:55.000000000 +0200
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-# Copyright (c) 2005 by OpenVPN Solutions LLC
+# Copyright (c) 2005-2008 by Telethra, Inc.
 # Licensed under the GPL version 2
 
 # First version by Jesse Adelman
diff -urN openvpn-2.1_rc7/crypto.c openvpn-2.1_rc9/crypto.c
--- openvpn-2.1_rc7/crypto.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/crypto.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,16 +22,10 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
+#include "syshead.h"
 
 #ifdef USE_CRYPTO
 
-#include "syshead.h"
-
 #include "crypto.h"
 #include "error.h"
 #include "misc.h"
@@ -1058,13 +1052,15 @@
       if (fd == -1)
 	msg (M_ERR, "Cannot open file key file '%s'", file);
       size = read (fd, in.data, in.capacity);
+      if (size < 0)
+	msg (M_FATAL, "Read error on key file ('%s')", file);
       if (size == in.capacity)
 	msg (M_FATAL, "Key file ('%s') can be a maximum of %d bytes", file, (int)in.capacity);
       close (fd);
     }
 
   cp = (unsigned char *)in.data;
-  while (size)
+  while (size > 0)
     {
       const unsigned char c = *cp;
 
diff -urN openvpn-2.1_rc7/crypto.h openvpn-2.1_rc9/crypto.h
--- openvpn-2.1_rc7/crypto.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/crypto.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -69,6 +69,9 @@
 
 #if SSLEAY_VERSION_NUMBER < 0x00907000L
 
+/* Workaround: OpenSSL 0.9.6 breaks extract_x509_field_ssl function */
+#define USE_OLD_EXTRACT_X509_FIELD
+
 /* Workaround: EVP_CIPHER_mode is defined wrong in OpenSSL 0.9.6 but is fixed in 0.9.7 */
 #undef EVP_CIPHER_mode
 #define EVP_CIPHER_mode(e)                (((e)->flags) & EVP_CIPH_MODE)
diff -urN openvpn-2.1_rc7/cryptoapi.c openvpn-2.1_rc9/cryptoapi.c
--- openvpn-2.1_rc7/cryptoapi.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/cryptoapi.c	2008-07-26 10:28:08.000000000 +0200
@@ -27,13 +27,18 @@
  * LITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+
+#include "syshead.h"
+
+#ifdef WIN32
+
+#include <openssl/ssl.h>
+#include <openssl/err.h>
 #include <windows.h>
 #include <wincrypt.h>
 #include <stdio.h>
 #include <ctype.h>
 #include <assert.h>
-#include <openssl/ssl.h>
-#include <openssl/err.h>
 
 #ifdef __MINGW32_VERSION
 /* MinGW w32api is incomplete when it comes to CryptoAPI, as per version 3.1
@@ -364,7 +369,7 @@
     }
 
     /* cert_context->pbCertEncoded is the cert X509 DER encoded. */
-    cert = d2i_X509(NULL, (unsigned char **) &cd->cert_context->pbCertEncoded,
+    cert = d2i_X509(NULL, (const unsigned char **) &cd->cert_context->pbCertEncoded,
 		    cd->cert_context->cbCertEncoded);
     if (cert == NULL) {
 	SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE, ERR_R_ASN1_LIB);
@@ -461,3 +466,7 @@
     }
     return 0;
 }
+
+#else
+static void dummy (void) {}
+#endif				/* WIN32 */
diff -urN openvpn-2.1_rc7/debug/valgrind-suppress openvpn-2.1_rc9/debug/valgrind-suppress
--- openvpn-2.1_rc7/debug/valgrind-suppress	2008-01-23 22:08:36.000000000 +0100
+++ openvpn-2.1_rc9/debug/valgrind-suppress	2008-07-26 08:28:55.000000000 +0200
@@ -1,122 +1,610 @@
-# Valgrind suppressions file for OpenVPN.
-#
-# Mostly deal with uninitialized data warnings
-# in OpenSSL.
+{
+   <insert a suppression name here>
+   Memcheck:Addr8
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   obj:/lib/libc-2.5.so
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_tcp
+   fun:main
+}
 
 {
-   cond_BN
-   Memcheck:Cond
-   fun:BN_*
+   <insert a suppression name here>
+   Memcheck:Addr8
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   fun:__nss_next
+   fun:gethostbyname_r
+   fun:gethostbyname
+   fun:getaddr
+   fun:resolve_remote
+   fun:link_socket_init_phase1
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
 }
 
 {
-   value4_BN
-   Memcheck:Value4
-   fun:BN_*
+   <insert a suppression name here>
+   Memcheck:Addr8
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   obj:/lib/libc-2.5.so
+   fun:gethostbyname_r
+   fun:gethostbyname
+   fun:getaddr
+   fun:resolve_remote
+   fun:link_socket_init_phase1
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
 }
 
 {
-   cond_bn
-   Memcheck:Cond
-   fun:bn_*
+   <insert a suppression name here>
+   Memcheck:Addr8
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   fun:dlopen
+   fun:plugin_list_init
+   fun:init_plugins
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Addr8
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   fun:dlopen
+   fun:plugin_list_init
+   fun:init_plugins
+   fun:main
 }
 
 {
-   value4_bn
-   Memcheck:Value4
-   fun:bn_*
+   <insert a suppression name here>
+   Memcheck:Addr8
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/libdl-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   fun:dlsym
+   fun:libdl_resolve_symbol
+   fun:plugin_list_init
+   fun:init_plugins
+   fun:main
 }
 
 {
-   cond_SHA1_Update
+   <insert a suppression name here>
+   Memcheck:Addr8
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   fun:dlopen
+   fun:plugin_list_init
+   fun:init_plugins
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Cond
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:*
+   obj:*
+   obj:*
+}
+
+{
+   <insert a suppression name here>
    Memcheck:Cond
-   fun:SHA1_Update
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   fun:__nss_next
+   fun:gethostbyname_r
+   fun:gethostbyname
+   fun:getaddr
+   fun:resolve_remote
+   fun:link_socket_init_phase1
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
 }
 
 {
-   value4_SHA1_Update
-   Memcheck:Value4
-   fun:SHA1_Update
+   <insert a suppression name here>
+   Memcheck:Cond
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   obj:/lib/libc-2.5.so
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_tcp
+   fun:main
 }
 
 {
-   cond_ssl3_read_bytes
+   <insert a suppression name here>
    Memcheck:Cond
-   fun:ssl3_read_bytes
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   obj:/lib/libc-2.5.so
+   fun:gethostbyname_r
+   fun:gethostbyname
+   fun:getaddr
+   fun:resolve_remote
+   fun:link_socket_init_phase1
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
 }
 
 {
-   cond_crypto
+   <insert a suppression name here>
    Memcheck:Cond
-   obj:/lib/libcrypto.so.*
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   fun:__nss_next
+   fun:gethostbyname_r
+   fun:gethostbyname
+   fun:getaddr
+   fun:resolve_remote
+   fun:link_socket_init_phase1
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
 }
 
 {
-   value4_crypto
-   Memcheck:Value4
-   obj:/lib/libcrypto.so.*
+   <insert a suppression name here>
+   Memcheck:Cond
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   obj:/lib/libc-2.5.so
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_tcp
+   fun:main
 }
 
 {
-   cond_ssl
+   <insert a suppression name here>
    Memcheck:Cond
-   obj:/lib/libssl.so.*
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   obj:/lib/libc-2.5.so
+   fun:gethostbyname_r
+   fun:gethostbyname
+   fun:getaddr
+   fun:resolve_remote
+   fun:link_socket_init_phase1
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
 }
 
 {
-   value4_ssl
-   Memcheck:Value4
-   obj:/lib/libssl.so.*
+   <insert a suppression name here>
+   Memcheck:Cond
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   fun:__nss_next
+   fun:gethostbyname_r
+   fun:gethostbyname
+   fun:getaddr
+   fun:resolve_remote
+   fun:link_socket_init_phase1
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
 }
 
 {
-   addr4_AES_cbc_encrypt
-   Memcheck:Addr4
-   fun:AES_cbc_encrypt
+   <insert a suppression name here>
+   Memcheck:Cond
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   obj:/lib/libc-2.5.so
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_tcp
+   fun:main
 }
 
 {
-   cond_memcpy_ssl3_read_bytes
+   <insert a suppression name here>
    Memcheck:Cond
-   fun:memcpy
-   fun:ssl3_read_bytes
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   obj:/lib/libc-2.5.so
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_udp
+   fun:main
 }
 
 {
-   value4_memcpy_ssl3_read_bytes
-   Memcheck:Value4
-   fun:memcpy
-   fun:ssl3_read_bytes
+   <insert a suppression name here>
+   Memcheck:Cond
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/ld-2.5.so
+   fun:__libc_dlopen_mode
+   fun:__nss_lookup_function
+   obj:/lib/libc-2.5.so
+   fun:gethostbyname_r
+   fun:gethostbyname
+   fun:getaddr
+   fun:resolve_remote
+   fun:link_socket_init_phase1
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
 }
 
 {
-   cond_memset_BUF_MEM_grow_clean
+   <insert a suppression name here>
    Memcheck:Cond
-   fun:memset
-   fun:BUF_MEM_grow_clean
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libc-2.5.so
+   obj:/lib/libdl-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   fun:dlsym
+   fun:libdl_resolve_symbol
+   fun:plugin_list_init
+   fun:init_plugins
+   fun:main
 }
 
 {
-   value4_memset_BUF_MEM_grow_clean
-   Memcheck:Value4
-   fun:memset
-   fun:BUF_MEM_grow_clean
+   <insert a suppression name here>
+   Memcheck:Cond
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   obj:/lib/ld-2.5.so
+   obj:/lib/libdl-2.5.so
+   fun:dlopen
+   fun:plugin_list_init
+   fun:init_plugins
+   fun:main
 }
 
 {
-   SSL_get_ex_new_index
+   <insert a suppression name here>
    Memcheck:Leak
    fun:malloc
-   obj:/lib/libcrypto.so.*
    fun:CRYPTO_malloc
-   fun:lh_new
-   obj:/lib/libcrypto.so.*
-   obj:/lib/libcrypto.so.*
-   obj:/lib/libcrypto.so.*
-   fun:CRYPTO_get_ex_new_index
-   fun:SSL_get_ex_new_index
-   fun:ssl_set_mydata_index
+   fun:sk_new
+   obj:/usr/lib/libssl.so.0.9.8
+   fun:SSL_COMP_get_compression_methods
+   fun:SSL_library_init
    fun:init_ssl_lib
    fun:init_static
    fun:main
 }
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   fun:__nss_lookup_function
+   obj:*
+   obj:*
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   fun:__nss_lookup_function
+   obj:*
+   obj:*
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_tcp
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   fun:__nss_lookup_function
+   obj:*
+   obj:*
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_udp
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   fun:getdelim
+   fun:getpass
+   fun:get_console_input
+   fun:get_user_pass
+   fun:context_init_1
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   fun:tsearch
+   fun:__nss_lookup_function
+   obj:*
+   obj:*
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   fun:tsearch
+   fun:__nss_lookup_function
+   obj:*
+   obj:*
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_tcp
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   fun:tsearch
+   fun:__nss_lookup_function
+   obj:*
+   obj:*
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_udp
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   obj:/lib/libc-2.5.so
+   fun:__nss_database_lookup
+   obj:*
+   obj:*
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   obj:/lib/libc-2.5.so
+   fun:__nss_database_lookup
+   obj:*
+   obj:*
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_tcp
+   fun:main
+}
+
+{
+   <insert a suppression name here>
+   Memcheck:Leak
+   fun:malloc
+   obj:/lib/libc-2.5.so
+   fun:__nss_database_lookup
+   obj:*
+   obj:*
+   fun:getgrnam_r
+   fun:getgrnam
+   fun:get_group
+   fun:do_init_first_time
+   fun:init_instance
+   fun:init_instance_handle_signals
+   fun:tunnel_server_udp
+   fun:main
+}
+
diff -urN openvpn-2.1_rc7/doclean openvpn-2.1_rc9/doclean
--- openvpn-2.1_rc7/doclean	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/doclean	2008-06-13 09:54:59.000000000 +0200
@@ -1,16 +1,71 @@
 #!/bin/sh
 
-# Let's have a fresh start.  Remove all files
-# which are not source files.
+# Let's have a fresh start.  Remove all
+# generated files.
 #
 # Run this script, then:
-#        touch *
-#        [apply any patches here]
 #        autoreconf -i -v
 #        ./configure
 #        make
 #        make install
 
-rm -f *.o openvpn config.cache configure Makefile Makefile.in stamp-h* config.guess config.sub depcomp missing mkinstalldirs config.log config.status config.h config.h.in aclocal.m4 openvpn.spec install-sh
+rm -f \
+    *.o \
+    service-win32/*.o \
+    service-win32/*.exe \
+    *.exe \
+    openvpn \
+    config.cache \
+    configure \
+    Makefile \
+    Makefile.in \
+    stamp-h* \
+    config.guess \
+    config.sub \
+    depcomp \
+    missing \
+    mkinstalldirs \
+    config.log \
+    config.status \
+    config.h \
+    config.h.in \
+    aclocal.m4 \
+    openvpn.spec \
+    install-sh \
+    openvpn.8.html \
+    config-win32.h \
+    install-win32/*.exe \
+    install-win32/makensis.log \
+    install-win32/settings \
+    install-win32/Makefile \
+    install-win32/Makefile.in \
+    images/Makefile \
+    images/Makefile.in \
+    service-win32/Makefile \
+    service-win32/Makefile.in
 
-rm -rf autom4te*.cache .deps
+rm -rf \
+    autom4te*.cache \
+    .deps \
+    */.deps \
+    windest \
+    autodefs \
+    gen \
+    tapinstall \
+    install-win32/tmp
+
+rm -rf \
+    tap-win32/objfre_w2k_x86 \
+    tap-win32/dist \
+    tap-win32/SOURCES \
+    tap-win32/tapdrvr.cod \
+    tap-win32/buildfre_wnet_amd64.wrn \
+    tap-win32/buildfre_w2k_x86.wrn \
+    tap-win32/objfre_wnet_amd64 \
+    tap-win32/buildfre_wnet_amd64.log \
+    tap-win32/buildfre_w2k_x86.log \
+    tap-win32/amd64 \
+    tap-win32/i386/tap0901.pdb \
+    tap-win32/i386/OemWin2k.inf \
+    tap-win32/i386/tap0901.map \
+    tap-win32/i386/tap0901.sys
diff -urN openvpn-2.1_rc7/domake-win openvpn-2.1_rc9/domake-win
--- openvpn-2.1_rc7/domake-win	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/domake-win	2008-06-13 09:54:59.000000000 +0200
@@ -4,17 +4,34 @@
 # This script will build OpenVPN, the TAP driver, and
 # the installer from source, targeting x86 on Windows
 # 2000 and higher, and x64 on Windows 2003 and higher.
+# For quick start options, see pre-built notes below.
 #
-# See top-level build configuration in install-win32/settings.in
+# Note that if you are only looking to build the
+# openvpn user-space binaries (openvpn.exe
+# and openvpnserv.exe) you can use the
+# provided autoconf/automake build environment.
 #
-# Prerequisite installs:
+# If you are building from an expanded .tar.gz file,
+# make sure to run "./doclean" before "./domake-win".
+#
+# See top-level build configuration and settings in:
+#
+#   version.m4
+#   install-win32/settings.in
+#
+# Mandatory prerequisites:
 #
 # MinGW     -- for GNU C compiler
 # MSYS      -- for bash
 # msysDTK   -- for perl
 # NSIS      -- for building installer
+#
+# The following additional prerequisites may be omitted
+# when building in pre-built mode (see note below). 
+
 # svn       -- for checking out source code (or TortoiseSVN)
-# Windows Driver Kit (6001_17121_HyperV_WDK.iso) -- for building TAP driver + tapinstall
+# Windows Driver Kit (6001_17121_HyperV_WDK.iso) -- for building
+#    TAP driver + tapinstall
 #
 # Required libraries (must be prebuilt)
 #
@@ -35,19 +52,92 @@
 #
 # ../svc-template -- This directory should contain service.[ch]
 #                    from the MS Platform SDK.
+
+# Note that all variables referenced here such as GENOUT,
+# GENOUT_PREBUILT, and CLEAN are defined in install-win32/settings.in
+
+# SPECIAL NOTES ON PRE-BUILT MODE
+#   Setting up a complete tool chain to build OpenVPN and all
+#   dependencies on Windows can be an onerous task, so the capability
+#   is provided to reference a directory of pre-built components during
+#   the build process.  When dependencies are missing to build a given
+#   component (such as the TAP driver), the build script will auto-detect
+#   this and use the pre-built version instead.  This would allow you, for
+#   example, to build an OpenVPN installer with custom edits to
+#   install-win32/settings.in, but then avoid needing to build all other
+#   components (such as OpenSSL, LZO, Pkcs11-helper, TAP driver windows
+#   service, etc.).  The procedure is as follows. First Download and expand
+#   the pre-built binaries from:
+#
+#     https://secure.openvpn.net/devel/ (choose the most recent -prebuilt .tbz file)
+#
+#   After expanding the .tbz file, cd to the top level directory and
+#   expand an OpenVPN source distribution taken from either the subversion
+#   repository or a source .tar.gz file.  It's best to use an OpenVPN source
+#   version that is the same or slightly later than the pre-built binaries
+#   file.  So now you have a directory containing something that looks like
+#   this:
+#
+#   gen-prebuilt     -> from prebuilt .tbz file
+#   lzo-2.02         -> from prebuilt .tbz file
+#   openssl-0.9.7m   -> from prebuilt .tbz file
+#   pkcs11-helper    -> from prebuilt .tbz file
+#   openvpn-2.1_rc7a.tar.gz  -> downloaded from openvpn.net
+#   openvpn-2.1_rc7a -> directory expanded from above file
+#
+#   Now cd to your expanded source tree (openvpn-2.1_rc7a in the
+#   example above), make edits to install-win32/settings.in (or even
+#   patch the OpenVPN source code directly), and run this script:
 #
-# Example usage:
+#       ./domake-win
 #
-# build everything, then write installer to desktop
-#  INSTALLER_DEST="/c/Documents and Settings/James/Desktop" ./domake-win
+#   If everything runs correctly, you should have a custom installer
+#   written to ./gen/install
+
+
 
+# First build the autodefs directory, containing C, sh, and NSIS versions
+# of global settings, using install-win32/settings.in as source.
+# These settings will then drive the rest of the build process. 
 install-win32/winconfig
+
+# Delete the GENOUT directory if CLEAN="yes"
+install-win32/doclean
+
+# Load a pre-built GENOUT directory if GENOUT_PREBUILT is defined
+# and the GENOUT directory is non-existing
+install-win32/getprebuilt
+
+# Each of the scripts below build, get, and/or possibly sign a different
+# OpenVPN component, placing the generated files in GENOUT.  Each of these
+# steps is fully indepedent, and can be executed in any order or omitted.
+# The exception is the last script which gathers together all files from
+# GENOUT and builds the installer.
+
+# Make the OpenVPN user-space components (OpenVPN and service)
 install-win32/makeopenvpn
-install-win32/maketapinstall
+
+# Make the OpenVPN TAP driver
 install-win32/maketap
-install-win32/signtap
-install-win32/makebin
+
+# Make the tapinstall utility, used to install the TAP driver
+install-win32/maketapinstall
+
+# Get the OpenSSL libraries from a pre-build OpenSSL tree
+install-win32/getopenssl
+
+# Get the PKCS-11 helper library from a pre-built OpenSSL tree
+install-win32/getpkcs11helper
+
+# Get the OpenVPN GUI (must be prebuilt)
 install-win32/getgui
+
+# Produce the license text, install README, and sample config files
+install-win32/maketext
+
+# Get the OpenVPN XML-based GUI (must be prebuilt)
+install-win32/getxgui
+
+# This final step builds the OpenVPN installer using generated
+# files from GENOUT
 install-win32/buildinstaller
-install-win32/signinstaller
-install-win32/copyinstaller
diff -urN openvpn-2.1_rc7/easy-rsa/2.0/pkitool openvpn-2.1_rc9/easy-rsa/2.0/pkitool
--- openvpn-2.1_rc7/easy-rsa/2.0/pkitool	2008-01-23 22:08:38.000000000 +0100
+++ openvpn-2.1_rc9/easy-rsa/2.0/pkitool	2008-07-14 20:49:15.000000000 +0200
@@ -6,7 +6,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+#  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
@@ -118,6 +118,11 @@
     echo "  ./$PROGNAME client-new"
 }
 
+# Set tool defaults
+[ -n "$OPENSSL" ] || export OPENSSL="openssl"
+[ -n "$PKCS11TOOL" ] || export PKCS11TOOL="pkcs11-tool"
+[ -n "$GREP" ] || export GREP="grep"
+
 # Set defaults
 DO_REQ="1"
 REQ_EXT=""
diff -urN openvpn-2.1_rc7/easy-rsa/2.0/vars openvpn-2.1_rc9/easy-rsa/2.0/vars
--- openvpn-2.1_rc7/easy-rsa/2.0/vars	2008-01-23 22:08:38.000000000 +0100
+++ openvpn-2.1_rc9/easy-rsa/2.0/vars	2008-06-13 09:54:56.000000000 +0200
@@ -41,6 +41,10 @@
 # Issue rm -rf warning
 echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR
 
+# PKCS11 fixes
+export PKCS11_MODULE_PATH="dummy"
+export PKCS11_PIN="dummy"
+
 # Increase this to 2048 if you
 # are paranoid.  This will slow
 # down TLS negotiation performance
diff -urN openvpn-2.1_rc7/easy-rsa/Windows/vars.bat.sample openvpn-2.1_rc9/easy-rsa/Windows/vars.bat.sample
--- openvpn-2.1_rc7/easy-rsa/Windows/vars.bat.sample	2008-01-23 22:08:38.000000000 +0100
+++ openvpn-2.1_rc9/easy-rsa/Windows/vars.bat.sample	2008-07-31 23:00:32.000000000 +0200
@@ -31,5 +31,5 @@
 set KEY_COUNTRY=US
 set KEY_PROVINCE=CA
 set KEY_CITY=SanFrancisco
-set KEY_ORG=FortFunston
+set KEY_ORG=OpenVPN
 set KEY_EMAIL=mail@host.domain
diff -urN openvpn-2.1_rc7/errlevel.h openvpn-2.1_rc9/errlevel.h
--- openvpn-2.1_rc7/errlevel.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/errlevel.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -94,6 +94,7 @@
 #define D_ROUTE_QUOTA        LOGLEV(3, 43, 0)        /* show route quota exceeded messages */
 #define D_OSBUF              LOGLEV(3, 44, 0)        /* show socket/tun/tap buffer sizes */
 #define D_PS_PROXY           LOGLEV(3, 45, 0)        /* messages related to --port-share option */
+#define D_PF_INFO            LOGLEV(3, 46, 0)        /* packet filter informational messages */
 
 #define D_SHOW_PARMS         LOGLEV(4, 50, 0)        /* show all parameters on program initiation */
 #define D_SHOW_OCC           LOGLEV(4, 51, 0)        /* show options compatibility string */
@@ -101,6 +102,7 @@
 #define D_DHCP_OPT           LOGLEV(4, 53, 0)        /* show DHCP options binary string */
 #define D_MBUF               LOGLEV(4, 54, 0)        /* mbuf.[ch] routines */
 #define D_PACKET_TRUNC_ERR   LOGLEV(4, 55, 0)        /* PACKET_TRUNCATION_CHECK */
+#define D_PF_DROPPED         LOGLEV(4, 56, 0)        /* packet filter dropped a packet */
 
 #define D_LOG_RW             LOGLEV(5, 0,  0)        /* Print 'R' or 'W' to stdout for read/write */
 
@@ -118,7 +120,7 @@
 #define D_MULTI_DEBUG        LOGLEV(7, 70, M_DEBUG)  /* show medium-freq multi debugging info */
 #define D_MSS                LOGLEV(7, 70, M_DEBUG)  /* show MSS adjustments */
 #define D_COMP_LOW           LOGLEV(7, 70, M_DEBUG)  /* show adaptive compression state changes */
-#define D_REMOTE_LIST        LOGLEV(7, 70, M_DEBUG)  /* show --remote list */
+#define D_CONNECTION_LIST    LOGLEV(7, 70, M_DEBUG)  /* show <connection> list info */
 #define D_SCRIPT             LOGLEV(7, 70, M_DEBUG)  /* show parms & env vars passed to scripts */
 #define D_SHOW_NET           LOGLEV(7, 70, M_DEBUG)  /* show routing table and adapter list */
 #define D_ROUTE_DEBUG        LOGLEV(7, 70, M_DEBUG)  /* show verbose route.[ch] output */
@@ -135,6 +137,8 @@
 #define D_PING               LOGLEV(7, 70, M_DEBUG)  /* PING send/receive messages */
 #define D_PS_PROXY_DEBUG     LOGLEV(7, 70, M_DEBUG)  /* port share proxy debug */
 #define D_AUTO_USERID        LOGLEV(7, 70, M_DEBUG)  /* AUTO_USERID debugging */
+#define D_PF_DROPPED_BCAST   LOGLEV(7, 71, M_DEBUG)  /* packet filter dropped a broadcast packet */
+#define D_PF_DEBUG           LOGLEV(7, 72, M_DEBUG)  /* packet filter debugging, must also define PF_DEBUG in pf.h */
 
 #define D_HANDSHAKE_VERBOSE  LOGLEV(8, 70, M_DEBUG)  /* show detailed description of each handshake */
 #define D_TLS_DEBUG_MED      LOGLEV(8, 70, M_DEBUG)  /* limited info from tls_session routines */
diff -urN openvpn-2.1_rc7/error.c openvpn-2.1_rc9/error.c
--- openvpn-2.1_rc7/error.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/error.c	2008-07-26 10:28:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "error.h"
@@ -84,7 +78,9 @@
 static bool suppress_timestamps; /* GLOBAL */
 
 /* The program name passed to syslog */
+#if SYSLOG_CAPABILITY
 static char *pgmname_syslog;  /* GLOBAL */
+#endif
 
 /* If non-null, messages should be written here (used for debugging only) */
 static FILE *msgfp;         /* GLOBAL */
@@ -274,7 +270,10 @@
 #endif
 
   /* set up client prefix */
-  prefix = msg_get_prefix ();
+  if (flags & M_NOIPREFIX)
+    prefix = NULL;
+  else
+    prefix = msg_get_prefix ();
   prefix_sep = " ";
   if (!prefix)
     prefix_sep = prefix = "";
diff -urN openvpn-2.1_rc7/error.h openvpn-2.1_rc9/error.h
--- openvpn-2.1_rc7/error.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/error.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -30,7 +30,11 @@
 
 /* #define ABORT_ON_ERROR */
 
+#ifdef ENABLE_PKCS11
+#define ERR_BUF_SIZE 8192
+#else
 #define ERR_BUF_SIZE 1024
+#endif
 
 struct gc_arena;
 
@@ -98,13 +102,14 @@
 #define M_MSG_VIRT_OUT    (1<<14)        /* output message through msg_status_output callback */
 #define M_OPTERR          (1<<15)        /* print "Options error:" prefix */
 #define M_NOLF            (1<<16)        /* don't print new line */
+#define M_NOIPREFIX       (1<<17)        /* don't print instance prefix */
 
 /* flag combinations which are frequently used */
 #define M_ERR     (M_FATAL | M_ERRNO)
 #define M_SOCKERR (M_FATAL | M_ERRNO_SOCK)
 #define M_SSLERR  (M_FATAL | M_SSL)
 #define M_USAGE   (M_USAGE_SMALL | M_NOPREFIX | M_OPTERR)
-#define M_CLIENT  (M_MSG_VIRT_OUT|M_NOMUTE)
+#define M_CLIENT  (M_MSG_VIRT_OUT | M_NOMUTE | M_NOIPREFIX)
 
 /*
  * Mute levels are designed to avoid large numbers of
@@ -122,6 +127,11 @@
  * log_level:  verbosity level n (--verb n) must be >= log_level to print.
  * mute_level: don't print more than n (--mute n) consecutive messages at
  *             a given mute level, or if 0 disable muting and print everything.
+ *
+ * Mask map:
+ * Bits 0-3:   log level
+ * Bits 4-23:  M_x flags
+ * Bits 24-31: mute level
  */
 #define LOGLEV(log_level, mute_level, other) ((log_level) | ENCODE_MUTE_LEVEL(mute_level) | other)
 
@@ -132,7 +142,7 @@
 
 bool dont_mute (unsigned int flags); /* check muting filter */
 
-#define MSG_TEST(flags) (((((unsigned int)flags) & M_DEBUG_LEVEL) <= x_debug_level) && dont_mute (flags))
+#define MSG_TEST(flags) (unlikely((((unsigned int)flags) & M_DEBUG_LEVEL) <= x_debug_level) && dont_mute (flags))
 
 #if defined(HAVE_CPP_VARARG_MACRO_ISO) && !defined(__LCLINT__)
 # define HAVE_VARARG_MACROS
diff -urN openvpn-2.1_rc7/event.c openvpn-2.1_rc9/event.c
--- openvpn-2.1_rc7/event.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/event.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "buffer.h"
diff -urN openvpn-2.1_rc7/event.h openvpn-2.1_rc9/event.h
--- openvpn-2.1_rc7/event.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/event.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/fdmisc.c openvpn-2.1_rc9/fdmisc.c
--- openvpn-2.1_rc7/fdmisc.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/fdmisc.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "fdmisc.h"
diff -urN openvpn-2.1_rc7/fdmisc.h openvpn-2.1_rc9/fdmisc.h
--- openvpn-2.1_rc7/fdmisc.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/fdmisc.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/forward-inline.h openvpn-2.1_rc9/forward-inline.h
--- openvpn-2.1_rc7/forward-inline.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/forward-inline.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/forward.c openvpn-2.1_rc9/forward.c
--- openvpn-2.1_rc7/forward.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/forward.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "forward.h"
@@ -89,13 +83,19 @@
 
   if (interval_test (&c->c2.tmp_int))
     {
-      if (tls_multi_process
-	  (c->c2.tls_multi, &c->c2.to_link, &c->c2.to_link_addr,
-	   get_link_socket_info (c), &wakeup))
+      const int tmp_status = tls_multi_process
+	(c->c2.tls_multi, &c->c2.to_link, &c->c2.to_link_addr,
+	 get_link_socket_info (c), &wakeup);
+      if (tmp_status == TLSMP_ACTIVE)
 	{
 	  update_time ();
 	  interval_action (&c->c2.tmp_int);
 	}
+      else if (tmp_status == TLSMP_KILL)
+	{
+	  c->sig->signal_received = SIGTERM;
+	  c->sig->signal_text = "auth-control-exit";
+	}
 
       interval_future_trigger (&c->c2.tmp_int, wakeup);
     }
@@ -356,7 +356,7 @@
   if (lsi->mtu_changed && c->c2.ipv4_tun)
     {
       frame_adjust_path_mtu (&c->c2.frame_fragment, c->c2.link_socket->mtu,
-			     c->options.proto);
+			     c->options.ce.proto);
       lsi->mtu_changed = false;
     }
 
@@ -492,6 +492,10 @@
   check_push_request (c);
 #endif
 
+#ifdef PLUGIN_PF
+  pf_check_reload (c);
+#endif
+
   /* process --route options */
   check_add_routes (c);
 
@@ -1034,7 +1038,7 @@
 #ifdef HAVE_GETTIMEOFDAY
 	  if (c->options.shaper)
 	    shaper_wrote_bytes (&c->c2.shaper, BLEN (&c->c2.to_link)
-				+ datagram_overhead (c->options.proto));
+				+ datagram_overhead (c->options.ce.proto));
 #endif
 	  /*
 	   * Let the pinger know that we sent a packet.
diff -urN openvpn-2.1_rc7/forward.h openvpn-2.1_rc9/forward.h
--- openvpn-2.1_rc7/forward.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/forward.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/fragment.c openvpn-2.1_rc9/fragment.c
--- openvpn-2.1_rc7/fragment.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/fragment.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #ifdef ENABLE_FRAGMENT
diff -urN openvpn-2.1_rc7/fragment.h openvpn-2.1_rc9/fragment.h
--- openvpn-2.1_rc7/fragment.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/fragment.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/gentoo/openvpn.init openvpn-2.1_rc9/gentoo/openvpn.init
--- openvpn-2.1_rc7/gentoo/openvpn.init	2008-01-23 22:08:39.000000000 +0100
+++ openvpn-2.1_rc9/gentoo/openvpn.init	1970-01-01 01:00:00.000000000 +0100
@@ -1,111 +0,0 @@
-#!/sbin/runscript
-
-# OpenVPN start/stop script
-# Adapted to Gentoo by James Yonan
-
-# Originally Contributed to the OpenVPN project by
-# Douglas Keller <doug@voidstar.dyndns.org>
-# 2002.05.15
-
-# This script does the following:
-#
-# - Starts an openvpn process for each .conf file it finds in
-#   /etc/openvpn.
-#
-# - If /etc/openvpn/xxx.sh exists for a xxx.conf file then it executes
-#   it before starting openvpn (useful for doing openvpn --mktun...).
-
-# - In addition to start/stop you can do:
-#
-#   service openvpn reload - SIGHUP
-#   service openvpn reopen - SIGUSR1
-#   service openvpn status - SIGUSR2
-
-# Location of openvpn binary
-openvpn=/usr/local/sbin/openvpn
-
-# PID directory
-piddir=/var/run/openvpn
-
-# Our working directory (.conf files should be here)
-work=/etc/openvpn
-
-# Our options
-opts="start stop restart condrestart"
-
-depend() {
-    need net
-    use dns
-}
-
-start() {
-    ebegin "Starting OpenVPN"
-
-    # Load the TUN/TAP module
-    /sbin/modprobe tun >/dev/null 2>&1
-
-    if [ ! -d  $piddir ]; then
-	mkdir $piddir
-    fi
-
-    cd $work
-
-    # Start every .conf in $work and run .sh if exists
-    local errors=0
-    local successes=0
-    local retstatus=0
-    for c in `/bin/ls *.conf 2>/dev/null`; do
-	bn=${c%%.conf}
-	if [ -f "$bn.sh" ]; then
-	    . $bn.sh
-	fi
-	rm -f $piddir/$bn.pid
-	$openvpn --daemon openvpn-$bn --writepid $piddir/$bn.pid --config $c --cd $work
-	if [ $? = 0 ]; then
-	    successes=1
-	else
-	    errors=1
-	fi
-    done
-
-    # Decide status based on errors/successes.
-    # If at least one tunnel succeeded, we return success.
-    # If some tunnels succeeded and some failed, we return
-    #   success but give a warning.
-    if [ $successes = 1 ]; then
-	if [ $errors = 1 ]; then
-	    ewarn "Note: At least one OpenVPN tunnel failed to start"
-	fi
-    else
-	retstatus=1
-	if [ $errors = 0 ]; then
-	    ewarn "Note: No OpenVPN configuration files were found in $work"
-	fi
-    fi
-    eend $retstatus "Error starting OpenVPN"
-}
-
-stop() {
-    ebegin "Stopping OpenVPN"
-    for pidf in `/bin/ls $piddir/*.pid 2>/dev/null`; do
-	if [ -s $pidf ]; then
-	    kill `cat $pidf` >/dev/null 2>&1
-	fi
-	rm -f $pidf
-    done
-    eend 0
-}
-
-# this should really be in runscript.sh
-started() {
-    if [ -L "${svcdir}/started/${myservice}" ]; then
-	return 1
-    else
-	return 0
-    fi
-}
-
-# attempt to restart ONLY if we are already started
-condrestart() {
-    started || restart
-}
diff -urN openvpn-2.1_rc7/gremlin.c openvpn-2.1_rc9/gremlin.c
--- openvpn-2.1_rc7/gremlin.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/gremlin.c	2008-07-27 06:15:44.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -27,12 +27,6 @@
  * network outages when the --gremlin option is used.
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #ifdef ENABLE_DEBUG
diff -urN openvpn-2.1_rc7/gremlin.h openvpn-2.1_rc9/gremlin.h
--- openvpn-2.1_rc7/gremlin.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/gremlin.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/helper.c openvpn-2.1_rc9/helper.c
--- openvpn-2.1_rc7/helper.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/helper.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "forward.h"
@@ -287,9 +281,6 @@
 	  o->push_ifconfig_constraint_network = o->server_network;
 	  o->push_ifconfig_constraint_netmask = o->server_netmask;
 	}
-
-      if (o->proto == PROTO_TCPv4)
-	o->proto = PROTO_TCPv4_SERVER;
     }
 
   /*
@@ -331,9 +322,6 @@
       ifconfig_pool_verify_range (M_USAGE, o->ifconfig_pool_start, o->ifconfig_pool_end);
       o->ifconfig_pool_netmask = o->server_bridge_netmask;
       push_option (o, print_opt_route_gateway (o->server_bridge_ip, &o->gc), M_USAGE);
-
-      if (o->proto == PROTO_TCPv4)
-	o->proto = PROTO_TCPv4_SERVER;
     }
   else
 #endif /* P2MP_SERVER */
@@ -355,16 +343,10 @@
 
       o->pull = true;
       o->tls_client = true;
-
-      if (o->proto == PROTO_TCPv4)
-	o->proto = PROTO_TCPv4_CLIENT;
     }
 
 #endif /* P2MP */
 
-  if (o->proto == PROTO_TCPv4)
-    msg (M_USAGE, "--proto tcp is ambiguous in this context.  Please specify --proto tcp-server or --proto tcp-client");
-
   gc_free (&gc);
 }
 
diff -urN openvpn-2.1_rc7/helper.h openvpn-2.1_rc9/helper.h
--- openvpn-2.1_rc7/helper.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/helper.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/ieproxy.c openvpn-2.1_rc9/ieproxy.c
--- openvpn-2.1_rc7/ieproxy.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/ieproxy.c	2008-07-26 08:18:08.000000000 +0200
@@ -17,7 +17,11 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include <WinInet.h>
+#include "syshead.h"
+
+#ifdef WIN32
+
+#include <wininet.h>
 #include <malloc.h>
 
 LPCTSTR getIeHttpProxyError=NULL;
@@ -135,3 +139,7 @@
     return(NULL);
   }
 }
+
+#else
+static void dummy (void) {}
+#endif				/* WIN32 */
diff -urN openvpn-2.1_rc7/images/Makefile.am openvpn-2.1_rc9/images/Makefile.am
--- openvpn-2.1_rc7/images/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/images/Makefile.am	2008-07-14 20:49:15.000000000 +0200
@@ -0,0 +1,41 @@
+#
+#  OpenVPN -- An application to securely tunnel IP networks
+#             over a single UDP port, with support for SSL/TLS-based
+#             session authentication and key exchange,
+#             packet encryption, packet authentication, and
+#             packet compression.
+#
+#  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License version 2
+#  as published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program (see the file COPYING included with this
+#  distribution); if not, write to the Free Software Foundation, Inc.,
+#  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+
+images = \
+	install-whirl.bmp \
+	icon.ico
+
+if WIN32
+
+imagedir = $(win32datadir)/images
+dist_image_DATA = $(images)
+
+else
+
+dist_noinst_DATA = $(images)
+
+endif
+
diff -urN openvpn-2.1_rc7/images/Makefile.in openvpn-2.1_rc9/images/Makefile.in
--- openvpn-2.1_rc7/images/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/images/Makefile.in	2008-07-31 19:45:20.000000000 +0200
@@ -0,0 +1,374 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#
+#  OpenVPN -- An application to securely tunnel IP networks
+#             over a single UDP port, with support for SSL/TLS-based
+#             session authentication and key exchange,
+#             packet encryption, packet authentication, and
+#             packet compression.
+#
+#  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License version 2
+#  as published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program (see the file COPYING included with this
+#  distribution); if not, write to the Free Software Foundation, Inc.,
+#  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = images
+DIST_COMMON = $(am__dist_image_DATA_DIST) $(am__dist_noinst_DATA_DIST) \
+	$(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/version.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__dist_image_DATA_DIST = install-whirl.bmp icon.ico
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(imagedir)"
+dist_imageDATA_INSTALL = $(INSTALL_DATA)
+am__dist_noinst_DATA_DIST = install-whirl.bmp icon.ico
+DATA = $(dist_image_DATA) $(dist_noinst_DATA)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+GREP = @GREP@
+IFCONFIG = @IFCONFIG@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+IPROUTE = @IPROUTE@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MAN2HTML = @MAN2HTML@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PTHREAD_CC = @PTHREAD_CC@
+PTHREAD_CFLAGS = @PTHREAD_CFLAGS@
+PTHREAD_LIBS = @PTHREAD_LIBS@
+ROUTE = @ROUTE@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+TAP_ID = @TAP_ID@
+TAP_WIN32_MIN_MAJOR = @TAP_WIN32_MIN_MAJOR@
+TAP_WIN32_MIN_MINOR = @TAP_WIN32_MIN_MINOR@
+VERSION = @VERSION@
+WIN32_FALSE = @WIN32_FALSE@
+WIN32_TRUE = @WIN32_TRUE@
+ac_ct_CC = @ac_ct_CC@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+win32datadir = @win32datadir@
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+images = \
+	install-whirl.bmp \
+	icon.ico
+
+@WIN32_TRUE@imagedir = $(win32datadir)/images
+@WIN32_TRUE@dist_image_DATA = $(images)
+@WIN32_FALSE@dist_noinst_DATA = $(images)
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  images/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  images/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
+install-dist_imageDATA: $(dist_image_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(imagedir)" || $(mkdir_p) "$(DESTDIR)$(imagedir)"
+	@list='$(dist_image_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(dist_imageDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(imagedir)/$$f'"; \
+	  $(dist_imageDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(imagedir)/$$f"; \
+	done
+
+uninstall-dist_imageDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(dist_image_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(imagedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(imagedir)/$$f"; \
+	done
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(DATA)
+installdirs:
+	for dir in "$(DESTDIR)$(imagedir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+clean: clean-am
+
+clean-am: clean-generic mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-dist_imageDATA
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-dist_imageDATA uninstall-info-am
+
+.PHONY: all all-am check check-am clean clean-generic distclean \
+	distclean-generic distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am \
+	install-dist_imageDATA install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
+	pdf-am ps ps-am uninstall uninstall-am \
+	uninstall-dist_imageDATA uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Files openvpn-2.1_rc7/images/icon.ico and openvpn-2.1_rc9/images/icon.ico differ
Files openvpn-2.1_rc7/images/install-whirl.bmp and openvpn-2.1_rc9/images/install-whirl.bmp differ
diff -urN openvpn-2.1_rc7/init.c openvpn-2.1_rc9/init.c
--- openvpn-2.1_rc7/init.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/init.c	2008-07-27 20:16:55.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "win32.h"
@@ -84,23 +78,100 @@
 }
 
 /*
- * Initialize and possibly randomize remote list.
+ * Should be called after options->ce is modified at the top
+ * of a SIGUSR1 restart.
  */
 static void
-init_remote_list (struct context *c)
+update_options_ce_post (struct options *options)
 {
-  c->c1.remote_list = NULL;
+#if P2MP
+  /*
+   * In pull mode, we usually import --ping/--ping-restart parameters from
+   * the server.  However we should also set an initial default --ping-restart
+   * for the period of time before we pull the --ping-restart parameter
+   * from the server.
+   */
+  if (options->pull
+      && options->ping_rec_timeout_action == PING_UNDEF
+      && options->ce.proto == PROTO_UDPv4)
+    {
+      options->ping_rec_timeout = PRE_PULL_INITIAL_PING_RESTART;
+      options->ping_rec_timeout_action = PING_RESTART;
+    }
+#endif
+#ifdef USE_CRYPTO
+  /* 
+   * Don't use replay window for TCP mode (i.e. require that packets be strictly in sequence).
+   */
+  if (link_socket_proto_connection_oriented (options->ce.proto))
+    options->replay_window = options->replay_time = 0;
+#endif
+}
 
-  if (c->options.remote_list)
+/*
+ * Initialize and possibly randomize connection list.
+ */
+static void
+init_connection_list (struct context *c)
+{
+#ifdef ENABLE_CONNECTION
+  struct connection_list *l = c->options.connection_list;
+  if (l)
     {
-      struct remote_list *l;
-      ALLOC_OBJ_GC (c->c1.remote_list, struct remote_list, &c->gc);
-      l = c->c1.remote_list;
-      *l = *c->options.remote_list;
       l->current = -1;
       if (c->options.remote_random)
-	remote_list_randomize (l);
+	{
+	  int i;
+	  for (i = 0; i < l->len; ++i)
+	    {
+	      const int j = get_random () % l->len;
+	      if (i != j)
+		{
+		  struct connection_entry *tmp;
+		  tmp = l->array[i];
+		  l->array[i] = l->array[j];
+		  l->array[j] = tmp;
+		}
+	    }
+	}
     }
+#endif
+}
+
+/*
+ * Increment to next connection entry
+ */
+static void
+next_connection_entry (struct context *c)
+{
+#ifdef ENABLE_CONNECTION
+  struct connection_list *l = c->options.connection_list;
+  if (l)
+    {
+      if (l->no_advance && l->current >= 0)
+	{
+	  l->no_advance = false;
+	}
+      else
+	{
+	  int i;
+	  if (++l->current >= l->len)
+	    l->current = 0;
+
+	  dmsg (D_CONNECTION_LIST, "CONNECTION_LIST len=%d current=%d",
+		l->len, l->current);
+	  for (i = 0; i < l->len; ++i)
+	    {
+	      dmsg (D_CONNECTION_LIST, "[%d] %s:%d",
+		    i,
+		    l->array[i]->remote,
+		    l->array[i]->remote_port);
+	    }
+	}
+      c->options.ce = *l->array[l->current];
+    }
+#endif
+  update_options_ce_post (&c->options);
 }
 
 /*
@@ -122,8 +193,41 @@
 #endif
 }
 
-void
-context_init_1 (struct context *c)
+/*
+ * Initialize/Uninitialize HTTP or SOCKS proxy
+ */
+
+#ifdef GENERAL_PROXY_SUPPORT
+
+static int
+proxy_scope (struct context *c)
+{
+  return connection_list_defined (&c->options) ? 2 : 1;
+}
+
+static void
+uninit_proxy_dowork (struct context *c)
+{
+#ifdef ENABLE_HTTP_PROXY
+  if (c->c1.http_proxy_owned && c->c1.http_proxy)
+    {
+      http_proxy_close (c->c1.http_proxy);
+      c->c1.http_proxy = NULL;
+      c->c1.http_proxy_owned = false;
+    }
+#endif
+#ifdef ENABLE_SOCKS
+  if (c->c1.socks_proxy_owned && c->c1.socks_proxy)
+    {
+      socks_proxy_close (c->c1.socks_proxy);
+      c->c1.socks_proxy = NULL;
+      c->c1.socks_proxy_owned = false;
+    }
+#endif
+}
+
+static void
+init_proxy_dowork (struct context *c)
 {
 #ifdef ENABLE_HTTP_PROXY
   bool did_http = false;
@@ -131,10 +235,73 @@
   const bool did_http = false;
 #endif
 
+  uninit_proxy_dowork (c);
+
+#ifdef ENABLE_HTTP_PROXY
+  if (c->options.ce.http_proxy_options || c->options.auto_proxy_info)
+    {
+      /* Possible HTTP proxy user/pass input */
+      c->c1.http_proxy = http_proxy_new (c->options.ce.http_proxy_options,
+					 c->options.auto_proxy_info);
+      if (c->c1.http_proxy)
+	{
+	  did_http = true;
+	  c->c1.http_proxy_owned = true;
+	}
+    }
+#endif
+
+#ifdef ENABLE_SOCKS
+  if (!did_http && (c->options.ce.socks_proxy_server || c->options.auto_proxy_info))
+    {
+      c->c1.socks_proxy = socks_proxy_new (c->options.ce.socks_proxy_server,
+					   c->options.ce.socks_proxy_port,
+					   c->options.ce.socks_proxy_retry,
+					   c->options.auto_proxy_info);
+      if (c->c1.socks_proxy)
+	{
+	  c->c1.socks_proxy_owned = true;
+	}
+    }
+#endif
+}
+
+static void
+init_proxy (struct context *c, const int scope)
+{
+  if (scope == proxy_scope (c))
+    init_proxy_dowork (c);
+}
+
+static void
+uninit_proxy (struct context *c)
+{
+  if (c->sig->signal_received != SIGUSR1 || proxy_scope (c) == 2)
+    uninit_proxy_dowork (c);
+}
+
+#else
+
+static inline void
+init_proxy (struct context *c, const int scope)
+{
+}
+
+static inline void
+uninit_proxy (struct context *c, const int scope)
+{
+}
+
+#endif
+
+void
+context_init_1 (struct context *c)
+{
   context_clear_1 (c);
 
   packet_id_persist_init (&c->c1.pid_persist);
-  init_remote_list (c);
+
+  init_connection_list (c);
 
   init_query_passwords (c);
 
@@ -162,28 +329,8 @@
  }
 #endif
 
-#ifdef ENABLE_HTTP_PROXY
-  if (c->options.http_proxy_options || c->options.auto_proxy_info)
-    {
-      /* Possible HTTP proxy user/pass input */
-      c->c1.http_proxy = new_http_proxy (c->options.http_proxy_options,
-					 c->options.auto_proxy_info,
-					 &c->gc);
-      if (c->c1.http_proxy)
-	did_http = true;
-    }
-#endif
-
-#ifdef ENABLE_SOCKS
-  if (!did_http && (c->options.socks_proxy_server || c->options.auto_proxy_info))
-    {
-      c->c1.socks_proxy = new_socks_proxy (c->options.socks_proxy_server,
-					   c->options.socks_proxy_port,
-					   c->options.socks_proxy_retry,
-					   c->options.auto_proxy_info,
-					   &c->gc);
-    }
-#endif
+  /* initialize HTTP or SOCKS proxy object at scope level 1 */
+  init_proxy (c, 1);
 }
 
 void
@@ -223,7 +370,7 @@
 bool
 init_static (void)
 {
-  configure_path ();
+  /* configure_path (); */
 
 #if defined(USE_CRYPTO) && defined(DMALLOC)
   openssl_dmalloc_init ();
@@ -292,6 +439,40 @@
   return false;
 #endif
 
+#ifdef GEN_PATH_TEST
+  {
+    struct gc_arena gc = gc_new ();
+    const char *fn = gen_path ("foo",
+			       "bar",
+			       &gc);
+    printf ("%s\n", fn);
+    gc_free (&gc);
+  }
+  return false;
+#endif
+
+#ifdef STATUS_PRINTF_TEST
+  {
+    struct gc_arena gc = gc_new ();
+    const char *tmp_file = create_temp_filename ("/tmp", "foo", &gc);
+    struct status_output *so = status_open (tmp_file, 0, -1, NULL, STATUS_OUTPUT_WRITE);
+    status_printf (so, "%s", "foo");
+    status_printf (so, "%s", "bar");
+    if (!status_close (so))
+      msg (M_WARN, "STATUS_PRINTF_TEST: %s: write error", tmp_file);
+    gc_free (&gc);
+  }
+  return false;
+#endif
+
+#ifdef ARGV_TEST
+  {
+    void argv_test (void);
+    argv_test ();
+    return false;
+  }
+#endif
+
   return true;
 }
 
@@ -413,7 +594,7 @@
     {
       /* sanity check on options for --mktun or --rmtun */
       notnull (options->dev, "TUN/TAP device (--dev)");
-      if (options->remote_list || options->ifconfig_local
+      if (options->ce.remote || options->ifconfig_local
 	  || options->ifconfig_remote_netmask
 #ifdef USE_CRYPTO
 	  || options->shared_secret_file
@@ -690,9 +871,9 @@
   else
     msg (M_INFO, "%s", message);
 
-  /* Flag remote_list that we initialized */
-  if ((flags & (ISC_ERRORS|ISC_SERVER)) == 0 && c->c1.remote_list && c->c1.remote_list->len > 1)
-    c->c1.remote_list->no_advance = true;
+  /* Flag connection_list that we initialized */
+  if ((flags & (ISC_ERRORS|ISC_SERVER)) == 0 && connection_list_defined (&c->options))
+    connection_list_set_no_advance (&c->options);
 
 #ifdef ENABLE_MANAGEMENT
   /* Tell management interface that we initialized */
@@ -734,14 +915,17 @@
 
   if (plugin_defined (plugins, OPENVPN_PLUGIN_ROUTE_UP))
     {
-      if (plugin_call (plugins, OPENVPN_PLUGIN_ROUTE_UP, NULL, NULL, es))
+      if (plugin_call (plugins, OPENVPN_PLUGIN_ROUTE_UP, NULL, NULL, es) != OPENVPN_PLUGIN_FUNC_SUCCESS)
 	msg (M_WARN, "WARNING: route-up plugin call failed");
     }
 
   if (options->route_script)
     {
+      struct argv argv = argv_new ();
       setenv_str (es, "script_type", "route-up");
-      system_check (options->route_script, es, S_SCRIPT, "Route script failed");
+      argv_printf (&argv, "%s", options->route_script);
+      openvpn_execve_check (&argv, es, S_SCRIPT, "Route script failed");
+      argv_reset (&argv);
     }
 
 #ifdef WIN32
@@ -1105,7 +1289,7 @@
 #ifdef ENABLE_OCC
   if (found & OPT_P_EXPLICIT_NOTIFY)
     {
-      if (c->options.proto != PROTO_UDPv4 && c->options.explicit_exit_notification)
+      if (c->options.ce.proto != PROTO_UDPv4 && c->options.explicit_exit_notification)
 	{
 	  msg (D_PUSH, "OPTIONS IMPORT: --explicit-exit-notify can only be used with --proto udp");
 	  c->options.explicit_exit_notification = 0;
@@ -1189,25 +1373,25 @@
   int sec = 2;
 
 #ifdef ENABLE_HTTP_PROXY
-  if (c->options.http_proxy_options)
+  if (c->options.ce.http_proxy_options)
     proxy = true;
 #endif
 #ifdef ENABLE_SOCKS
-  if (c->options.socks_proxy_server)
+  if (c->options.ce.socks_proxy_server)
     proxy = true;
 #endif
 
-  switch (c->options.proto)
+  switch (c->options.ce.proto)
     {
     case PROTO_UDPv4:
       if (proxy)
-	sec = c->options.connect_retry_seconds;
+	sec = c->options.ce.connect_retry_seconds;
       break;
     case PROTO_TCPv4_SERVER:
       sec = 1;
       break;
     case PROTO_TCPv4_CLIENT:
-      sec = c->options.connect_retry_seconds;
+      sec = c->options.ce.connect_retry_seconds;
       break;
     }
 
@@ -1543,7 +1727,7 @@
 
   /* should we not xmit any packets until we get an initial
      response from client? */
-  if (to.server && options->proto == PROTO_TCPv4_SERVER)
+  if (to.server && options->ce.proto == PROTO_TCPv4_SERVER)
     to.xmit_hold = true;
 
 #ifdef ENABLE_OCC
@@ -1564,6 +1748,10 @@
 
   to.plugins = c->plugins;
 
+#ifdef MANAGEMENT_DEF_AUTH
+  to.mda_context = &c->c2.mda_context;
+#endif
+
 #if P2MP_SERVER
   to.auth_user_pass_verify_script = options->auth_user_pass_verify_script;
   to.auth_user_pass_verify_script_via_file = options->auth_user_pass_verify_script_via_file;
@@ -1586,7 +1774,7 @@
 
   /* If we are running over TCP, allow for
      length prefix */
-  socket_adjust_frame_parameters (&to.frame, options->proto);
+  socket_adjust_frame_parameters (&to.frame, options->ce.proto);
 
   /*
    * Initialize OpenVPN's master TLS-mode object.
@@ -1684,8 +1872,8 @@
   /*
    * Adjust frame size for UDP Socks support.
    */
-  if (c->options.socks_proxy_server)
-    socks_adjust_frame_parameters (&c->c2.frame, c->options.proto);
+  if (c->options.ce.socks_proxy_server)
+    socks_adjust_frame_parameters (&c->c2.frame, c->options.ce.proto);
 #endif
 
   /*
@@ -1699,7 +1887,7 @@
    * (Since TCP is a stream protocol, we need to insert
    * a packet length uint16_t in the buffer.)
    */
-  socket_adjust_frame_parameters (&c->c2.frame, c->options.proto);
+  socket_adjust_frame_parameters (&c->c2.frame, c->options.ce.proto);
 
   /*
    * Fill in the blanks in the frame parameters structure,
@@ -1741,7 +1929,7 @@
   const struct options *o = &c->options;
 
 #if 1 /* JYFIXME -- port warning */
-  if (!o->port_option_used && (o->local_port == OPENVPN_PORT && o->remote_port == OPENVPN_PORT))
+  if (!o->ce.port_option_used && (o->ce.local_port == OPENVPN_PORT && o->ce.remote_port == OPENVPN_PORT))
     msg (M_WARN, "IMPORTANT: OpenVPN's default port number is now %d, based on an official port number assignment by IANA.  OpenVPN 2.0-beta16 and earlier used 5000 as the default port.",
 	 OPENVPN_PORT);
 #endif
@@ -1761,6 +1949,9 @@
      msg (M_WARN, "WARNING: you are using user/group/chroot without persist-key -- this may cause restarts to fail");
    }
 
+  if (o->chroot_dir && !(o->username && o->groupname))
+    msg (M_WARN, "WARNING: you are using chroot without specifying user and group -- this may cause the chroot jail to be insecure");
+
 #if P2MP
   if (o->pull && o->ifconfig_local && c->first_time)
     msg (M_WARN, "WARNING: using --pull/--client and --ifconfig together is probably not what you want");
@@ -1791,13 +1982,20 @@
       && !(o->ns_cert_type & NS_SSL_SERVER)
       && !o->remote_cert_eku)
     msg (M_WARN, "WARNING: No server certificate verification method has been enabled.  See http://openvpn.net/howto.html#mitm for more info.");
+  if (o->tls_remote)
+    msg (M_WARN, "WARNING: Make sure you understand the semantics of --tls-remote before using it (see the man page).");
 #endif
 #endif
 
 #ifndef CONNECT_NONBLOCK
-  if (o->connect_timeout_defined)
+  if (o->ce.connect_timeout_defined)
     msg (M_WARN, "NOTE: --connect-timeout option is not supported on this OS");
 #endif
+
+  if (script_security >= SSEC_SCRIPTS)
+    msg (M_WARN, "NOTE: the current --script-security setting may allow this configuration to call user-defined scripts");
+  if (script_security >= SSEC_PW_ENV)
+    msg (M_WARN, "WARNING: the current --script-security setting may allow passwords to be passed to scripts via environmental variables");
 }
 
 static void
@@ -1920,10 +2118,12 @@
 #endif
 
   link_socket_init_phase1 (c->c2.link_socket,
-			   c->options.local,
-			   c->c1.remote_list,
-			   c->options.local_port,
-			   c->options.proto,
+			   connection_list_defined (&c->options),
+			   c->options.ce.local,
+			   c->options.ce.local_port,
+			   c->options.ce.remote,
+			   c->options.ce.remote_port,
+			   c->options.ce.proto,
 			   mode,
 			   c->c2.accept_from,
 #ifdef ENABLE_HTTP_PROXY
@@ -1935,16 +2135,16 @@
 #ifdef ENABLE_DEBUG
 			   c->options.gremlin,
 #endif
-			   c->options.bind_local,
-			   c->options.remote_float,
+			   c->options.ce.bind_local,
+			   c->options.ce.remote_float,
 			   c->options.inetd,
 			   &c->c1.link_socket_addr,
 			   c->options.ipchange,
 			   c->plugins,
 			   c->options.resolve_retry_seconds,
-			   c->options.connect_retry_seconds,
-			   c->options.connect_timeout,
-			   c->options.connect_retry_max,
+			   c->options.ce.connect_retry_seconds,
+			   c->options.ce.connect_timeout,
+			   c->options.ce.connect_retry_max,
 			   c->options.mtu_discover_type,
 			   c->options.rcvbuf,
 			   c->options.sndbuf,
@@ -2304,7 +2504,7 @@
 #ifdef WIN32
       msg (M_INFO, "NOTE: --fast-io is disabled since we are running on Windows");
 #else
-      if (c->options.proto != PROTO_UDPv4)
+      if (c->options.ce.proto != PROTO_UDPv4)
 	msg (M_INFO, "NOTE: --fast-io is disabled since we are not using UDP");
       else
 	{
@@ -2362,7 +2562,7 @@
 		{
 		  unsigned int option_types_found = 0;
 		  if (config.list[i] && config.list[i]->value)
-		    options_plugin_import (&c->options,
+		    options_string_import (&c->options,
 					   config.list[i]->value,
 					   D_IMPORT_ERRORS|M_OPTERR,
 					   OPT_P_DEFAULT & ~OPT_P_PLUGIN,
@@ -2458,21 +2658,19 @@
     {
       if (c->options.management_addr)
 	{
+	  unsigned int flags = c->options.management_flags;
+	  if (c->options.mode == MODE_SERVER)
+	    flags |= MF_SERVER;
 	  if (management_open (management,
 			       c->options.management_addr,
 			       c->options.management_port,
 			       c->options.management_user_pass,
-			       c->options.mode == MODE_SERVER,
-			       c->options.management_query_passwords,
 			       c->options.management_log_history_cache,
 			       c->options.management_echo_buffer_size,
 			       c->options.management_state_buffer_size,
-			       c->options.management_hold,
-			       c->options.management_signal,
-			       c->options.management_forget_disconnect,
-			       c->options.management_client,
 			       c->options.management_write_peer_info_file,
-			       c->options.remap_sigusr1))
+			       c->options.remap_sigusr1,
+			       flags))
 	    {
 	      management_set_state (management,
 				    OPENVPN_STATE_CONNECTING,
@@ -2560,10 +2758,13 @@
   c->sig->signal_text = NULL;
   c->sig->hard = false;
 
+  /* map in current connection entry */
+  next_connection_entry (c);
+
   /* link_socket_mode allows CM_CHILD_TCP
      instances to inherit acceptable fds
      from a top-level parent */
-  if (c->options.proto == PROTO_TCPv4_SERVER)
+  if (c->options.ce.proto == PROTO_TCPv4_SERVER)
     {
       if (c->mode == CM_TOP)
 	link_socket_mode = LS_MODE_TCP_LISTEN;
@@ -2637,6 +2838,9 @@
   else if (c->mode == CM_CHILD_TCP)
     do_event_set_init (c, false);
 
+  /* initialize HTTP or SOCKS proxy object at scope level 2 */
+  init_proxy (c, 2);
+
   /* allocate our socket object */
   if (c->mode == CM_P2P || c->mode == CM_TOP || c->mode == CM_CHILD_TCP)
     do_link_socket_new (c);
@@ -2743,6 +2947,11 @@
     init_port_share (c);
 #endif
 	  
+#ifdef ENABLE_PF
+  if (child)
+    pf_init_context (c);
+#endif
+
   /* Check for signals */
   if (IS_SIG (c))
     goto sig;
@@ -2793,6 +3002,15 @@
 	/* close TUN/TAP device */
 	do_close_tun (c, false);
 
+#ifdef MANAGEMENT_DEF_AUTH
+	if (management)
+	  management_notify_client_close (management, &c->c2.mda_context, NULL);
+#endif
+
+#ifdef ENABLE_PF
+	pf_destroy_context (&c->c2.pf);
+#endif
+
 #ifdef ENABLE_PLUGIN
 	/* call plugin close functions and unload */
 	do_close_plugins (c);
@@ -2815,6 +3033,9 @@
 	/* free up environmental variable store */
 	do_env_set_destroy (c);
 
+	/* close HTTP or SOCKS proxy */
+	uninit_proxy (c);
+
 	/* garbage collect */
 	gc_free (&c->c2.gc);
       }
@@ -2826,7 +3047,7 @@
 {
   CLEAR (*dest);
 
-  switch (src->options.proto)
+  switch (src->options.ce.proto)
     {
     case PROTO_UDPv4:
       dest->mode = CM_CHILD_UDP;
@@ -2942,7 +3163,7 @@
   dest->c2.es_owned = false;
 
   dest->c2.event_set = NULL;
-  if (src->options.proto == PROTO_UDPv4)
+  if (src->options.ce.proto == PROTO_UDPv4)
     do_event_set_init (dest, false);
 }
 
diff -urN openvpn-2.1_rc7/init.h openvpn-2.1_rc9/init.h
--- openvpn-2.1_rc7/init.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/init.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/install-win32/.svnignore openvpn-2.1_rc9/install-win32/.svnignore
--- openvpn-2.1_rc7/install-win32/.svnignore	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/.svnignore	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-openvpn.nsi
diff -urN openvpn-2.1_rc7/install-win32/Makefile.am openvpn-2.1_rc9/install-win32/Makefile.am
--- openvpn-2.1_rc7/install-win32/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/Makefile.am	2008-07-14 20:49:16.000000000 +0200
@@ -0,0 +1,97 @@
+#
+#  OpenVPN -- An application to securely tunnel IP networks
+#             over a single UDP port, with support for SSL/TLS-based
+#             session authentication and key exchange,
+#             packet encryption, packet authentication, and
+#             packet compression.
+#
+#  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License version 2
+#  as published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program (see the file COPYING included with this
+#  distribution); if not, write to the Free Software Foundation, Inc.,
+#  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+
+dist_noinst_DATA = \
+	openssl \
+	GetWindowsVersion.nsi \
+	build-pkcs11-helper.sh \
+	buildinstaller \
+	ddk-common \
+	doclean \
+	dosname.pl \
+	getgui \
+	getopenssl \
+	getpkcs11helper \
+	getprebuilt \
+	getxgui \
+	ifdef.pl \
+	m4todef.pl \
+	macro.pl \
+	makeopenvpn \
+	maketap \
+	maketapinstall \
+	maketext \
+	openvpn.nsi \
+	setpath.nsi \
+	settings.in \
+	trans.pl \
+	u2d.c \
+	winconfig
+
+if WIN32
+
+nodist_doc_DATA = tmp/license.txt
+
+confdir = $(win32datadir)/config
+nodist_conf_DATA = \
+	tmp/openssl.cnf.sample \
+	tmp/client.ovpn \
+	tmp/server.ovpn
+dist_conf_DATA = \
+	sample.ovpn
+
+easyrsadir = $(win32datadir)/easy-rsa/Windows
+nodist_easyrsa_DATA = \
+	$(top_srcdir)/easy-rsa/Windows/*
+
+keysdir = $(win32datadir)/sample-keys
+nodist_keys_DATA = \
+	$(top_srcdir)/sample-keys/*
+
+tmp:
+	mkdir tmp
+
+tmp/client.ovpn:	tmp $(top_srcdir)/sample-config-files/client.conf
+	cp $(top_srcdir)/sample-config-files/client.conf tmp/client.ovpn
+
+tmp/server.ovpn:	tmp $(top_srcdir)/sample-config-files/server.conf
+	cp $(top_srcdir)/sample-config-files/server.conf tmp/server.ovpn
+
+tmp/license.txt:	tmp $(top_srcdir)/COPYING $(top_srcdir)/COPYRIGHT.GPL
+	cat $(top_srcdir)/COPYING $(top_srcdir)/COPYRIGHT.GPL > tmp/license.txt
+
+tmp/openssl.cnf.sample:	tmp $(top_srcdir)/easy-rsa/2.0/openssl.cnf
+	cp $(top_srcdir)/easy-rsa/2.0/openssl.cnf tmp/openssl.cnf.sample
+
+clean-local:
+	-rm -fr tmp
+
+else
+
+dist_noinst_DATA += sample.ovpn
+
+endif
+
diff -urN openvpn-2.1_rc7/install-win32/Makefile.in openvpn-2.1_rc9/install-win32/Makefile.in
--- openvpn-2.1_rc7/install-win32/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/Makefile.in	2008-07-31 19:45:20.000000000 +0200
@@ -0,0 +1,502 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#
+#  OpenVPN -- An application to securely tunnel IP networks
+#             over a single UDP port, with support for SSL/TLS-based
+#             session authentication and key exchange,
+#             packet encryption, packet authentication, and
+#             packet compression.
+#
+#  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License version 2
+#  as published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program (see the file COPYING included with this
+#  distribution); if not, write to the Free Software Foundation, Inc.,
+#  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+@WIN32_FALSE@am__append_1 = sample.ovpn
+subdir = install-win32
+DIST_COMMON = $(am__dist_conf_DATA_DIST) $(am__dist_noinst_DATA_DIST) \
+	$(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(srcdir)/settings.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/version.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES = settings
+SOURCES =
+DIST_SOURCES =
+am__dist_conf_DATA_DIST = sample.ovpn
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(confdir)" "$(DESTDIR)$(confdir)" \
+	"$(DESTDIR)$(docdir)" "$(DESTDIR)$(easyrsadir)" \
+	"$(DESTDIR)$(keysdir)"
+dist_confDATA_INSTALL = $(INSTALL_DATA)
+am__dist_noinst_DATA_DIST = openssl GetWindowsVersion.nsi \
+	build-pkcs11-helper.sh buildinstaller ddk-common doclean \
+	dosname.pl getgui getopenssl getpkcs11helper getprebuilt \
+	getxgui ifdef.pl m4todef.pl macro.pl makeopenvpn maketap \
+	maketapinstall maketext openvpn.nsi setpath.nsi settings.in \
+	trans.pl u2d.c winconfig sample.ovpn
+nodist_confDATA_INSTALL = $(INSTALL_DATA)
+nodist_docDATA_INSTALL = $(INSTALL_DATA)
+nodist_easyrsaDATA_INSTALL = $(INSTALL_DATA)
+nodist_keysDATA_INSTALL = $(INSTALL_DATA)
+DATA = $(dist_conf_DATA) $(dist_noinst_DATA) $(nodist_conf_DATA) \
+	$(nodist_doc_DATA) $(nodist_easyrsa_DATA) $(nodist_keys_DATA)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+GREP = @GREP@
+IFCONFIG = @IFCONFIG@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+IPROUTE = @IPROUTE@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MAN2HTML = @MAN2HTML@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PTHREAD_CC = @PTHREAD_CC@
+PTHREAD_CFLAGS = @PTHREAD_CFLAGS@
+PTHREAD_LIBS = @PTHREAD_LIBS@
+ROUTE = @ROUTE@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+TAP_ID = @TAP_ID@
+TAP_WIN32_MIN_MAJOR = @TAP_WIN32_MIN_MAJOR@
+TAP_WIN32_MIN_MINOR = @TAP_WIN32_MIN_MINOR@
+VERSION = @VERSION@
+WIN32_FALSE = @WIN32_FALSE@
+WIN32_TRUE = @WIN32_TRUE@
+ac_ct_CC = @ac_ct_CC@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+win32datadir = @win32datadir@
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+dist_noinst_DATA = openssl GetWindowsVersion.nsi \
+	build-pkcs11-helper.sh buildinstaller ddk-common doclean \
+	dosname.pl getgui getopenssl getpkcs11helper getprebuilt \
+	getxgui ifdef.pl m4todef.pl macro.pl makeopenvpn maketap \
+	maketapinstall maketext openvpn.nsi setpath.nsi settings.in \
+	trans.pl u2d.c winconfig $(am__append_1)
+@WIN32_TRUE@nodist_doc_DATA = tmp/license.txt
+@WIN32_TRUE@confdir = $(win32datadir)/config
+@WIN32_TRUE@nodist_conf_DATA = \
+@WIN32_TRUE@	tmp/openssl.cnf.sample \
+@WIN32_TRUE@	tmp/client.ovpn \
+@WIN32_TRUE@	tmp/server.ovpn
+
+@WIN32_TRUE@dist_conf_DATA = \
+@WIN32_TRUE@	sample.ovpn
+
+@WIN32_TRUE@easyrsadir = $(win32datadir)/easy-rsa/Windows
+@WIN32_TRUE@nodist_easyrsa_DATA = \
+@WIN32_TRUE@	$(top_srcdir)/easy-rsa/Windows/*
+
+@WIN32_TRUE@keysdir = $(win32datadir)/sample-keys
+@WIN32_TRUE@nodist_keys_DATA = \
+@WIN32_TRUE@	$(top_srcdir)/sample-keys/*
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  install-win32/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  install-win32/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+settings: $(top_builddir)/config.status $(srcdir)/settings.in
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
+uninstall-info-am:
+install-dist_confDATA: $(dist_conf_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(confdir)" || $(mkdir_p) "$(DESTDIR)$(confdir)"
+	@list='$(dist_conf_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(dist_confDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(confdir)/$$f'"; \
+	  $(dist_confDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(confdir)/$$f"; \
+	done
+
+uninstall-dist_confDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(dist_conf_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(confdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(confdir)/$$f"; \
+	done
+install-nodist_confDATA: $(nodist_conf_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(confdir)" || $(mkdir_p) "$(DESTDIR)$(confdir)"
+	@list='$(nodist_conf_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(nodist_confDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(confdir)/$$f'"; \
+	  $(nodist_confDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(confdir)/$$f"; \
+	done
+
+uninstall-nodist_confDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(nodist_conf_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(confdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(confdir)/$$f"; \
+	done
+install-nodist_docDATA: $(nodist_doc_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(docdir)" || $(mkdir_p) "$(DESTDIR)$(docdir)"
+	@list='$(nodist_doc_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(nodist_docDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(docdir)/$$f'"; \
+	  $(nodist_docDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(docdir)/$$f"; \
+	done
+
+uninstall-nodist_docDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(nodist_doc_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(docdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(docdir)/$$f"; \
+	done
+install-nodist_easyrsaDATA: $(nodist_easyrsa_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(easyrsadir)" || $(mkdir_p) "$(DESTDIR)$(easyrsadir)"
+	@list='$(nodist_easyrsa_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(nodist_easyrsaDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(easyrsadir)/$$f'"; \
+	  $(nodist_easyrsaDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(easyrsadir)/$$f"; \
+	done
+
+uninstall-nodist_easyrsaDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(nodist_easyrsa_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(easyrsadir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(easyrsadir)/$$f"; \
+	done
+install-nodist_keysDATA: $(nodist_keys_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(keysdir)" || $(mkdir_p) "$(DESTDIR)$(keysdir)"
+	@list='$(nodist_keys_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(nodist_keysDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(keysdir)/$$f'"; \
+	  $(nodist_keysDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(keysdir)/$$f"; \
+	done
+
+uninstall-nodist_keysDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(nodist_keys_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(keysdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(keysdir)/$$f"; \
+	done
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(DATA)
+installdirs:
+	for dir in "$(DESTDIR)$(confdir)" "$(DESTDIR)$(confdir)" "$(DESTDIR)$(docdir)" "$(DESTDIR)$(easyrsadir)" "$(DESTDIR)$(keysdir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+@WIN32_FALSE@clean-local:
+clean: clean-am
+
+clean-am: clean-generic clean-local mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-dist_confDATA install-nodist_confDATA \
+	install-nodist_docDATA install-nodist_easyrsaDATA \
+	install-nodist_keysDATA
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-dist_confDATA uninstall-info-am \
+	uninstall-nodist_confDATA uninstall-nodist_docDATA \
+	uninstall-nodist_easyrsaDATA uninstall-nodist_keysDATA
+
+.PHONY: all all-am check check-am clean clean-generic clean-local \
+	distclean distclean-generic distdir dvi dvi-am html html-am \
+	info info-am install install-am install-data install-data-am \
+	install-dist_confDATA install-exec install-exec-am \
+	install-info install-info-am install-man \
+	install-nodist_confDATA install-nodist_docDATA \
+	install-nodist_easyrsaDATA install-nodist_keysDATA \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am \
+	uninstall-dist_confDATA uninstall-info-am \
+	uninstall-nodist_confDATA uninstall-nodist_docDATA \
+	uninstall-nodist_easyrsaDATA uninstall-nodist_keysDATA
+
+
+@WIN32_TRUE@tmp:
+@WIN32_TRUE@	mkdir tmp
+
+@WIN32_TRUE@tmp/client.ovpn:	tmp $(top_srcdir)/sample-config-files/client.conf
+@WIN32_TRUE@	cp $(top_srcdir)/sample-config-files/client.conf tmp/client.ovpn
+
+@WIN32_TRUE@tmp/server.ovpn:	tmp $(top_srcdir)/sample-config-files/server.conf
+@WIN32_TRUE@	cp $(top_srcdir)/sample-config-files/server.conf tmp/server.ovpn
+
+@WIN32_TRUE@tmp/license.txt:	tmp $(top_srcdir)/COPYING $(top_srcdir)/COPYRIGHT.GPL
+@WIN32_TRUE@	cat $(top_srcdir)/COPYING $(top_srcdir)/COPYRIGHT.GPL > tmp/license.txt
+
+@WIN32_TRUE@tmp/openssl.cnf.sample:	tmp $(top_srcdir)/easy-rsa/2.0/openssl.cnf
+@WIN32_TRUE@	cp $(top_srcdir)/easy-rsa/2.0/openssl.cnf tmp/openssl.cnf.sample
+
+@WIN32_TRUE@clean-local:
+@WIN32_TRUE@	-rm -fr tmp
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN openvpn-2.1_rc7/install-win32/build-pkcs11-helper.sh openvpn-2.1_rc9/install-win32/build-pkcs11-helper.sh
--- openvpn-2.1_rc7/install-win32/build-pkcs11-helper.sh	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/build-pkcs11-helper.sh	2008-06-13 09:54:55.000000000 +0200
@@ -1,5 +1,5 @@
-F=pkcs11-helper-1.05
-OPENSSL_DIR=`pwd`/openssl-0.9.7m
+F=pkcs11-helper-1.06-beta1
+OPENSSL_DIR=`pwd`/openssl-0.9.8h
 
 PKCS11_HELPER_DIR=`pwd`/pkcs11-helper
 rm -rf $PKCS11_HELPER_DIR
@@ -12,12 +12,13 @@
 cd $F
 ./configure \
 	MAN2HTML=true \
-	ac_cv_type_size_t=no \
 	--disable-crypto-engine-gnutls \
         --disable-crypto-engine-nss \
         PKG_CONFIG=true \
         OPENSSL_CFLAGS="-I${OPENSSL_DIR}/include" \
-        OPENSSL_LIBS="-L${OPENSSL_DIR}/out -lcrypto"
+        OPENSSL_LIBS="-L${OPENSSL_DIR}/out -leay32"
 
 make
 make install DESTDIR="${PKCS11_HELPER_DIR}"
+
+# ./configure doesn't need this any more: ac_cv_type_size_t=no
diff -urN openvpn-2.1_rc7/install-win32/buildinstaller openvpn-2.1_rc9/install-win32/buildinstaller
--- openvpn-2.1_rc7/install-win32/buildinstaller	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/buildinstaller	2008-06-13 09:54:55.000000000 +0200
@@ -1,8 +1,22 @@
 #!/bin/sh
 
-# build the installer
+# load version.nsi definitions
+. autodefs/defs.sh
 
+# build the installer
 cd install-win32
 rm -f *.exe
 '/c/Program Files/NSIS/makensis' openvpn.nsi &>makensis.log
 tail -20 makensis.log
+
+# copy the installer to GENOUT/install
+ls openvpn*.exe 2>/dev/null || exit 1
+i=`ls -t openvpn*.exe | head -n 1`
+cd ..
+mkdir $GENOUT/install &>/dev/null
+cp install-win32/$i $GENOUT/install
+
+# sign the installer
+if [ -d "$SIGNTOOL" ]; then
+    TARGET_EXE="$(pwd)/$GENOUT/install/$i" $SIGNTOOL/signexe
+fi
diff -urN openvpn-2.1_rc7/install-win32/buildopensslpath.bat openvpn-2.1_rc9/install-win32/buildopensslpath.bat
--- openvpn-2.1_rc7/install-win32/buildopensslpath.bat	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/buildopensslpath.bat	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-REM set path for OpenSSL build
-
-set PATH=c:\bin;C:\Perl\bin\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;c:\MinGW\bin;c:\msys\1.0\bin
diff -urN openvpn-2.1_rc7/install-win32/copyinstaller openvpn-2.1_rc9/install-win32/copyinstaller
--- openvpn-2.1_rc7/install-win32/copyinstaller	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/copyinstaller	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-#!/bin/sh
-
-# copy the installer to the $INSTALLER_DEST directory.
-
-# load version.nsi definitions
-. autodefs/defs.sh
-
-if [ -n "$INSTALLER_DEST" ] ; then
-    cd install-win32
-    ls openvpn*.exe 2>/dev/null || exit 1
-    exe=install-win32/`ls -t openvpn*.exe | head -n 1`
-    cd ..
-    echo cp $exe "$INSTALLER_DEST"
-    cp $exe "$INSTALLER_DEST"
-fi
diff -urN openvpn-2.1_rc7/install-win32/doclean openvpn-2.1_rc9/install-win32/doclean
--- openvpn-2.1_rc7/install-win32/doclean	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/doclean	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+# get version.nsi definitions
+. autodefs/defs.sh
+
+[ "$CLEAN" = "yes" ] && rm -rf $GENOUT
diff -urN openvpn-2.1_rc7/install-win32/getgui openvpn-2.1_rc9/install-win32/getgui
--- openvpn-2.1_rc7/install-win32/getgui	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/getgui	2008-06-13 09:54:55.000000000 +0200
@@ -2,20 +2,21 @@
 
 # Get and sign the OpenVPN GUI
 
-c=`pwd`
-
 # load version.nsi definitions
 . autodefs/defs.sh
 
 GUI="$OPENVPN_GUI_DIR/$OPENVPN_GUI"
 
 if [ -e "$GUI" ]; then
-    cp $GUI bin
-    echo '!define OPENVPN_GUI_DEFINED' >autodefs/guidefs.nsi
+    mkdir -p $GENOUT/bin &>/dev/null    
+    cp $GUI $GENOUT/bin
     if [ -d "$SIGNTOOL" ]; then
-	export TARGET_EXE="bin/$OPENVPN_GUI"
-	$SIGNTOOL/signexe
+	TARGET_EXE="$GENOUT/bin/$OPENVPN_GUI" $SIGNTOOL/signexe
     fi
+fi
+
+if [ -e "$GENOUT/bin/$OPENVPN_GUI" ]; then
+    echo '!define OPENVPN_GUI_DEFINED' >autodefs/guidefs.nsi
 else
     cat /dev/null >autodefs/guidefs.nsi
 fi
diff -urN openvpn-2.1_rc7/install-win32/getopenssl openvpn-2.1_rc9/install-win32/getopenssl
--- openvpn-2.1_rc7/install-win32/getopenssl	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/getopenssl	2008-07-31 22:53:22.000000000 +0200
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# get version.nsi definitions
+. autodefs/defs.sh
+
+# Get OpenSSL binaries
+if [ -d "$OPENSSL_DIR" ] ; then
+    mkdir -p $GENOUT/lib &>/dev/null    
+    mkdir -p $GENOUT/bin &>/dev/null    
+    for f in libeay32.dll libssl32.dll out/openssl.exe ; do
+	cp $OPENSSL_DIR/$f $GENOUT/lib
+        if [ -z "$NO_STRIP" ]; then
+	    strip $GENOUT/lib/$f
+	fi
+    done
+    mv $GENOUT/lib/openssl.exe $GENOUT/bin
+else
+    echo OpenSSL DIR $OPENSSL_DIR NOT FOUND
+fi
diff -urN openvpn-2.1_rc7/install-win32/getpkcs11helper openvpn-2.1_rc9/install-win32/getpkcs11helper
--- openvpn-2.1_rc7/install-win32/getpkcs11helper	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/getpkcs11helper	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+# get version.nsi definitions
+. autodefs/defs.sh
+
+# Get PKCS11-helper libraries
+if [ -d "$PKCS11_HELPER_DIR" ] ; then
+    mkdir -p $GENOUT/lib &>/dev/null    
+    for f in libpkcs11-helper-1.dll ; do
+	cp $PKCS11_HELPER_DIR/usr/local/bin/$f $GENOUT/lib
+        if [ -z "$NO_STRIP" ]; then
+	    strip $GENOUT/lib/$f
+	fi
+    done
+else
+    echo PKCS11-helper DIR $PKCS11_HELPER_DIR NOT FOUND
+fi
diff -urN openvpn-2.1_rc7/install-win32/getprebuilt openvpn-2.1_rc9/install-win32/getprebuilt
--- openvpn-2.1_rc7/install-win32/getprebuilt	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/getprebuilt	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+# get version.nsi definitions
+. autodefs/defs.sh
+
+# Get PKCS11-helper libraries
+if [ -d "$GENOUT_PREBUILT" ] && ! [ -d "$GENOUT" ]; then
+    echo LOADING prebuilt binaries from $GENOUT_PREBUILT
+    cp -a $GENOUT_PREBUILT $GENOUT
+fi
diff -urN openvpn-2.1_rc7/install-win32/getxgui openvpn-2.1_rc9/install-win32/getxgui
--- openvpn-2.1_rc7/install-win32/getxgui	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/getxgui	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+# Get and sign the OpenVPN XML-based GUI
+
+# load version.nsi definitions
+. autodefs/defs.sh
+
+if [ -d "$OPENVPN_XGUI_DIR" ]; then
+    SIGNED_EXES="gui/ovpn-xgui-en.exe sta/ovpn-tray.exe"
+    UNSIGNED_EXES="xmlserv/ovpn-xmlserv.exe"
+    EXES="$SIGNED_EXES $UNSIGNED_EXES"
+
+    mkdir -p $GENOUT/bin &>/dev/null
+
+    if [ -z "$NO_STRIP" ]; then
+	for f in $EXES; do
+	    cp $OPENVPN_XGUI_DIR/$f $GENOUT/bin
+	    strip $GENOUT/bin/`basename $f`
+	done
+    fi
+
+    for f in $SIGNED_EXES; do
+	if [ -d "$SIGNTOOL" ]; then
+	    TARGET_EXE="$GENOUT/bin/`basename $f`" $SIGNTOOL/signexe
+	fi
+    done
+
+    rm -rf $GENOUT/htdocs
+    cp -a $OPENVPN_XGUI_DIR/ajax/htdocs $GENOUT/htdocs
+
+    echo '!define OPENVPN_XGUI_DEFINED' >autodefs/xguidefs.nsi
+else
+    cat /dev/null >autodefs/xguidefs.nsi
+fi
diff -urN openvpn-2.1_rc7/install-win32/makebin openvpn-2.1_rc9/install-win32/makebin
--- openvpn-2.1_rc7/install-win32/makebin	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/makebin	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-#!/bin/sh
-
-# Assemble binaries into bin
-
-# get version.nsi definitions
-. autodefs/defs.sh
-
-rm -rf bin
-mkdir bin
-
-# Get OpenVPN executable
-cp $PRODUCT_UNIX_NAME.exe bin
-strip bin/$PRODUCT_UNIX_NAME.exe
-
-# Get OpenVPN service
-cp service-win32/${PRODUCT_UNIX_NAME}serv.exe bin
-strip bin/${PRODUCT_UNIX_NAME}serv.exe
-
-# Get OpenSSL binaries
-for f in libeay32.dll libssl32.dll openssl.exe ; do
-  cp $OPENSSL_DIR/$f bin
-  strip bin/$f
-done
-
-# Get PKCS11 libraries
-for f in libpkcs11-helper-1.dll ; do
-    cp $PKCS11_HELPER_DIR/bin/$f bin
-    strip bin/$f
-done
-
-# $DRVBINSRC, if defined, points to prebuilt TAP driver and
-# tapinstall.exe.
-if [ -z "$DRVBINSRC" ] ; then
-    # Get TAP drivers
-    cp -a tap-win32/dist bin/driver
-
-    # Get tapinstall
-    mkdir bin/tapinstall
-    mkdir bin/tapinstall/i386
-    mkdir bin/tapinstall/amd64
-    cp tapinstall/objfre_w2k_x86/i386/tapinstall.exe bin/tapinstall/i386
-    cp tapinstall/objfre_wnet_amd64/amd64/tapinstall.exe bin/tapinstall/amd64
-else
-    cp -a $DRVBINSRC/driver bin/driver
-    cp -a $DRVBINSRC/tapinstall bin/tapinstall
-fi
-
-# $DRVBINDEST, if defined, points to a destination directory
-# where TAP driver and tapinstall.exe will be saved, to be used
-# as a $DRVBINSRC in future builds.
-if [ -n "$DRVBINDEST" ] ; then
-    rm -rf $DRVBINDEST
-    mkdir $DRVBINDEST
-    cp -a bin/driver $DRVBINDEST
-    cp -a bin/tapinstall $DRVBINDEST
-fi
diff -urN openvpn-2.1_rc7/install-win32/makeopenvpn openvpn-2.1_rc9/install-win32/makeopenvpn
--- openvpn-2.1_rc7/install-win32/makeopenvpn	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/makeopenvpn	2008-06-13 09:54:55.000000000 +0200
@@ -1,16 +1,37 @@
 #!/bin/sh
 
+H=`pwd`
+
 # get version.nsi definitions
 . autodefs/defs.sh
 
-# build OpenVPN binary
-[ "$MAKE_CLEAN" = "yes" ] && make -f makefile.w32 clean
-make -f makefile.w32 -j $MAKE_JOBS
-
-# build OpenVPN service (openvpnserv.exe)
-if [ -n "$SVC_TEMPLATE" ] ; then
-    cd service-win32
-    [ "$MAKE_CLEAN" = "yes" ] && make clean
-    make -j $MAKE_JOBS
-    cd ..
+if gcc --version &>/dev/null && [ -d "$OPENSSL_DIR" ] && [ -d "$LZO_DIR" ] && [ -d "$PKCS11_HELPER_DIR" ]; then
+    # build OpenVPN binary
+
+    if ! [ -f Makefile ]; then
+	autoreconf -i -v \
+	&& ./configure \
+	    --enable-strict \
+	    --prefix=$H/windest \
+	    MAN2HTML=true \
+	    --with-ssl-headers=$H/$OPENSSL_DIR/include \
+	    --with-ssl-lib=$H/$OPENSSL_DIR/out \
+	    --with-lzo-headers=$H/$LZO_DIR/include \
+	    --with-lzo-lib=$H/$LZO_DIR \
+	    --with-pkcs11-helper-headers=$H/$PKCS11_HELPER_DIR/usr/local/include \
+	    --with-pkcs11-helper-lib=$H/$PKCS11_HELPER_DIR/usr/local/lib
+    fi
+
+    make -j $MAKE_JOBS && make install
+
+    # copy OpenVPN and service executables to GENOUT/bin
+    mkdir -p $GENOUT/bin &>/dev/null
+    cp windest/sbin/openvpn.exe $GENOUT/bin
+    cp windest/sbin/openvpnserv.exe $GENOUT/bin
+    if [ -z "$NO_STRIP" ]; then
+	strip $GENOUT/bin/openvpn.exe
+	strip $GENOUT/bin/openvpnserv.exe
+    fi
+else
+    echo DID NOT BUILD openvpn.exe and openvpnserv.exe because one or more of gcc, OPENSSL_DIR, LZO_DIR, or PKCS11_HELPER_DIR directories were missing
 fi
diff -urN openvpn-2.1_rc7/install-win32/maketap openvpn-2.1_rc9/install-win32/maketap
--- openvpn-2.1_rc7/install-win32/maketap	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/maketap	2008-06-13 09:54:55.000000000 +0200
@@ -6,9 +6,20 @@
 # get version.nsi definitions
 . autodefs/defs.sh
 
+if [ -d "/c/WINDDK/$DDKVER" ] ; then
+
 # common declarations for all DDK build targets
 . install-win32/ddk-common
 
+# configure tap driver sources
+MACRO="perl install-win32/macro.pl autodefs/defs.in"
+IFDEF="perl install-win32/ifdef.pl"
+rm -rf tap-win32/amd64
+mkdir tap-win32/amd64
+$MACRO <tap-win32/SOURCES.in >tap-win32/SOURCES
+$MACRO <tap-win32/i386/OemWin2k.inf.in | $IFDEF >tap-win32/i386/OemWin2k.inf
+$MACRO <tap-win32/i386/OemWin2k.inf.in | $IFDEF -DAMD64 >tap-win32/amd64/OemWin2k.inf
+
 if [ -n "$PRODUCT_TAP_DEBUG" ] ; then
     w2ktarget="w2k c"
     amdtarget="chk $x64_tag WNET"
@@ -57,4 +68,33 @@
     out="TAP driver catalog file is undefined";
     echo "$out" >$x86/$PRODUCT_TAP_ID.cat
     echo "$out" >$x64/$PRODUCT_TAP_ID.cat
+    cd ..
+fi
+
+# $DRVBINSRC, if defined, points to prebuilt TAP driver and
+# tapinstall.exe.
+mkdir $GENOUT &>/dev/null
+rm -rf $GENOUT/driver
+if [ -z "$DRVBINSRC" ] ; then
+    # Get TAP drivers
+    cp -a tap-win32/dist $GENOUT/driver
+
+    # Sign TAP drivers
+    if [ -d "$SIGNTOOL" ]; then
+	$SIGNTOOL/signtap
+    fi
+else
+    cp -a $DRVBINSRC/driver $GENOUT/driver
+fi
+
+# $DRVBINDEST, if defined, points to a destination directory
+# where TAP driver and tapinstall.exe will be saved, to be used
+# as a $DRVBINSRC in future builds.
+if [ -n "$DRVBINDEST" ] ; then
+    mkdir $DRVBINDEST &>/dev/null
+    cp -a $GENOUT/driver $DRVBINDEST
+fi
+
+else
+    echo Not building TAP driver -- DDK version $DDKVER NOT FOUND
 fi
diff -urN openvpn-2.1_rc7/install-win32/maketapinstall openvpn-2.1_rc9/install-win32/maketapinstall
--- openvpn-2.1_rc7/install-win32/maketapinstall	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/maketapinstall	2008-06-13 09:54:55.000000000 +0200
@@ -8,6 +8,8 @@
 # get version.nsi definitions
 . autodefs/defs.sh
 
+if [ -d "/c/WINDDK/$DDKVER" ] ; then
+
 if ! [ -d "$TISRC" ] ; then
     echo "$TISRC" NOT INSTALLED
     exit 1
@@ -46,4 +48,30 @@
     cp "$TI_BIN_AMD64" $t/objfre_wnet_amd64/amd64
 fi
 
+# $DRVBINSRC, if defined, points to prebuilt TAP driver and
+# tapinstall.exe.
+if [ -z "$DRVBINSRC" ] ; then
+    # Get tapinstall
+    mkdir -p $GENOUT/tapinstall/i386 &>/dev/null
+    mkdir -p $GENOUT/tapinstall/amd64 &>/dev/null
+    cp tapinstall/objfre_w2k_x86/i386/tapinstall.exe $GENOUT/tapinstall/i386
+    cp tapinstall/objfre_wnet_amd64/amd64/tapinstall.exe $GENOUT/tapinstall/amd64
+else
+    mkdir $GENOUT &>/dev/null
+    cp -a $DRVBINSRC/tapinstall $GENOUT/tapinstall
+fi
+
+# $DRVBINDEST, if defined, points to a destination directory
+# where TAP driver and tapinstall.exe will be saved, to be used
+# as a $DRVBINSRC in future builds.
+if [ -n "$DRVBINDEST" ] ; then
+    mkdir $DRVBINDEST &>/dev/null
+    cp -a $GENOUT/driver $DRVBINDEST
+    cp -a $GENOUT/tapinstall $DRVBINDEST
+fi
+
 title openvpn-build &>/dev/null
+
+else
+    echo Not building tapinstall -- DDK version $DDKVER NOT BUILT
+fi
diff -urN openvpn-2.1_rc7/install-win32/maketext openvpn-2.1_rc9/install-win32/maketext
--- openvpn-2.1_rc7/install-win32/maketext	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/maketext	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+# get version.nsi definitions
+. autodefs/defs.sh
+
+mkdir -p $GENOUT/text &>/dev/null
+
+# build license file
+cat COPYING COPYRIGHT.GPL >$GENOUT/text/license.txt
+
+# copy install file
+cp INSTALL-win32.txt $GENOUT/text/INSTALL-win32.txt
+
+# copy sample configuration files and docs
+s=$GENOUT/samples
+mkdir -p $s &>/dev/null
+cp sample-config-files/client.conf $s/client.$PRODUCT_FILE_EXT
+cp sample-config-files/server.conf $s/server.$PRODUCT_FILE_EXT
+cp install-win32/sample.ovpn $s/sample.$PRODUCT_FILE_EXT
+cp easy-rsa/1.0/openssl.cnf $s/openssl.cnf.sample
diff -urN openvpn-2.1_rc7/install-win32/openssl/.svn/all-wcprops openvpn-2.1_rc9/install-win32/openssl/.svn/all-wcprops
--- openvpn-2.1_rc7/install-win32/openssl/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl/.svn/all-wcprops	2008-08-01 00:03:37.000000000 +0200
@@ -0,0 +1,23 @@
+K 25
+svn:wc:ra_dav:version-url
+V 77
+/projects/openvpn/!svn/ver/2982/branches/BETA21/openvpn/install-win32/openssl
+END
+openssl097.patch
+K 25
+svn:wc:ra_dav:version-url
+V 94
+/projects/openvpn/!svn/ver/2982/branches/BETA21/openvpn/install-win32/openssl/openssl097.patch
+END
+openssl098.patch
+K 25
+svn:wc:ra_dav:version-url
+V 94
+/projects/openvpn/!svn/ver/3149/branches/BETA21/openvpn/install-win32/openssl/openssl098.patch
+END
+README.txt
+K 25
+svn:wc:ra_dav:version-url
+V 88
+/projects/openvpn/!svn/ver/2982/branches/BETA21/openvpn/install-win32/openssl/README.txt
+END
diff -urN openvpn-2.1_rc7/install-win32/openssl/.svn/entries openvpn-2.1_rc9/install-win32/openssl/.svn/entries
--- openvpn-2.1_rc7/install-win32/openssl/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl/.svn/entries	2008-08-01 00:03:37.000000000 +0200
@@ -0,0 +1,64 @@
+8
+
+dir
+3125
+https://svn.openvpn.net/projects/openvpn/branches/BETA21/openvpn/install-win32/openssl
+https://svn.openvpn.net/projects/openvpn
+
+
+
+2008-06-04T10:53:57.832544Z
+2982
+james
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+e7ae566f-a301-0410-adde-c780ea21d3b5
+
+openssl097.patch
+file
+
+
+
+
+2008-06-13T07:54:55.000000Z
+686b9f53674fe4132af89cdc7aea5344
+2008-06-04T10:53:57.832544Z
+2982
+james
+
+openssl098.patch
+file
+3149
+
+
+
+2008-07-31T20:41:13.000000Z
+6f2e5ab0b37296726fbbd4dbc59df49c
+2008-07-31T22:03:38.310201Z
+3149
+james
+
+README.txt
+file
+
+
+
+
+2008-06-13T07:54:55.000000Z
+23193d2431aedf5200bdbf115e9cefd7
+2008-06-04T10:53:57.832544Z
+2982
+james
+
diff -urN openvpn-2.1_rc7/install-win32/openssl/.svn/format openvpn-2.1_rc9/install-win32/openssl/.svn/format
--- openvpn-2.1_rc7/install-win32/openssl/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl/.svn/format	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1 @@
+8
diff -urN openvpn-2.1_rc7/install-win32/openssl/.svn/text-base/README.txt.svn-base openvpn-2.1_rc9/install-win32/openssl/.svn/text-base/README.txt.svn-base
--- openvpn-2.1_rc7/install-win32/openssl/.svn/text-base/README.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl/.svn/text-base/README.txt.svn-base	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1,22 @@
+Rebuild OpenSSL tarball without symbolic links, so
+it can be extracted on Windows (run on Unix):
+
+  [download tarball and .asc sig]
+  gpg --verify openssl-0.9.8h.tar.gz.asc
+  tar xfz openssl-0.9.8h.tar.gz
+  rm openssl-0.9.8h.tar.gz
+  tar cfzh openssl-0.9.8h.tar.gz openssl-0.9.8h
+
+To apply patch (in MSYS shell):
+
+  cd /c/src/openssl-0.9.8h
+  patch -p1 <../21/install-win32/openssl/openssl098.patch
+
+To build OpenSSL, open a command prompt window, then:
+
+  cd \src\openssl-0.9.8h
+  ms\mw
+
+To build a new patch (optional):
+
+  diff -urw openssl-0.9.8h.orig openssl-0.9.8h | grep -v '^Only in' >openssl098.patch
diff -urN openvpn-2.1_rc7/install-win32/openssl/.svn/text-base/openssl097.patch.svn-base openvpn-2.1_rc9/install-win32/openssl/.svn/text-base/openssl097.patch.svn-base
--- openvpn-2.1_rc7/install-win32/openssl/.svn/text-base/openssl097.patch.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl/.svn/text-base/openssl097.patch.svn-base	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1,68 @@
+[in msys bash window]
+cd /c/src/openssl-0.9.7m
+patch -p1 <../21/install-win32/openssl.patch
+
+[open command prompt window]
+cd \src\openssl-0.9.7m
+ms\mw
+
+diff -wur openssl-0.9.7m.orig/ms/mw.bat openssl-0.9.7m/ms/mw.bat
+--- openssl-0.9.7m.orig/ms/mw.bat	Sat Feb 22 11:02:46 2003
++++ openssl-0.9.7m/ms/mw.bat	Mon Jan 21 23:12:34 2008
+@@ -1,17 +1,23 @@
+ @rem OpenSSL with Mingw32
+ @rem --------------------
+ 
++@rem Include MinGW, MSYS, and ActiveState Perl in path
++set PATH=c:\perl\bin;c:\MinGW\bin;c:\msys\1.0\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem
++
+ @rem Makefile
+ perl util\mkfiles.pl >MINFO
+-perl util\mk1mf.pl Mingw32 >ms\mingw32.mak
++perl util\mk1mf.pl no-idea no-mdc2 no-rc5 Mingw32 >ms\mingw32.mak
++
+ @rem DLL definition files
+-perl util\mkdef.pl 32 libeay >ms\libeay32.def
++perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 libeay >ms\libeay32.def
+ if errorlevel 1 goto end
+-perl util\mkdef.pl 32 ssleay >ms\ssleay32.def
++perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 ssleay >ms\ssleay32.def
+ if errorlevel 1 goto end
+ 
+ @rem Build the libraries
+-make -f ms/mingw32.mak
++
++@rem JY added --win32 flag
++make --win32 -f ms/mingw32.mak
+ if errorlevel 1 goto end
+ 
+ @rem Generate the DLLs and input libraries
+@@ -20,7 +26,9 @@
+ dllwrap --dllname libssl32.dll --output-lib out/libssl32.a --def ms/ssleay32.def out/libssl.a out/libeay32.a
+ if errorlevel 1 goto end
+ 
++@rem JY added openssl.exe linked to DLL
++gcc -o openssl  tmp\verify.o tmp\asn1pars.o tmp\req.o tmp\dgst.o tmp\dh.o tmp\dhparam.o tmp\enc.o tmp\passwd.o tmp\gendh.o tmp\errstr.o tmp\ca.o tmp\pkcs7.o tmp\crl2p7.o tmp\crl.o tmp\rsa.o tmp\rsautl.o tmp\dsa.o tmp\dsaparam.o tmp\x509.o tmp\genrsa.o tmp\gendsa.o tmp\s_server.o tmp\s_client.o tmp\speed.o tmp\s_time.o tmp\apps.o tmp\s_cb.o tmp\s_socket.o tmp\app_rand.o tmp\version.o tmp\sess_id.o tmp\ciphers.o tmp\nseq.o tmp\pkcs12.o tmp\pkcs8.o tmp\spkac.o tmp\smime.o tmp\rand.o tmp\engine.o tmp\ocsp.o tmp\prime.o tmp\openssl.o -leay32 -lssl32 -L. -lwsock32 -lgdi32
++
+ echo Done compiling OpenSSL
+ 
+ :end
+-
+diff -wur openssl-0.9.7m.orig/util/pl/Mingw32.pl openssl-0.9.7m/util/pl/Mingw32.pl
+--- openssl-0.9.7m.orig/util/pl/Mingw32.pl	Sun May 16 23:28:32 2004
++++ openssl-0.9.7m/util/pl/Mingw32.pl	Mon Jan 21 17:52:36 2008
+@@ -99,10 +99,10 @@
+ 	$n=&bname($target);
+ 	$ret.="$target: $files $dep_libs\n";
+ 	$ret.="\t\$(LINK) ${efile}$target \$(LFLAGS) $files $libs\n";
+-	if (defined $sha1file)
+-		{
+-		$ret.="\t$openssl sha1 -hmac etaonrishdlcupfm -binary $target > $sha1file";
+-		}
++#	if (defined $sha1file)
++#		{
++#		$ret.="\t$openssl sha1 -hmac etaonrishdlcupfm -binary $target > $sha1file";
++#		}
+ 	$ret.="\n";
+ 	return($ret);
+ 	}
diff -urN openvpn-2.1_rc7/install-win32/openssl/.svn/text-base/openssl098.patch.svn-base openvpn-2.1_rc9/install-win32/openssl/.svn/text-base/openssl098.patch.svn-base
--- openvpn-2.1_rc7/install-win32/openssl/.svn/text-base/openssl098.patch.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl/.svn/text-base/openssl098.patch.svn-base	2008-07-31 22:41:13.000000000 +0200
@@ -0,0 +1,56 @@
+diff -urw tmp/openssl-0.9.8h/crypto/pqueue/pqueue.c openssl-0.9.8h/crypto/pqueue/pqueue.c
+--- tmp/openssl-0.9.8h/crypto/pqueue/pqueue.c	Tue Jun 28 06:53:34 2005
++++ openssl-0.9.8h/crypto/pqueue/pqueue.c	Wed Jun  4 02:52:42 2008
+@@ -199,10 +199,10 @@
+ 	return found;
+ 	}
+ 
+-#if PQ_64BIT_IS_INTEGER
+ void
+ pqueue_print(pqueue_s *pq)
+ 	{
++#if PQ_64BIT_IS_INTEGER
+ 	pitem *item = pq->items;
+ 
+ 	while(item != NULL)
+@@ -210,8 +210,8 @@
+ 		printf("item\t" PQ_64BIT_PRINT "\n", item->priority);
+ 		item = item->next;
+ 		}
+-	}
+ #endif
++	}
+ 
+ pitem *
+ pqueue_iterator(pqueue_s *pq)
+diff -urw tmp/openssl-0.9.8h/ms/mw.bat openssl-0.9.8h/ms/mw.bat
+--- tmp/openssl-0.9.8h/ms/mw.bat	Sat Feb 22 11:00:10 2003
++++ openssl-0.9.8h/ms/mw.bat	Wed Jun  4 02:56:54 2008
+@@ -1,17 +1,23 @@
+ @rem OpenSSL with Mingw32
+ @rem --------------------
+ 
++@rem Include MinGW, MSYS, and ActiveState Perl in path
++set PATH=c:\bin;C:\Perl\bin\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;c:\MinGW\bin;c:\msys\1.0\bin
++
+ @rem Makefile
+ perl util\mkfiles.pl >MINFO
+-perl util\mk1mf.pl Mingw32 >ms\mingw32.mak
++perl util\mk1mf.pl no-idea no-mdc2 no-rc5 Mingw32 >ms\mingw32.mak
++
+ @rem DLL definition files
+-perl util\mkdef.pl 32 libeay >ms\libeay32.def
++perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 libeay >ms\libeay32.def
+ if errorlevel 1 goto end
+-perl util\mkdef.pl 32 ssleay >ms\ssleay32.def
++perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 ssleay >ms\ssleay32.def
+ if errorlevel 1 goto end
+ 
+ @rem Build the libraries
+-make -f ms/mingw32.mak
++
++@rem JY added --win32
++make --win32 -f ms/mingw32.mak
+ if errorlevel 1 goto end
+ 
+ @rem Generate the DLLs and input libraries
diff -urN openvpn-2.1_rc7/install-win32/openssl/README.txt openvpn-2.1_rc9/install-win32/openssl/README.txt
--- openvpn-2.1_rc7/install-win32/openssl/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl/README.txt	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1,22 @@
+Rebuild OpenSSL tarball without symbolic links, so
+it can be extracted on Windows (run on Unix):
+
+  [download tarball and .asc sig]
+  gpg --verify openssl-0.9.8h.tar.gz.asc
+  tar xfz openssl-0.9.8h.tar.gz
+  rm openssl-0.9.8h.tar.gz
+  tar cfzh openssl-0.9.8h.tar.gz openssl-0.9.8h
+
+To apply patch (in MSYS shell):
+
+  cd /c/src/openssl-0.9.8h
+  patch -p1 <../21/install-win32/openssl/openssl098.patch
+
+To build OpenSSL, open a command prompt window, then:
+
+  cd \src\openssl-0.9.8h
+  ms\mw
+
+To build a new patch (optional):
+
+  diff -urw openssl-0.9.8h.orig openssl-0.9.8h | grep -v '^Only in' >openssl098.patch
diff -urN openvpn-2.1_rc7/install-win32/openssl/openssl097.patch openvpn-2.1_rc9/install-win32/openssl/openssl097.patch
--- openvpn-2.1_rc7/install-win32/openssl/openssl097.patch	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl/openssl097.patch	2008-06-13 09:54:55.000000000 +0200
@@ -0,0 +1,68 @@
+[in msys bash window]
+cd /c/src/openssl-0.9.7m
+patch -p1 <../21/install-win32/openssl.patch
+
+[open command prompt window]
+cd \src\openssl-0.9.7m
+ms\mw
+
+diff -wur openssl-0.9.7m.orig/ms/mw.bat openssl-0.9.7m/ms/mw.bat
+--- openssl-0.9.7m.orig/ms/mw.bat	Sat Feb 22 11:02:46 2003
++++ openssl-0.9.7m/ms/mw.bat	Mon Jan 21 23:12:34 2008
+@@ -1,17 +1,23 @@
+ @rem OpenSSL with Mingw32
+ @rem --------------------
+ 
++@rem Include MinGW, MSYS, and ActiveState Perl in path
++set PATH=c:\perl\bin;c:\MinGW\bin;c:\msys\1.0\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem
++
+ @rem Makefile
+ perl util\mkfiles.pl >MINFO
+-perl util\mk1mf.pl Mingw32 >ms\mingw32.mak
++perl util\mk1mf.pl no-idea no-mdc2 no-rc5 Mingw32 >ms\mingw32.mak
++
+ @rem DLL definition files
+-perl util\mkdef.pl 32 libeay >ms\libeay32.def
++perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 libeay >ms\libeay32.def
+ if errorlevel 1 goto end
+-perl util\mkdef.pl 32 ssleay >ms\ssleay32.def
++perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 ssleay >ms\ssleay32.def
+ if errorlevel 1 goto end
+ 
+ @rem Build the libraries
+-make -f ms/mingw32.mak
++
++@rem JY added --win32 flag
++make --win32 -f ms/mingw32.mak
+ if errorlevel 1 goto end
+ 
+ @rem Generate the DLLs and input libraries
+@@ -20,7 +26,9 @@
+ dllwrap --dllname libssl32.dll --output-lib out/libssl32.a --def ms/ssleay32.def out/libssl.a out/libeay32.a
+ if errorlevel 1 goto end
+ 
++@rem JY added openssl.exe linked to DLL
++gcc -o openssl  tmp\verify.o tmp\asn1pars.o tmp\req.o tmp\dgst.o tmp\dh.o tmp\dhparam.o tmp\enc.o tmp\passwd.o tmp\gendh.o tmp\errstr.o tmp\ca.o tmp\pkcs7.o tmp\crl2p7.o tmp\crl.o tmp\rsa.o tmp\rsautl.o tmp\dsa.o tmp\dsaparam.o tmp\x509.o tmp\genrsa.o tmp\gendsa.o tmp\s_server.o tmp\s_client.o tmp\speed.o tmp\s_time.o tmp\apps.o tmp\s_cb.o tmp\s_socket.o tmp\app_rand.o tmp\version.o tmp\sess_id.o tmp\ciphers.o tmp\nseq.o tmp\pkcs12.o tmp\pkcs8.o tmp\spkac.o tmp\smime.o tmp\rand.o tmp\engine.o tmp\ocsp.o tmp\prime.o tmp\openssl.o -leay32 -lssl32 -L. -lwsock32 -lgdi32
++
+ echo Done compiling OpenSSL
+ 
+ :end
+-
+diff -wur openssl-0.9.7m.orig/util/pl/Mingw32.pl openssl-0.9.7m/util/pl/Mingw32.pl
+--- openssl-0.9.7m.orig/util/pl/Mingw32.pl	Sun May 16 23:28:32 2004
++++ openssl-0.9.7m/util/pl/Mingw32.pl	Mon Jan 21 17:52:36 2008
+@@ -99,10 +99,10 @@
+ 	$n=&bname($target);
+ 	$ret.="$target: $files $dep_libs\n";
+ 	$ret.="\t\$(LINK) ${efile}$target \$(LFLAGS) $files $libs\n";
+-	if (defined $sha1file)
+-		{
+-		$ret.="\t$openssl sha1 -hmac etaonrishdlcupfm -binary $target > $sha1file";
+-		}
++#	if (defined $sha1file)
++#		{
++#		$ret.="\t$openssl sha1 -hmac etaonrishdlcupfm -binary $target > $sha1file";
++#		}
+ 	$ret.="\n";
+ 	return($ret);
+ 	}
diff -urN openvpn-2.1_rc7/install-win32/openssl/openssl098.patch openvpn-2.1_rc9/install-win32/openssl/openssl098.patch
--- openvpn-2.1_rc7/install-win32/openssl/openssl098.patch	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl/openssl098.patch	2008-07-31 22:41:13.000000000 +0200
@@ -0,0 +1,56 @@
+diff -urw tmp/openssl-0.9.8h/crypto/pqueue/pqueue.c openssl-0.9.8h/crypto/pqueue/pqueue.c
+--- tmp/openssl-0.9.8h/crypto/pqueue/pqueue.c	Tue Jun 28 06:53:34 2005
++++ openssl-0.9.8h/crypto/pqueue/pqueue.c	Wed Jun  4 02:52:42 2008
+@@ -199,10 +199,10 @@
+ 	return found;
+ 	}
+ 
+-#if PQ_64BIT_IS_INTEGER
+ void
+ pqueue_print(pqueue_s *pq)
+ 	{
++#if PQ_64BIT_IS_INTEGER
+ 	pitem *item = pq->items;
+ 
+ 	while(item != NULL)
+@@ -210,8 +210,8 @@
+ 		printf("item\t" PQ_64BIT_PRINT "\n", item->priority);
+ 		item = item->next;
+ 		}
+-	}
+ #endif
++	}
+ 
+ pitem *
+ pqueue_iterator(pqueue_s *pq)
+diff -urw tmp/openssl-0.9.8h/ms/mw.bat openssl-0.9.8h/ms/mw.bat
+--- tmp/openssl-0.9.8h/ms/mw.bat	Sat Feb 22 11:00:10 2003
++++ openssl-0.9.8h/ms/mw.bat	Wed Jun  4 02:56:54 2008
+@@ -1,17 +1,23 @@
+ @rem OpenSSL with Mingw32
+ @rem --------------------
+ 
++@rem Include MinGW, MSYS, and ActiveState Perl in path
++set PATH=c:\bin;C:\Perl\bin\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;c:\MinGW\bin;c:\msys\1.0\bin
++
+ @rem Makefile
+ perl util\mkfiles.pl >MINFO
+-perl util\mk1mf.pl Mingw32 >ms\mingw32.mak
++perl util\mk1mf.pl no-idea no-mdc2 no-rc5 Mingw32 >ms\mingw32.mak
++
+ @rem DLL definition files
+-perl util\mkdef.pl 32 libeay >ms\libeay32.def
++perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 libeay >ms\libeay32.def
+ if errorlevel 1 goto end
+-perl util\mkdef.pl 32 ssleay >ms\ssleay32.def
++perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 ssleay >ms\ssleay32.def
+ if errorlevel 1 goto end
+ 
+ @rem Build the libraries
+-make -f ms/mingw32.mak
++
++@rem JY added --win32
++make --win32 -f ms/mingw32.mak
+ if errorlevel 1 goto end
+ 
+ @rem Generate the DLLs and input libraries
diff -urN openvpn-2.1_rc7/install-win32/openssl.patch openvpn-2.1_rc9/install-win32/openssl.patch
--- openvpn-2.1_rc7/install-win32/openssl.patch	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openssl.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-[in msys bash window]
-cd /c/src/openssl-0.9.7m
-patch -p1 <../21/install-win32/openssl.patch
-
-[open command prompt window]
-cd \src\openssl-0.9.7m
-ms\mw
-
-diff -wur openssl-0.9.7m.orig/ms/mw.bat openssl-0.9.7m/ms/mw.bat
---- openssl-0.9.7m.orig/ms/mw.bat	Sat Feb 22 11:02:46 2003
-+++ openssl-0.9.7m/ms/mw.bat	Mon Jan 21 23:12:34 2008
-@@ -1,17 +1,23 @@
- @rem OpenSSL with Mingw32
- @rem --------------------
- 
-+@rem Include MinGW, MSYS, and ActiveState Perl in path
-+set PATH=c:\perl\bin;c:\MinGW\bin;c:\msys\1.0\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem
-+
- @rem Makefile
- perl util\mkfiles.pl >MINFO
--perl util\mk1mf.pl Mingw32 >ms\mingw32.mak
-+perl util\mk1mf.pl no-idea no-mdc2 no-rc5 Mingw32 >ms\mingw32.mak
-+
- @rem DLL definition files
--perl util\mkdef.pl 32 libeay >ms\libeay32.def
-+perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 libeay >ms\libeay32.def
- if errorlevel 1 goto end
--perl util\mkdef.pl 32 ssleay >ms\ssleay32.def
-+perl util\mkdef.pl no-idea no-mdc2 no-rc5 32 ssleay >ms\ssleay32.def
- if errorlevel 1 goto end
- 
- @rem Build the libraries
--make -f ms/mingw32.mak
-+
-+@rem JY added --win32 flag
-+make --win32 -f ms/mingw32.mak
- if errorlevel 1 goto end
- 
- @rem Generate the DLLs and input libraries
-@@ -20,7 +26,9 @@
- dllwrap --dllname libssl32.dll --output-lib out/libssl32.a --def ms/ssleay32.def out/libssl.a out/libeay32.a
- if errorlevel 1 goto end
- 
-+@rem JY added openssl.exe linked to DLL
-+gcc -o openssl  tmp\verify.o tmp\asn1pars.o tmp\req.o tmp\dgst.o tmp\dh.o tmp\dhparam.o tmp\enc.o tmp\passwd.o tmp\gendh.o tmp\errstr.o tmp\ca.o tmp\pkcs7.o tmp\crl2p7.o tmp\crl.o tmp\rsa.o tmp\rsautl.o tmp\dsa.o tmp\dsaparam.o tmp\x509.o tmp\genrsa.o tmp\gendsa.o tmp\s_server.o tmp\s_client.o tmp\speed.o tmp\s_time.o tmp\apps.o tmp\s_cb.o tmp\s_socket.o tmp\app_rand.o tmp\version.o tmp\sess_id.o tmp\ciphers.o tmp\nseq.o tmp\pkcs12.o tmp\pkcs8.o tmp\spkac.o tmp\smime.o tmp\rand.o tmp\engine.o tmp\ocsp.o tmp\prime.o tmp\openssl.o -leay32 -lssl32 -L. -lwsock32 -lgdi32
-+
- echo Done compiling OpenSSL
- 
- :end
--
-diff -wur openssl-0.9.7m.orig/util/pl/Mingw32.pl openssl-0.9.7m/util/pl/Mingw32.pl
---- openssl-0.9.7m.orig/util/pl/Mingw32.pl	Sun May 16 23:28:32 2004
-+++ openssl-0.9.7m/util/pl/Mingw32.pl	Mon Jan 21 17:52:36 2008
-@@ -99,10 +99,10 @@
- 	$n=&bname($target);
- 	$ret.="$target: $files $dep_libs\n";
- 	$ret.="\t\$(LINK) ${efile}$target \$(LFLAGS) $files $libs\n";
--	if (defined $sha1file)
--		{
--		$ret.="\t$openssl sha1 -hmac etaonrishdlcupfm -binary $target > $sha1file";
--		}
-+#	if (defined $sha1file)
-+#		{
-+#		$ret.="\t$openssl sha1 -hmac etaonrishdlcupfm -binary $target > $sha1file";
-+#		}
- 	$ret.="\n";
- 	return($ret);
- 	}
diff -urN openvpn-2.1_rc7/install-win32/openvpn.nsi openvpn-2.1_rc9/install-win32/openvpn.nsi
--- openvpn-2.1_rc7/install-win32/openvpn.nsi	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/openvpn.nsi	2008-07-14 20:37:55.000000000 +0200
@@ -1,5 +1,5 @@
 ; ****************************************************************************
-; * Copyright (C) 2002-2005 OpenVPN Solutions LLC                            *
+; * Copyright (C) 2002-2008 Telethra, Inc.                            *
 ; *  This program is free software; you can redistribute it and/or modify    *
 ; *  it under the terms of the GNU General Public License version 2          *
 ; *  as published by the Free Software Foundation.                           *
@@ -11,20 +11,42 @@
 
 !include "${HOME}\autodefs\defs.nsi"
 !include "${HOME}\autodefs\guidefs.nsi"
+!include "${HOME}\autodefs\xguidefs.nsi"
 !include "MUI.nsh"
 !include "setpath.nsi"
 !include "GetWindowsVersion.nsi"
 
-!define BIN "${HOME}\bin"
+; Which GUI to use (XGUI has priority).
+; We will define either USE_XGUI (XML-based version) or
+; USE_GUI (Mathias Sundman version) but not both.
+!ifdef OPENVPN_XGUI_DEFINED
+!define USE_XGUI
+!else
+!ifdef OPENVPN_GUI_DEFINED
+!define USE_GUI
+!endif
+!endif
+
+!define GEN "${HOME}\${GENOUT}"
+!define BIN "${GEN}\bin"
+!define LIB "${GEN}\lib"
 
 !define PRODUCT_ICON "icon.ico"
 
+!ifdef USE_XGUI
+!define XGUI_POSTFIX "X"
+!else
+!define XGUI_POSTFIX ""
+!endif
+
 !ifdef PRODUCT_TAP_DEBUG
-!define VERSION "${PRODUCT_VERSION}-DBG"
+!define DBG_POSTFIX "-DBG"
 !else
-!define VERSION "${PRODUCT_VERSION}"
+!define DBG_POSTFIX ""
 !endif
 
+!define VERSION "${PRODUCT_VERSION}${XGUI_POSTFIX}${DBG_POSTFIX}"
+
 !define TAP "${PRODUCT_TAP_ID}"
 !define TAPDRV "${TAP}.sys"
 
@@ -36,6 +58,15 @@
 !define SERV_PRIORITY     "NORMAL_PRIORITY_CLASS"
 !define SERV_LOG_APPEND   "0"
 
+; XGUI variables
+!define XGUI_EXE      ovpn-xgui-en.exe
+!define XGUI_TRAY     ovpn-tray.exe
+!define XGUI_XMLSERV  ovpn-xmlserv.exe
+!define XGUI_HTDOCS   htdocs
+
+!define XGUI_AJAX_GUI_NAME       "${PRODUCT_NAME} Ajax GUI"
+!define XGUI_TRANSITION_GUI_NAME "${PRODUCT_NAME} Transitional GUI"
+
 ;--------------------------------
 ;Configuration
 
@@ -64,9 +95,13 @@
   !define MUI_COMPONENTSPAGE_TEXT_TOP "Select the components to install/upgrade.  Stop any ${PRODUCT_NAME} processes or the ${PRODUCT_NAME} service if it is running.  All DLLs are installed locally."
 
   !define MUI_COMPONENTSPAGE_SMALLDESC
-  !define MUI_FINISHPAGE_SHOWREADME "$INSTDIR\INSTALL-win32.txt"
+  !ifdef USE_XGUI
+    !define MUI_FINISHPAGE_SHOWREADME "http://openvpn.net/"
+    !define MUI_FINISHPAGE_SHOWREADME_NOTCHECKED
+  !else
+    !define MUI_FINISHPAGE_SHOWREADME "$INSTDIR\INSTALL-win32.txt"
+  !endif
   !define MUI_FINISHPAGE_NOAUTOCLOSE
-#  !define MUI_FINISHPAGE_SHOWREADME_NOTCHECKED
   !define MUI_ABORTWARNING
   !define MUI_ICON "${HOME}\images\${PRODUCT_ICON}"
   !define MUI_UNICON "${HOME}\images\${PRODUCT_ICON}"
@@ -75,7 +110,7 @@
   !define MUI_UNFINISHPAGE_NOAUTOCLOSE
 
   !insertmacro MUI_PAGE_WELCOME
-  !insertmacro MUI_PAGE_LICENSE "${HOME}\install-win32\license.txt"
+  !insertmacro MUI_PAGE_LICENSE "${GEN}\text\license.txt"
   !insertmacro MUI_PAGE_COMPONENTS
   !insertmacro MUI_PAGE_DIRECTORY
   !insertmacro MUI_PAGE_INSTFILES
@@ -96,17 +131,21 @@
 
   LangString DESC_SecOpenVPNUserSpace ${LANG_ENGLISH} "Install ${PRODUCT_NAME} user-space components, including ${PRODUCT_UNIX_NAME}.exe."
 
-!ifdef OPENVPN_GUI_DEFINED
+!ifdef USE_GUI
   LangString DESC_SecOpenVPNGUI ${LANG_ENGLISH} "Install ${PRODUCT_NAME} GUI by Mathias Sundman"
 !endif
 
+!ifdef USE_XGUI
+  LangString DESC_SecOpenVPNXGUI ${LANG_ENGLISH} "Install ${PRODUCT_NAME} XML-based GUI"
+!endif
+
   LangString DESC_SecOpenVPNEasyRSA ${LANG_ENGLISH} "Install ${PRODUCT_NAME} RSA scripts for X509 certificate management."
 
   LangString DESC_SecOpenSSLDLLs ${LANG_ENGLISH} "Install OpenSSL DLLs locally (may be omitted if DLLs are already installed globally)."
 
   LangString DESC_SecPKCS11DLLs ${LANG_ENGLISH} "Install PKCS#11 helper DLLs locally (may be omitted if DLLs are already installed globally)."
 
-  LangString DESC_SecTAP ${LANG_ENGLISH} "Install/Upgrade the TAP-Win32 virtual device driver.  Will not interfere with CIPE."
+  LangString DESC_SecTAP ${LANG_ENGLISH} "Install/Upgrade the TAP virtual device driver.  Will not interfere with CIPE."
 
   LangString DESC_SecService ${LANG_ENGLISH} "Install the ${PRODUCT_NAME} service wrapper (${PRODUCT_UNIX_NAME}serv.exe)"
 
@@ -225,6 +264,26 @@
 
 !define SF_SELECTED 1
 
+;--------------------
+;Pre-install section
+
+Section -pre
+
+  ; Stop OpenVPN if currently running
+  DetailPrint "Previous Service REMOVE (if exists)"
+  nsExec::ExecToLog '"$INSTDIR\bin\${PRODUCT_UNIX_NAME}serv.exe" -remove'
+  Pop $R0 # return value/error/timeout
+
+!ifdef USE_XGUI
+  DetailPrint "Previous XML Service REMOVE (if exists)"
+  nsExec::ExecToLog '"$INSTDIR\bin\${XGUI_XMLSERV}" -remove'
+  Pop $R0 # return value/error/timeout
+!endif
+
+  Sleep 3000
+
+SectionEnd
+
 Section "${PRODUCT_NAME} User-Space Components" SecOpenVPNUserSpace
 
   SetOverwrite on
@@ -234,7 +293,7 @@
 
 SectionEnd
 
-!ifdef OPENVPN_GUI_DEFINED
+!ifdef USE_GUI
 Section "${PRODUCT_NAME} GUI" SecOpenVPNGUI
 
   SetOverwrite on
@@ -245,12 +304,28 @@
 SectionEnd
 !endif
 
+!ifdef USE_XGUI
+Section "${PRODUCT_NAME} XML-based GUI" SecOpenVPNXGUI
+
+  SetOverwrite on
+
+  SetOutPath "$INSTDIR\bin"
+  File "${BIN}\${XGUI_EXE}"
+  File "${BIN}\${XGUI_TRAY}"
+  File "${BIN}\${XGUI_XMLSERV}"
+
+  SetOutPath "$INSTDIR\${XGUI_HTDOCS}"
+  File "${GEN}\${XGUI_HTDOCS}\*.*"
+
+SectionEnd
+!endif
+
 Section "${PRODUCT_NAME} RSA Certificate Management Scripts" SecOpenVPNEasyRSA
 
   SetOverwrite on
   SetOutPath "$INSTDIR\easy-rsa"
 
-  File "${HOME}\samples\openssl.cnf.sample"
+  File "${GEN}\samples\openssl.cnf.sample"
   File "${HOME}\easy-rsa\Windows\vars.bat.sample"
 
   File "${HOME}\easy-rsa\Windows\init-config.bat"
@@ -286,9 +361,9 @@
   FileClose $R0
 
   SetOutPath "$INSTDIR\sample-config"
-  File "${HOME}\samples\sample.${SERV_CONFIG_EXT}"
-  File "${HOME}\samples\client.${SERV_CONFIG_EXT}"
-  File "${HOME}\samples\server.${SERV_CONFIG_EXT}"
+  File "${GEN}\samples\sample.${SERV_CONFIG_EXT}"
+  File "${GEN}\samples\client.${SERV_CONFIG_EXT}"
+  File "${GEN}\samples\server.${SERV_CONFIG_EXT}"
 
   CreateDirectory "$INSTDIR\log"
   FileOpen $R0 "$INSTDIR\log\README.txt" w
@@ -305,8 +380,8 @@
 
   SetOverwrite on
   SetOutPath "$INSTDIR\bin"
-  File "${BIN}\libeay32.dll"
-  File "${BIN}\libssl32.dll"
+  File "${LIB}\libeay32.dll"
+  File "${LIB}\libssl32.dll"
 
 SectionEnd
 
@@ -322,22 +397,22 @@
 
   SetOverwrite on
   SetOutPath "$INSTDIR\bin"
-  File "${BIN}\libpkcs11-helper-1.dll"
+  File "${LIB}\libpkcs11-helper-1.dll"
 
 SectionEnd
 
-Section "TAP-Win32 Virtual Ethernet Adapter" SecTAP
+Section "TAP Virtual Ethernet Adapter" SecTAP
 
   SetOverwrite on
 
   FileOpen $R0 "$INSTDIR\bin\addtap.bat" w
-  FileWrite $R0 "rem Add a new TAP-Win32 virtual ethernet adapter$\r$\n"
+  FileWrite $R0 "rem Add a new TAP virtual ethernet adapter$\r$\n"
   FileWrite $R0 '"$INSTDIR\bin\tapinstall.exe" install "$INSTDIR\driver\OemWin2k.inf" ${TAP}$\r$\n'
   FileWrite $R0 "pause$\r$\n"
   FileClose $R0
 
   FileOpen $R0 "$INSTDIR\bin\deltapall.bat" w
-  FileWrite $R0 "echo WARNING: this script will delete ALL TAP-Win32 virtual adapters (use the device manager to delete adapters one at a time)$\r$\n"
+  FileWrite $R0 "echo WARNING: this script will delete ALL TAP virtual adapters (use the device manager to delete adapters one at a time)$\r$\n"
   FileWrite $R0 "pause$\r$\n"
   FileWrite $R0 '"$INSTDIR\bin\tapinstall.exe" remove ${TAP}$\r$\n'
   FileWrite $R0 "pause$\r$\n"
@@ -354,13 +429,13 @@
 
   SetOutPath "$INSTDIR\bin"
 
-  File "${BIN}\tapinstall\amd64\tapinstall.exe"
+  File "${GEN}\tapinstall\amd64\tapinstall.exe"
 
   SetOutPath "$INSTDIR\driver"
 
-  File "${BIN}\driver\amd64\OemWin2k.inf"
-  File "${BIN}\driver\amd64\${PRODUCT_TAP_ID}.cat"
-  File "${BIN}\driver\amd64\${TAPDRV}"
+  File "${GEN}\driver\amd64\OemWin2k.inf"
+  File "${GEN}\driver\amd64\${PRODUCT_TAP_ID}.cat"
+  File "${GEN}\driver\amd64\${TAPDRV}"
 
 goto tapend
 
@@ -369,12 +444,12 @@
   DetailPrint "We are running on a 32-bit system."
 
   SetOutPath "$INSTDIR\bin"
-  File "${BIN}\tapinstall\i386\tapinstall.exe"
+  File "${GEN}\tapinstall\i386\tapinstall.exe"
 
   SetOutPath "$INSTDIR\driver"
-  File "${BIN}\driver\i386\OemWin2k.inf"
-  File "${BIN}\driver\i386\${PRODUCT_TAP_ID}.cat"
-  File "${BIN}\driver\i386\${TAPDRV}"
+  File "${GEN}\driver\i386\OemWin2k.inf"
+  File "${GEN}\driver\i386\${PRODUCT_TAP_ID}.cat"
+  File "${GEN}\driver\i386\${TAPDRV}"
 
   tapend:
 
@@ -410,11 +485,37 @@
 
 Section -post
 
+  SetOverwrite on
+
   ; delete old devcon.exe
   Delete "$INSTDIR\bin\devcon.exe"
 
+  ; Store README, license, icon
+  SetOverwrite on
+  SetOutPath $INSTDIR
+  !ifndef USE_XGUI
+    File "${GEN}\text\INSTALL-win32.txt"
+  !endif
+  File "${GEN}\text\license.txt"
+  File "${HOME}\images\${PRODUCT_ICON}"
+
+  ; store sample config files
+  !ifdef SAMPCONF_DIR
+    SetOverwrite on
+    SetOutPath "$INSTDIR\config"
+  !ifdef SAMPCONF_CONF
+    File "${HOME}\..\${SAMPCONF_DIR}\${SAMPCONF_CONF}"
+  !endif
+  !ifdef SAMPCONF_P12
+    File "${HOME}\..\${SAMPCONF_DIR}\${SAMPCONF_P12}"
+  !endif
+  !ifdef SAMPCONF_TA
+    File "${HOME}\..\${SAMPCONF_DIR}\${SAMPCONF_TA}"
+  !endif
+  !endif
+
   ;
-  ; install/upgrade TAP-Win32 driver if selected, using tapinstall.exe
+  ; install/upgrade TAP driver if selected, using tapinstall.exe
   ;
   SectionGetFlags ${SecTAP} $R0
   IntOp $R0 $R0 & ${SF_SELECTED}
@@ -440,7 +541,7 @@
     IntCmp $R0 -1 tapinstall
 
  ;tapupdate:
-    DetailPrint "TAP-Win32 UPDATE"
+    DetailPrint "TAP UPDATE"
     nsExec::ExecToLog '"$INSTDIR\bin\tapinstall.exe" update "$INSTDIR\driver\OemWin2k.inf" ${TAP}'
     Pop $R0 # return value/error/timeout
     Call CheckReboot
@@ -449,13 +550,13 @@
     Goto tapinstall_check_error
 
  tapinstall:
-    DetailPrint "TAP-Win32 REMOVE OLD TAP"
+    DetailPrint "TAP REMOVE OLD TAP"
 
     nsExec::ExecToLog '"$INSTDIR\bin\tapinstall.exe" remove TAP0801'
     Pop $R0 # return value/error/timeout
     DetailPrint "tapinstall remove TAP0801 returned: $R0"
 
-    DetailPrint "TAP-Win32 INSTALL (${TAP})"
+    DetailPrint "TAP INSTALL (${TAP})"
     nsExec::ExecToLog '"$INSTDIR\bin\tapinstall.exe" install "$INSTDIR\driver\OemWin2k.inf" ${TAP}'
     Pop $R0 # return value/error/timeout
     Call CheckReboot
@@ -465,7 +566,7 @@
  tapinstall_check_error:
     DetailPrint "tapinstall cumulative status: $5"
     IntCmp $5 0 notap
-    MessageBox MB_OK "An error occurred installing the TAP-Win32 device driver."
+    MessageBox MB_OK "An error occurred installing the TAP device driver."
 
  notap:
 
@@ -485,38 +586,29 @@
     !insertmacro WriteRegStringIfUndef HKLM "SOFTWARE\${PRODUCT_NAME}" "priority"    "${SERV_PRIORITY}"
     !insertmacro WriteRegStringIfUndef HKLM "SOFTWARE\${PRODUCT_NAME}" "log_append"  "${SERV_LOG_APPEND}"
 
-    ; install openvpnserv as a service
-    DetailPrint "Previous Service REMOVE (if exists)"
-    nsExec::ExecToLog '"$INSTDIR\bin\${PRODUCT_UNIX_NAME}serv.exe" -remove'
-    Pop $R0 # return value/error/timeout
+    ; install openvpnserv as a service (to be started manually from service control manager)
     DetailPrint "Service INSTALL"
     nsExec::ExecToLog '"$INSTDIR\bin\${PRODUCT_UNIX_NAME}serv.exe" -install'
     Pop $R0 # return value/error/timeout
 
  noserv:
-  ; Store README, license, icon
-  SetOverwrite on
-  SetOutPath $INSTDIR
-  File "${HOME}\install-win32\INSTALL-win32.txt"
-  File "${HOME}\install-win32\license.txt"
-  File "${HOME}\images\${PRODUCT_ICON}"
+  !ifdef USE_XGUI
+    IfFileExists "$INSTDIR\bin\${XGUI_XMLSERV}" "" fileass
+      ; install and automatically start XML service
+      DetailPrint "XML Service INSTALL"
+      nsExec::ExecToLog '"$INSTDIR\bin\${XGUI_XMLSERV}" -install'
+      Pop $R0 # return value/error/timeout
+
+      Sleep 2000
+
+      DetailPrint "XML Service START"
+      nsExec::ExecToLog '"$INSTDIR\bin\${XGUI_XMLSERV}" -start'
+      Pop $R0 # return value/error/timeout
 
-  ; store sample config files
-  !ifdef SAMPCONF_DIR
-    SetOverwrite on
-    SetOutPath "$INSTDIR\config"
-  !ifdef SAMPCONF_CONF
-    File "${HOME}\..\${SAMPCONF_DIR}\${SAMPCONF_CONF}"
-  !endif
-  !ifdef SAMPCONF_P12
-    File "${HOME}\..\${SAMPCONF_DIR}\${SAMPCONF_P12}"
-  !endif
-  !ifdef SAMPCONF_TA
-    File "${HOME}\..\${SAMPCONF_DIR}\${SAMPCONF_TA}"
-  !endif
   !endif
 
   ; Create file association if requested
+ fileass:
   SectionGetFlags ${SecFileAssociation} $R0
   IntOp $R0 $R0 & ${SF_SELECTED}
   IntCmp $R0 ${SF_SELECTED} "" noass noass
@@ -533,21 +625,33 @@
   CreateDirectory "$SMPROGRAMS\${PRODUCT_NAME}\Utilities"
   CreateDirectory "$SMPROGRAMS\${PRODUCT_NAME}\Shortcuts"
 
-    ; Create start menu and desktop shortcuts to OpenVPN GUI
-  !ifdef OPENVPN_GUI_DEFINED
-    IfFileExists "$INSTDIR\bin\${OPENVPN_GUI}" "" tryaddtap
+  ; Create start menu and desktop shortcuts to OpenVPN GUI
+  !ifdef USE_GUI
+    IfFileExists "$INSTDIR\bin\${OPENVPN_GUI}" "" tryaddxgui
       CreateShortCut "$SMPROGRAMS\${PRODUCT_NAME}\${PRODUCT_NAME} GUI.lnk" "$INSTDIR\bin\${OPENVPN_GUI}" ""
       CreateShortcut "$DESKTOP\${PRODUCT_NAME} GUI.lnk" "$INSTDIR\bin\${OPENVPN_GUI}"
   !endif
 
+  ; Create start menu and desktop shortcuts to OpenVPN XGUI
+ tryaddxgui:
+  !ifdef USE_XGUI
+    IfFileExists "$INSTDIR\bin\${XGUI_EXE}" "" tryaddtray
+      CreateShortCut "$SMPROGRAMS\${PRODUCT_NAME}\${XGUI_TRANSITION_GUI_NAME}.lnk" "$INSTDIR\bin\${XGUI_EXE}" ""
+#      CreateShortcut "$DESKTOP\${XGUI_TRANSITION_GUI_NAME}.lnk" "$INSTDIR\bin\${XGUI_EXE}"
+ tryaddtray:
+    IfFileExists "$INSTDIR\bin\${XGUI_TRAY}" "" tryaddtap
+      CreateShortCut "$SMPROGRAMS\${PRODUCT_NAME}\${XGUI_AJAX_GUI_NAME}.lnk" "$INSTDIR\bin\${XGUI_EXE}" ""
+      CreateShortcut "$DESKTOP\${XGUI_AJAX_GUI_NAME}.lnk" "$INSTDIR\bin\${XGUI_TRAY}"
+  !endif
+
     ; Create start menu shortcuts to addtap.bat and deltapall.bat
  tryaddtap:
     IfFileExists "$INSTDIR\bin\addtap.bat" "" trydeltap
-      CreateShortCut "$SMPROGRAMS\${PRODUCT_NAME}\Utilities\Add a new TAP-Win32 virtual ethernet adapter.lnk" "$INSTDIR\bin\addtap.bat" ""
+      CreateShortCut "$SMPROGRAMS\${PRODUCT_NAME}\Utilities\Add a new TAP virtual ethernet adapter.lnk" "$INSTDIR\bin\addtap.bat" ""
 
  trydeltap:
     IfFileExists "$INSTDIR\bin\deltapall.bat" "" config_shortcut
-      CreateShortCut "$SMPROGRAMS\${PRODUCT_NAME}\Utilities\Delete ALL TAP-Win32 virtual ethernet adapters.lnk" "$INSTDIR\bin\deltapall.bat" ""
+      CreateShortCut "$SMPROGRAMS\${PRODUCT_NAME}\Utilities\Delete ALL TAP virtual ethernet adapters.lnk" "$INSTDIR\bin\deltapall.bat" ""
 
     ; Create start menu shortcuts for config and log directories
  config_shortcut:
@@ -578,7 +682,7 @@
   WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${PRODUCT_NAME}" "DisplayVersion" "${VERSION}"
 
   ; Advise a reboot
-  ;Messagebox MB_OK "IMPORTANT: Rebooting the system is advised in order to finalize TAP-Win32 driver installation/upgrade (this is an informational message only, pressing OK will not reboot)."
+  ;Messagebox MB_OK "IMPORTANT: Rebooting the system is advised in order to finalize TAP driver installation/upgrade (this is an informational message only, pressing OK will not reboot)."
 
 SectionEnd
 
@@ -587,9 +691,12 @@
 
 !insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN
   !insertmacro MUI_DESCRIPTION_TEXT ${SecOpenVPNUserSpace} $(DESC_SecOpenVPNUserSpace)
-  !ifdef OPENVPN_GUI_DEFINED
+  !ifdef USE_GUI
     !insertmacro MUI_DESCRIPTION_TEXT ${SecOpenVPNGUI} $(DESC_SecOpenVPNGUI)
   !endif
+  !ifdef USE_XGUI
+    !insertmacro MUI_DESCRIPTION_TEXT ${SecOpenVPNXGUI} $(DESC_SecOpenVPNXGUI)
+  !endif
   !insertmacro MUI_DESCRIPTION_TEXT ${SecOpenVPNEasyRSA} $(DESC_SecOpenVPNEasyRSA)
   !insertmacro MUI_DESCRIPTION_TEXT ${SecTAP} $(DESC_SecTAP)
   !insertmacro MUI_DESCRIPTION_TEXT ${SecOpenSSLUtilities} $(DESC_SecOpenSSLUtilities)
@@ -619,13 +726,20 @@
 
 Section "Uninstall"
 
+!ifdef USE_XGUI
+  DetailPrint "XML Service REMOVE"
+  nsExec::ExecToLog '"$INSTDIR\bin\${XGUI_XMLSERV}" -remove'
+  Pop $R0 # return value/error/timeout
+!endif
+
+  ; Stop OpenVPN if currently running
   DetailPrint "Service REMOVE"
   nsExec::ExecToLog '"$INSTDIR\bin\${PRODUCT_UNIX_NAME}serv.exe" -remove'
   Pop $R0 # return value/error/timeout
 
-  Sleep 2000
+  Sleep 3000
 
-  DetailPrint "TAP-Win32 REMOVE"
+  DetailPrint "TAP REMOVE"
   nsExec::ExecToLog '"$INSTDIR\bin\tapinstall.exe" remove ${TAP}'
   Pop $R0 # return value/error/timeout
   DetailPrint "tapinstall remove returned: $R0"
@@ -648,11 +762,20 @@
   !endif
   !endif
 
-  !ifdef OPENVPN_GUI_DEFINED
+  !ifdef USE_GUI
     Delete "$INSTDIR\bin\${OPENVPN_GUI}"
     Delete "$DESKTOP\${PRODUCT_NAME} GUI.lnk"
   !endif
 
+  !ifdef USE_XGUI
+    Delete "$INSTDIR\bin\${XGUI_EXE}"
+    Delete "$INSTDIR\bin\${XGUI_TRAY}"
+    Delete "$INSTDIR\bin\${XGUI_XMLSERV}"
+    RMDir /r "$INSTDIR\${XGUI_HTDOCS}"
+    Delete "$DESKTOP\${XGUI_AJAX_GUI_NAME}.lnk"
+    Delete "$DESKTOP\${XGUI_TRANSITION_GUI_NAME}.lnk"
+  !endif
+
   Delete "$INSTDIR\bin\${PRODUCT_UNIX_NAME}.exe"
   Delete "$INSTDIR\bin\${PRODUCT_UNIX_NAME}serv.exe"
   Delete "$INSTDIR\bin\libeay32.dll"
diff -urN openvpn-2.1_rc7/install-win32/settings.in openvpn-2.1_rc9/install-win32/settings.in
--- openvpn-2.1_rc7/install-win32/settings.in	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/settings.in	2008-06-13 09:54:55.000000000 +0200
@@ -17,30 +17,29 @@
 !define OPENVPN_GUI_DIR "../openvpn-gui"
 !define OPENVPN_GUI     "openvpn-gui-1.0.3.exe"
 
+# Include the OpenVPN XML-based GUI exe in the installer.
+# May be undefined.
+;!define OPENVPN_XGUI_DIR "../ovpnxml"
+
 # Prebuilt libraries.  DMALLOC is optional.
-!define OPENSSL_DIR	  "../openssl-0.9.7m"
+!define OPENSSL_DIR	  "../openssl-0.9.8h"
 !define LZO_DIR		  "../lzo-2.02"
-!define PKCS11_HELPER_DIR "../pkcs11-helper/usr/local"
+!define PKCS11_HELPER_DIR "../pkcs11-helper"
 !define DMALLOC_DIR	  "../dmalloc-5.4.2"
 
-# Write TAP driver and tapinstall.exe to this directory,
-# to use as prebuilt binaries for future builds.  May
-# be undefined.
-;!define DRVBINDEST "../tapbin"
-
-# Don't build TAP driver and tapinstall.exe -- instead get
-# them as prebuilt binaries from this directory.  May be
-# undefined.
-;!define DRVBINSRC  "../tapbin"
+# Optional directory of prebuilt OpenVPN binary components,
+# to be used as a source when build-from-scratch prerequisites
+# are not met.
+!define GENOUT_PREBUILT  "../gen-prebuilt"
 
 # tapinstall.exe source code.
 # Not needed if DRVBINSRC is defined.
 !define TISRC	"../tapinstall"
 
-# TAP Adapter parameters.
+# TAP Adapter parameters.  Note that PRODUCT_TAP_ID is
+# defined in version.m4.
 !define PRODUCT_TAP_DEVICE_DESCRIPTION  "TAP-Win32 Adapter V9"
 !define PRODUCT_TAP_PROVIDER            "TAP-Win32 Provider V9"
-!define PRODUCT_TAP_ID		        "tap0901"
 !define PRODUCT_TAP_MAJOR_VER           9
 !define PRODUCT_TAP_MINOR_VER           4
 !define PRODUCT_TAP_RELDATE             "01/22/2008"
@@ -48,16 +47,9 @@
 ; visible=0x81  hidden=0x89
 !define PRODUCT_TAP_CHARACTERISTICS     0x81
 
-# hide tap warning
-;!define PRODUCT_TAP_HIDE_WARN
-
 # Build debugging version of TAP driver
 ;!define PRODUCT_TAP_DEBUG
 
-# Service template files service.[ch] (get from Platform SDK).
-# If undefined, don't build openvpnserv.exe
-!define SVC_TEMPLATE "../svc-template"
-
 # DDK Version.
 # DDK distribution is assumed to be in C:\WINDDK\${DDKVER}
 !define DDKVER	     6001.17121
@@ -71,8 +63,16 @@
 # -j parameter passed to make
 !define MAKE_JOBS 2
 
-# do a make clean before make
-!define MAKE_CLEAN "yes"
+# output directory for built binaries
+# and other generated files
+!define GENOUT "gen"
+
+# delete GENOUT directory before starting
+# set to "yes" or "no"
+!define CLEAN "yes"
+
+# Don't strip executables and DLLs
+;!define NO_STRIP
 
 ; DEBUGGING -- set to something like "-DBG2"
 !define OUTFILE_LABEL ""
@@ -82,6 +82,6 @@
 
 # include a sample configuration file and key
 ;!define SAMPCONF_DIR   "test-key"
-;!define SAMPCONF_CONF  "test.ovpn"
-;!define SAMPCONF_P12   "test.p12"
-;!define SAMPCONF_TA    "ta.key"
+!define SAMPCONF_CONF  "test.ovpn"
+!define SAMPCONF_P12   "test.p12"
+!define SAMPCONF_TA    "ta.key"
diff -urN openvpn-2.1_rc7/install-win32/signinstaller openvpn-2.1_rc9/install-win32/signinstaller
--- openvpn-2.1_rc7/install-win32/signinstaller	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/signinstaller	1970-01-01 01:00:00.000000000 +0100
@@ -1,16 +0,0 @@
-#!/bin/sh
-
-# Sign the installer.
-
-c=`pwd`
-
-# load version.nsi definitions
-. autodefs/defs.sh
-
-if [ -d "$SIGNTOOL" ]; then
-    cd install-win32
-    ls *.exe 2>/dev/null || exit 1
-    export TARGET_EXE=$(pwd)/$(ls -t *.exe | head -n 1)
-    cd $c
-    $SIGNTOOL/signexe
-fi
diff -urN openvpn-2.1_rc7/install-win32/signtap openvpn-2.1_rc9/install-win32/signtap
--- openvpn-2.1_rc7/install-win32/signtap	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/signtap	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-#!/bin/sh
-
-# Sign the TAP driver.
-
-# load version.nsi definitions
-. autodefs/defs.sh
-
-if [ -d "$SIGNTOOL" ]; then
-    $SIGNTOOL/signtap
-fi
diff -urN openvpn-2.1_rc7/install-win32/winconfig openvpn-2.1_rc9/install-win32/winconfig
--- openvpn-2.1_rc7/install-win32/winconfig	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/install-win32/winconfig	2008-06-13 09:54:55.000000000 +0200
@@ -3,54 +3,13 @@
 # prepare files for building on Windows
 # run from top directory: install-win32/winconfig
 
-c=`pwd`
-
 rm -rf autodefs
 mkdir autodefs
 
-MACRO="perl install-win32/macro.pl autodefs/defs.in"
-IFDEF="perl install-win32/ifdef.pl"
-
-# silly vista security theatre
-PATCH="/tmp/p.exe"
-cp `which patch` $PATCH
-
 # build multi-grammar definition files
 perl install-win32/m4todef.pl <version.m4 >autodefs/version.in
 for g in "h" "sh" "nsi" "in" ; do
     perl install-win32/trans.pl $g install-win32/settings.in >autodefs/defs.$g
 done
 
-# load sh definitions
-. autodefs/defs.sh
-
-# configure tap driver sources
-rm -rf tap-win32/amd64
-mkdir tap-win32/amd64
-$MACRO <tap-win32/SOURCES.in >tap-win32/SOURCES
-$MACRO <tap-win32/i386/OemWin2k.inf.in | $IFDEF >tap-win32/i386/OemWin2k.inf
-$MACRO <tap-win32/i386/OemWin2k.inf.in | $IFDEF -DAMD64 >tap-win32/amd64/OemWin2k.inf
-
-# configure service
-if [ -n "$SVC_TEMPLATE" ] ; then
-    cd $c
-    cp $SVC_TEMPLATE/service.[ch] service-win32
-    cd service-win32
-    cp service.c service.c.orig
-    cp service.h service.h.orig
-    $PATCH <service.patch
-fi
-
-# build license file
-cd $c
-cat COPYING COPYRIGHT.GPL >install-win32/license.txt
-
-# copy sample configuration files and docs
-s=samples
-rm -rf $s
-mkdir $s
-cp sample-config-files/client.conf $s/client.$PRODUCT_FILE_EXT
-cp sample-config-files/server.conf $s/server.$PRODUCT_FILE_EXT
-cp install-win32/sample.ovpn $s/sample.$PRODUCT_FILE_EXT
-cp easy-rsa/1.0/openssl.cnf $s/openssl.cnf.sample
-cp INSTALL-win32.txt install-win32
+cat /dev/null >autodefs/guidefs.nsi
diff -urN openvpn-2.1_rc7/integer.h openvpn-2.1_rc9/integer.h
--- openvpn-2.1_rc7/integer.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/integer.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/interval.c openvpn-2.1_rc9/interval.c
--- openvpn-2.1_rc7/interval.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/interval.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "interval.h"
diff -urN openvpn-2.1_rc7/interval.h openvpn-2.1_rc9/interval.h
--- openvpn-2.1_rc7/interval.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/interval.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/list.c openvpn-2.1_rc9/list.c
--- openvpn-2.1_rc7/list.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/list.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if P2MP_SERVER
@@ -39,6 +33,7 @@
 
 struct hash *
 hash_init (const int n_buckets,
+	   const uint32_t iv,
 	   uint32_t (*hash_function)(const void *key, uint32_t iv),
 	   bool (*compare_function)(const void *key1, const void *key2))
 {
@@ -51,7 +46,7 @@
   h->mask = h->n_buckets - 1;
   h->hash_function = hash_function;
   h->compare_function = compare_function;
-  h->iv = get_random ();
+  h->iv = iv;
   ALLOC_ARRAY (h->buckets, struct hash_bucket, h->n_buckets);
   for (i = 0; i < h->n_buckets; ++i)
     {
@@ -404,8 +399,8 @@
 
   {
     struct gc_arena gc = gc_new ();
-    struct hash *hash = hash_init (10000, word_hash_function, word_compare_function);
-    struct hash *nhash = hash_init (256, word_hash_function, word_compare_function);
+    struct hash *hash = hash_init (10000, get_random (), word_hash_function, word_compare_function);
+    struct hash *nhash = hash_init (256, get_random (), word_hash_function, word_compare_function);
 
     printf ("hash_init n_buckets=%d mask=0x%08x\n", hash->n_buckets, hash->mask);
   
diff -urN openvpn-2.1_rc7/list.h openvpn-2.1_rc9/list.h
--- openvpn-2.1_rc7/list.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/list.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -57,7 +57,7 @@
 struct hash_bucket
 {
   MUTEX_DEFINE (mutex);
-  struct hash_element * volatile list;
+  struct hash_element *list;
 };
 
 struct hash
@@ -72,6 +72,7 @@
 };
 
 struct hash *hash_init (const int n_buckets,
+			const uint32_t iv,
 			uint32_t (*hash_function)(const void *key, uint32_t iv),
 			bool (*compare_function)(const void *key1, const void *key2));
 
diff -urN openvpn-2.1_rc7/lladdr.c openvpn-2.1_rc9/lladdr.c
--- openvpn-2.1_rc7/lladdr.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/lladdr.c	2008-07-26 08:18:08.000000000 +0200
@@ -2,12 +2,6 @@
  * Support routine for configuring link layer address 
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 #include "error.h"
 #include "misc.h"
@@ -15,7 +9,7 @@
 int set_lladdr(const char *ifname, const char *lladdr,
 		const struct env_set *es)
 {
-  char cmd[256];
+  struct argv argv = argv_new ();
   int r;
 
   if (!ifname || !lladdr)
@@ -23,37 +17,45 @@
   
 #if defined(TARGET_LINUX)
 #ifdef CONFIG_FEATURE_IPROUTE
-  openvpn_snprintf (cmd, sizeof (cmd),
+  argv_printf (&argv,
 		    "%s link set addr %s dev %s",
 		    iproute_path, lladdr, ifname);
 #else
-  openvpn_snprintf (cmd, sizeof (cmd),
-		    IFCONFIG_PATH " %s hw ether %s",
+  argv_printf (&argv,
+		    "%s %s hw ether %s",
+		    IFCONFIG_PATH,
 		    ifname, lladdr);
 #endif
 #elif defined(TARGET_SOLARIS)
-  openvpn_snprintf (cmd, sizeof (cmd),
-		    IFCONFIG_PATH " %s ether %s",
+  argv_printf (&argv,
+		    "%s %s ether %s",
+		    IFCONFIG_PATH,
 		    ifname, lladdr);
 #elif defined(TARGET_OPENBSD)
-  openvpn_snprintf (cmd, sizeof (cmd),
-		    IFCONFIG_PATH " %s lladdr %s",
+  argv_printf (&argv,
+		    "%s %s lladdr %s",
+		    IFCONFIG_PATH,
 		    ifname, lladdr);
 #elif defined(TARGET_DARWIN)
-  openvpn_snprintf (cmd, sizeof (cmd),
-		    IFCONFIG_PATH " %s lladdr %s",
+  argv_printf (&argv,
+		    "%s %s lladdr %s",
+		    IFCONFIG_PATH,
 		    ifname, lladdr);
 #elif defined(TARGET_FREEBSD)
-  openvpn_snprintf (cmd, sizeof (cmd),
-		    IFCONFIG_PATH " %s ether %s",
+  argv_printf (&argv,
+		    "%s %s ether %s",
+		    IFCONFIG_PATH,
 		    ifname, lladdr);
 #else
       msg (M_WARN, "Sorry, but I don't know how to configure link layer addresses on this operating system.");
       return -1;
 #endif
 
-  r = system_check (cmd, es, M_WARN, "ERROR: Unable to set link layer address.");
+  argv_msg (M_INFO, &argv);
+  r = openvpn_execve_check (&argv, es, M_WARN, "ERROR: Unable to set link layer address.");
   if (r)
     msg (M_INFO, "TUN/TAP link layer address set to %s", lladdr);
+
+  argv_reset (&argv);
   return r;
 }
diff -urN openvpn-2.1_rc7/lzo.c openvpn-2.1_rc9/lzo.c
--- openvpn-2.1_rc7/lzo.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/lzo.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,16 +22,10 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
+#include "syshead.h"
 
 #ifdef USE_LZO
 
-#include "syshead.h"
-
 #include "lzo.h"
 #include "error.h"
 #include "otime.h"
diff -urN openvpn-2.1_rc7/lzo.h openvpn-2.1_rc9/lzo.h
--- openvpn-2.1_rc7/lzo.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/lzo.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/makefile.w32 openvpn-2.1_rc9/makefile.w32
--- openvpn-2.1_rc7/makefile.w32	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/makefile.w32	1970-01-01 01:00:00.000000000 +0100
@@ -1,204 +0,0 @@
-# This Makefile builds the user-mode component
-# of OpenVPN for WIN32 in the MinGW environment.
-#
-# Build Dependencies:
-#	mingw		(GNU C compiler for windows)
-#	msys		(GNU utilities and shell for windows)
-#	OpenSSL		(SSL/TLS/crypto library)
-#	LZO		(real-time compression library)
-#       Dmalloc         (debugging only)
-#
-# Targets:
-#	static -- link statically with OpenSSL
-#       dynamic -- link dynamically with OpenSSL
-#       dmalloc -- enable memory debugging using the dmalloc library 
-#
-# Note that LZO is always linked statically.
-#
-# To build openssl-0.9.7d, remember to edit ms\mw.bat
-# adding '--win32' flag to make command:
-#
-#   make --win32 -f ms/mingw32.mak
-#
-# Now cd to top level openssl directory in a Windows
-# command-prompt window, and type:
-#
-#   ms\mw
-#
-# See additional .bat scripts in install-win32 for OpenSSL
-# build setup.
-#
-# If you are building with dmalloc debugging support
-# see windbg.h for additional dmalloc notes.
-
-#########################################################
-# Change these to point to your OpenSSL, LZO, and
-# (optionally) dmalloc top-level directories.
-# Normally set as environmental variables before calling
-# make.
-#
-#OPENSSL_DIR = 
-#LZO_DIR = 
-#DMALLOC_DIR = 
-#PKCS11_HELPER_DIR =
-
-#########################################################
-
-CC = gcc -g -O2 -Wall -Wno-unused-function -Wno-unused-variable -mno-cygwin
-
-CC_DMALLOC = gcc -g -O2 -Wall -Wno-unused-function -Wno-unused-variable -mno-cygwin -fno-inline -DDMALLOC
-
-INCLUDE_DIRS = -I${OPENSSL_DIR}/include -I${LZO_DIR}/include -I${PKCS11_HELPER_DIR}/include
-
-INCLUDE_DIRS_DMALLOC = ${INCLUDE_DIRS} -I${DMALLOC_DIR}
-
-LIBS = -llzo2 -lcrypt32 -lWinInet -lws2_32 -lgdi32 -liphlpapi -lwinmm -lpkcs11-helper
-
-LIBS_DMALLOC = ${LIBS} -ldmalloc
-
-LIB_DIRS = -L${OPENSSL_DIR}/out -L${LZO_DIR} -L${PKCS11_HELPER_DIR}/lib
-
-LIB_DIRS_DMALLOC = ${LIB_DIRS} -L${DMALLOC_DIR}
-
-EXE = ${PRODUCT_UNIX_NAME}.exe
-
-HEADERS = \
-	base64.h \
-	basic.h \
-	buffer.h \
-	circ_list.h \
-	common.h \
-	tap-win32/common.h \
-        config-win32.h \
-	crypto.h \
-	cryptoapi.h \
-	errlevel.h \
-	error.h \
-	event.h \
-        fdmisc.h \
-	forward-inline.h \
-	forward.h \
-	fragment.h \
-        gremlin.h \
-	helper.h \
-	init.h \
-	integer.h \
-	interval.h \
-	list.h \
-	lladdr.h \
-	lzo.h \
-	manage.h \
-	mbuf.h \
-	memdbg.h \
-	misc.h \
-	mroute.h \
-	mss.h \
-	mtcp.h \
-	mtu.h \
-	mudp.h \
-	multi.h \
-	ntlm.h \
-	occ-inline.h \
-	occ.h \
-	pkcs11.h \
-        openvpn.h \
-	openvpn-plugin.h \
-	options.h \
-	otime.h \
-	packet_id.h \
-	perf.h \
-	ping-inline.h \
-	ping.h \
-	plugin.h \
-	pool.h \
-        proto.h \
-	proxy.h \
-	push.h \
-	reliable.h \
-	route.h \
-	schedule.h \
-	session_id.h \
-        shaper.h \
-	sig.h \
-	socket.h \
-	socks.h \
-	ssl.h \
-        status.h \
-	syshead.h \
-        thread.h \
-	tun.h \
-	win32.h
-
-OBJS =  base64.o \
-	buffer.o \
-	crypto.o \
-	cryptoapi.o \
-	error.o \
-	event.o \
-	fdmisc.o \
-	forward.o \
-        fragment.o \
-	gremlin.o \
-	helper.o \
-	init.o \
-	interval.o \
-        list.o \
-	lladdr.o \
-	lzo.o \
-	manage.o \
-	mbuf.o \
-	misc.o \
-	mroute.o \
-	mss.o \
-	mtcp.o \
-	mtu.o \
-	mudp.o \
-	multi.o \
-	ntlm.o \
-	occ.o \
-	pkcs11.o \
-        openvpn.o \
-	options.o \
-	otime.o \
-	packet_id.o \
-	perf.o \
-	ping.o \
-	plugin.o \
-        pool.o \
-	proto.o \
-	proxy.o \
-	push.o \
-	reliable.o \
-        route.o \
-	schedule.o \
-	session_id.o \
-	shaper.o \
-	sig.o \
-	socket.o \
-        socks.o \
-	ssl.o \
-	status.o \
-	thread.o \
-	tun.o \
-	win32.o
-
-dynamic : MY_CC = ${CC}
-dynamic : MY_INCLUDE_DIRS = ${INCLUDE_DIRS}
-dynamic : ${OBJS}
-	${MY_CC} -o ${EXE} ${OBJS} ${LIB_DIRS} -lssl32 -leay32 ${LIBS}
-
-static : MY_CC = ${CC}
-static : MY_INCLUDE_DIRS = ${INCLUDE_DIRS}
-static : ${OBJS}
-	${CC} -o ${EXE} ${OBJS} ${LIB_DIRS} -lssl -lcrypto ${LIBS}
-
-dmalloc : MY_CC = ${CC_DMALLOC}
-dmalloc : MY_INCLUDE_DIRS = ${INCLUDE_DIRS_DMALLOC}
-dmalloc : ${OBJS}
-	${MY_CC} -o ${EXE} ${OBJS} ${LIB_DIRS_DMALLOC} -lssl32 -leay32 ${LIBS_DMALLOC}
-
-clean :
-	rm -f ${OBJS} ${EXE}
-
-%.o : %.c ${HEADERS}
-	${MY_CC} ${MY_INCLUDE_DIRS} -c $< -o $@
diff -urN openvpn-2.1_rc7/makefile.w32-vc openvpn-2.1_rc9/makefile.w32-vc
--- openvpn-2.1_rc7/makefile.w32-vc	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/makefile.w32-vc	1970-01-01 01:00:00.000000000 +0100
@@ -1,186 +0,0 @@
-# This makefile builds the user-mode component
-# of OpenVPN for WIN32 in the MSVC++ environment.
-#
-# Build Dependencies:
-#	OpenSSL		(SSL/TLS/crypto library)
-#	LZO		(real-time compression library)
-#
-# Targets:
-#	static -- link statically with OpenSSL
-#	dynamic -- link dynamically with OpenSSL
-#
-# Note that LZO is always linked statically.
-
-# Change these to point to your OpenSSL and LZO top-level
-# directories.
-
-OPENSSL = \src\openssl-0.9.7d
-OPENSSL_STATIC = libeay32s.lib ssleay32s.lib
-#OPENSSL_STATIC = libeay32sd.lib ssleay32sd.lib
-OPENSSL_DYNAMIC = libeay32.lib ssleay32.lib
-#OPENSSL_DYNAMIC = libeay32d.lib ssleay32d.lib
-
-LZO = \src\lzo-1.08.vc
-
-PKCS11_HELPER = \src\pkcs11-helper-1.02
-
-INCLUDE_DIRS = -I$(OPENSSL)/include -I$(LZO)/include -I$(PKCS11_HELPER)/include
-
-LIBS = lzo.lib libpkcs11-helper-1.lib ws2_32.lib crypt32.lib iphlpapi.lib winmm.lib user32.lib gdi32.lib advapi32.lib wininet.lib
-
-LIB_DIRS = -LIBPATH:$(OPENSSL)\out -LIBPATH:$(LZO) -LIBPATH:$(PKCS11_HELPER)\lib
-
-EXE = openvpn.exe
-
-CPP=cl.exe
-CPP_ARG_COMMON=/nologo /W3 /G5 /O2 -DWIN32 -DWIN32_LEAN_AND_MEAN -D_CONSOLE -D_MBCS -D_CRT_SECURE_NO_DEPRECATE $(INCLUDE_DIRS) /FD /c
-# release:
-CPP_PROJ=$(CPP_ARG_COMMON) /MD -DNDEBUG
-# debug:
-#CPP_PROJ=$(CPP_ARG_COMMON) /MDd /Zi /Od -D_DEBUG
-
-LINK32=link.exe
-# release:
-LINK32_FLAGS=/nologo /subsystem:console /incremental:no /out:"$(EXE)"
-# debug:
-#LINK32_FLAGS=/nologo /subsystem:console /incremental:no /debug /out:"$(EXE)"
-
-# Make sure the HEADERS and OBJS definitions below match the same
-# definitions in makefile.w32.
-
-HEADERS = \
-	base64.h \
-	basic.h \
-	buffer.h \
-	circ_list.h common.h \
-	tap-win32/common.h \
-        config-win32.h \
-	crypto.h \
-	cryptoapi.h \
-	errlevel.h \
-	error.h \
-	event.h \
-        fdmisc.h \
-	forward-inline.h \
-	forward.h \
-	fragment.h \
-        gremlin.h \
-	helper.h \
-	init.h \
-	integer.h \
-	interval.h \
-	list.h \
-	lzo.h \
-	manage.h \
-	mbuf.h \
-	memdbg.h \
-	misc.h \
-	mroute.h \
-	mss.h \
-	mtcp.h \
-	mtu.h \
-	mudp.h \
-	multi.h \
-	ntlm.h \
-	occ-inline.h \
-	occ.h \
-	pkcs11.h \
-        openvpn.h \
-	openvpn-plugin.h \
-	options.h \
-	otime.h \
-	packet_id.h \
-	perf.h \
-	ping-inline.h \
-	ping.h \
-	plugin.h \
-	pool.h \
-        proto.h \
-	proxy.h \
-	push.h \
-	reliable.h \
-	route.h \
-	schedule.h \
-	session_id.h \
-        shaper.h \
-	sig.h \
-	socket.h \
-	socks.h \
-	ssl.h \
-        status.h \
-	syshead.h \
-        thread.h \
-	tun.h \
-	lladdr.h \
-	win32.h
-
-OBJS =  base64.obj \
-	buffer.obj \
-	crypto.obj \
-	cryptoapi.obj \
-	error.obj \
-	event.obj \
-	fdmisc.obj \
-	forward.obj \
-        fragment.obj \
-	gremlin.obj \
-	helper.obj \
-	init.obj \
-	interval.obj \
-        list.obj \
-	lzo.obj \
-	manage.obj \
-	mbuf.obj \
-	misc.obj \
-	mroute.obj \
-	mss.obj \
-	mtcp.obj \
-	mtu.obj \
-	mudp.obj \
-	multi.obj \
-	ntlm.obj \
-	occ.obj \
-	pkcs11.obj \
-        openvpn.obj \
-	options.obj \
-	otime.obj \
-	packet_id.obj \
-	perf.obj \
-	ping.obj \
-	plugin.obj \
-        pool.obj \
-	proto.obj \
-	proxy.obj \
-	push.obj \
-	reliable.obj \
-        route.obj \
-	schedule.obj \
-	session_id.obj \
-	shaper.obj \
-	sig.obj \
-	socket.obj \
-        socks.obj \
-	ssl.obj \
-	status.obj \
-	thread.obj \
-	tun.obj \
-	lladdr.obj \
-	win32.obj
-
-dynamic : $(OBJS)
-	$(LINK32) @<<
-	$(LINK32_FLAGS) $(LIB_DIRS) $(LIBS) $(OPENSSL_DYNAMIC) $(OBJS)
-<<
-
-static : $(OBJS)
-	$(LINK32) @<<
-	$(LINK32_FLAGS) $(LIB_DIRS) $(LIBS) $(OPENSSL_STATIC) $(OBJS)
-<<
-
-clean :
-	del /Q $(OBJS) $(EXE) *.idb *.pdb
-
-.c.obj::
-   $(CPP) @<<
-   $(CPP_PROJ) $<
-<<
diff -urN openvpn-2.1_rc7/manage.c openvpn-2.1_rc9/manage.c
--- openvpn-2.1_rc7/manage.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/manage.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #ifdef ENABLE_MANAGEMENT
@@ -45,6 +39,10 @@
 
 #include "memdbg.h"
 
+#ifdef ENABLE_PKCS11
+#include "pkcs11.h"
+#endif
+
 #define MANAGEMENT_ECHO_PULL_INFO 0
 
 #if MANAGEMENT_ECHO_PULL_INFO
@@ -82,8 +80,23 @@
   msg (M_CLIENT, "mute [n]               : Set log mute level to n, or show level if n is absent.");
   msg (M_CLIENT, "needok type action     : Enter confirmation for NEED-OK request of 'type',");
   msg (M_CLIENT, "                         where action = 'ok' or 'cancel'.");
+  msg (M_CLIENT, "needstr type action    : Enter confirmation for NEED-STR request of 'type',");
+  msg (M_CLIENT, "                         where action is reply string.");
   msg (M_CLIENT, "net                    : (Windows only) Show network info and routing table.");
   msg (M_CLIENT, "password type p        : Enter password p for a queried OpenVPN password.");
+#ifdef ENABLE_PKCS11
+  msg (M_CLIENT, "pkcs11-id-count        : Get number of available PKCS#11 identities.");
+  msg (M_CLIENT, "pkcs11-id-get index    : Get PKCS#11 identity at index.");
+#endif
+#ifdef MANAGEMENT_DEF_AUTH
+  msg (M_CLIENT, "client-auth CID KID    : Authenticate client-id/key-id CID/KID (MULTILINE)");
+  msg (M_CLIENT, "client-auth-nt CID KID : Authenticate client-id/key-id CID/KID");
+  msg (M_CLIENT, "client-deny CID KID R  : Deny auth client-id/key-id CID/KID with reason text R");
+  msg (M_CLIENT, "client-kill CID        : Kill client instance CID");
+#ifdef MANAGEMENT_PF
+  msg (M_CLIENT, "client-pf CID          : Define packet filter for client CID (MULTILINE)");
+#endif
+#endif
   msg (M_CLIENT, "signal s               : Send signal s to daemon,");
   msg (M_CLIENT, "                         s = SIGHUP|SIGTERM|SIGUSR1|SIGUSR2.");
   msg (M_CLIENT, "state [on|off] [N|all] : Like log, but show state history.");
@@ -174,7 +187,7 @@
 {
   if (socket_defined (man->connection.sd_cli))
     {
-      if (output_list_defined (man->connection.out))
+      if (buffer_list_defined (man->connection.out))
 	{
 	  man->connection.state = MS_CC_WAIT_WRITE;
 	}
@@ -191,7 +204,7 @@
   if (management_connected (man))
     {
       if (str)
-	output_list_push (man->connection.out, (const unsigned char *) str);
+	buffer_list_push (man->connection.out, (const unsigned char *) str);
       man_update_io_state (man);
       if (!man->persist.standalone_disabled)
 	{
@@ -541,6 +554,10 @@
       if (strlen (man->connection.up_query.password))
 	man->connection.up_query.defined = true;
       break;
+    case UP_QUERY_NEED_STR:
+      if (strlen (man->connection.up_query.password))
+	man->connection.up_query.defined = true;
+      break;
     default:
       ASSERT (0);
     }
@@ -604,10 +621,19 @@
 }
 
 static void
+man_query_need_str (struct management *man, const char *type, const char *action)
+{
+  const bool needed = ((man->connection.up_query_mode == UP_QUERY_NEED_STR) && man->connection.up_query_type);
+  man_query_user_pass (man, type, action, needed, "needstr-string", man->connection.up_query.password, USER_PASS_LEN);
+}
+
+static void
 man_forget_passwords (struct management *man)
 {
+#if defined(USE_CRYPTO) && defined(USE_SSL)
   ssl_purge_auth ();
   msg (M_CLIENT, "SUCCESS: Passwords were forgotten");
+#endif
 }
 
 static void
@@ -623,6 +649,33 @@
     }
 }
 
+#ifdef ENABLE_PKCS11
+
+static void
+man_pkcs11_id_count (struct management *man)
+{
+  msg (M_CLIENT, ">PKCS11ID-COUNT:%d", pkcs11_management_id_count ());
+}
+
+static void
+man_pkcs11_id_get (struct management *man, const int index)
+{
+  char *id = NULL;
+  char *base64 = NULL;
+
+  if (pkcs11_management_id_get (index, &id, &base64))
+    msg (M_CLIENT, ">PKCS11ID-ENTRY:'%d', ID:'%s', BLOB:'%s'", index, id, base64);
+  else
+    msg (M_CLIENT, ">PKCS11ID-ENTRY:'%d'", index);
+
+  if (id != NULL)
+    free (id);
+  if (base64 != NULL)
+    free (base64);
+}
+
+#endif
+
 static void
 man_hold (struct management *man, const char *cmd)
 {
@@ -630,12 +683,12 @@
     {
       if (streq (cmd, "on"))
 	{
-	  man->settings.hold = true;
+	  man->settings.flags |= MF_HOLD;
 	  msg (M_CLIENT, "SUCCESS: hold flag set to ON");
 	}
       else if (streq (cmd, "off"))
 	{
-	  man->settings.hold = false;
+	  man->settings.flags &= ~MF_HOLD;
 	  msg (M_CLIENT, "SUCCESS: hold flag set to OFF");
 	}
       else if (streq (cmd, "release"))
@@ -649,9 +702,205 @@
 	}
     }
   else
-    msg (M_CLIENT, "SUCCESS: hold=%d", (int) man->settings.hold);
+    msg (M_CLIENT, "SUCCESS: hold=%d", BOOL_CAST(man->settings.flags & MF_HOLD));
+}
+
+#ifdef MANAGEMENT_DEF_AUTH
+
+static bool
+parse_cid (const char *str, unsigned long *cid)
+{
+  if (sscanf (str, "%lu", cid) == 1)
+    return true;
+  else
+    {
+      msg (M_CLIENT, "ERROR: cannot parse CID");
+      return false;
+    }
+}
+
+static bool
+parse_kid (const char *str, unsigned int *kid)
+{
+  if (sscanf (str, "%u", kid) == 1)
+    return true;
+  else
+    {
+      msg (M_CLIENT, "ERROR: cannot parse KID");
+      return false;
+    }
+}
+
+static void
+in_extra_reset (struct man_connection *mc, const bool new)
+{
+  if (mc)
+    {
+      if (!new)
+	{
+	  mc->in_extra_cmd = IEC_UNDEF;
+	  mc->in_extra_cid = 0;
+	  mc->in_extra_kid = 0;
+	}
+      if (mc->in_extra)
+	{
+	  buffer_list_free (mc->in_extra);
+	  mc->in_extra = NULL;
+	}
+      if (new)
+	mc->in_extra = buffer_list_new (0);
+    }
+}
+
+static void
+in_extra_dispatch (struct management *man)
+{
+   switch (man->connection.in_extra_cmd)
+    {
+    case IEC_CLIENT_AUTH:
+       if (man->persist.callback.client_auth)
+	{
+	  const bool status = (*man->persist.callback.client_auth)
+	    (man->persist.callback.arg,
+	     man->connection.in_extra_cid,
+	     man->connection.in_extra_kid,
+	     true,
+	     NULL,
+	     man->connection.in_extra);
+	  man->connection.in_extra = NULL;
+	  if (status)
+	    {
+	      msg (M_CLIENT, "SUCCESS: client-auth command succeeded");
+	    }
+	  else
+	    {
+	      msg (M_CLIENT, "ERROR: client-auth command failed");
+	    }
+	}
+      else
+	{
+	  msg (M_CLIENT, "ERROR: The client-auth command is not supported by the current daemon mode");
+	}
+      break;
+#ifdef MANAGEMENT_PF
+    case IEC_CLIENT_PF:
+      if (man->persist.callback.client_pf)
+	{
+	  const bool status = (*man->persist.callback.client_pf)
+	    (man->persist.callback.arg,
+	     man->connection.in_extra_cid,
+	     man->connection.in_extra);
+	  man->connection.in_extra = NULL;
+	  if (status)
+	    {
+	      msg (M_CLIENT, "SUCCESS: client-pf command succeeded");
+	    }
+	  else
+	    {
+	      msg (M_CLIENT, "ERROR: client-pf command failed");
+	    }
+	}
+      else
+	{
+	  msg (M_CLIENT, "ERROR: The client-pf command is not supported by the current daemon mode");
+	}
+      break;
+#endif
+    }
+   in_extra_reset (&man->connection, false);
+}
+
+static void
+man_client_auth (struct management *man, const char *cid_str, const char *kid_str, const bool extra)
+{
+  struct man_connection *mc = &man->connection;
+  mc->in_extra_cid = 0;
+  mc->in_extra_kid = 0;
+  if (parse_cid (cid_str, &mc->in_extra_cid)
+      && parse_kid (kid_str, &mc->in_extra_kid))
+    {
+      mc->in_extra_cmd = IEC_CLIENT_AUTH;
+      in_extra_reset (mc, true);
+      if (!extra)
+	in_extra_dispatch (man);
+    }
+}
+
+static void
+man_client_deny (struct management *man, const char *cid_str, const char *kid_str, const char *reason)
+{
+  unsigned long cid = 0;
+  unsigned int kid = 0;
+  if (parse_cid (cid_str, &cid) && parse_kid (kid_str, &kid))
+    {
+      if (man->persist.callback.client_auth)
+	{
+	  const bool status = (*man->persist.callback.client_auth)
+	    (man->persist.callback.arg,
+	     cid,
+	     kid,
+	     false,
+	     reason,
+	     NULL);
+	  if (status)
+	    {
+	      msg (M_CLIENT, "SUCCESS: client-deny command succeeded");
+	    }
+	  else
+	    {
+	      msg (M_CLIENT, "ERROR: client-deny command failed");
+	    }
+	}
+      else
+	{
+	  msg (M_CLIENT, "ERROR: The client-deny command is not supported by the current daemon mode");
+	}
+    }
+}
+
+static void
+man_client_kill (struct management *man, const char *cid_str)
+{
+  unsigned long cid = 0;
+  if (parse_cid (cid_str, &cid))
+    {
+      if (man->persist.callback.kill_by_cid)
+	{
+	  const bool status = (*man->persist.callback.kill_by_cid) (man->persist.callback.arg, cid);
+	  if (status)
+	    {
+	      msg (M_CLIENT, "SUCCESS: client-kill command succeeded");
+	    }
+	  else
+	    {
+	      msg (M_CLIENT, "ERROR: client-kill command failed");
+	    }
+	}
+      else
+	{
+	  msg (M_CLIENT, "ERROR: The client-kill command is not supported by the current daemon mode");
+	}
+    }
 }
 
+#ifdef MANAGEMENT_PF
+
+static void
+man_client_pf (struct management *man, const char *cid_str)
+{
+  struct man_connection *mc = &man->connection;
+  mc->in_extra_cid = 0;
+  mc->in_extra_kid = 0;
+  if (parse_cid (cid_str, &mc->in_extra_cid))
+    {
+      mc->in_extra_cmd = IEC_CLIENT_PF;
+      in_extra_reset (mc, true);
+    }
+}
+
+#endif
+#endif
+
 #define MN_AT_LEAST (1<<0)
 
 static bool
@@ -807,6 +1056,11 @@
       if (man_need (man, p, 2, 0))
 	man_query_need_ok (man, p[1], p[2]);
     }
+  else if (streq (p[0], "needstr"))
+    {
+      if (man_need (man, p, 2, 0))
+	man_query_need_str (man, p[1], p[2]);
+    }
   else if (streq (p[0], "net"))
     {
       man_net (man);
@@ -820,6 +1074,46 @@
       if (man_need (man, p, 1, 0))
 	man_bytecount (man, atoi(p[1]));
     }
+#ifdef MANAGEMENT_DEF_AUTH
+  else if (streq (p[0], "client-kill"))
+    {
+      if (man_need (man, p, 1, 0))
+	man_client_kill (man, p[1]);
+    }
+  else if (streq (p[0], "client-deny"))
+    {
+      if (man_need (man, p, 3, 0))
+	man_client_deny (man, p[1], p[2], p[3]);
+    }
+  else if (streq (p[0], "client-auth-nt"))
+    {
+      if (man_need (man, p, 2, 0))
+	man_client_auth (man, p[1], p[2], false);
+    }
+  else if (streq (p[0], "client-auth"))
+    {
+      if (man_need (man, p, 2, 0))
+	man_client_auth (man, p[1], p[2], true);
+    }
+#ifdef MANAGEMENT_PF
+  else if (streq (p[0], "client-pf"))
+    {
+      if (man_need (man, p, 1, 0))
+	man_client_pf (man, p[1]);
+    }
+#endif
+#endif
+#ifdef ENABLE_PKCS11
+  else if (streq (p[0], "pkcs11-id-count"))
+    {
+      man_pkcs11_id_count (man);
+    }
+  else if (streq (p[0], "pkcs11-id-get"))
+    {
+      if (man_need (man, p, 1, 0))
+	man_pkcs11_id_get (man, atoi(p[1]));
+    }
+#endif
 #if 1
   else if (streq (p[0], "test"))
     {
@@ -941,7 +1235,7 @@
        description,
        print_sockaddr (&man->settings.local, &gc));
 
-  output_list_reset (man->connection.out);
+  buffer_list_reset (man->connection.out);
 
   if (!man_password_needed (man))
     man_welcome (man);
@@ -1076,14 +1370,18 @@
       man_close_socket (man, man->connection.sd_cli);
       man->connection.sd_cli = SOCKET_UNDEFINED;
       command_line_reset (man->connection.in);
-      output_list_reset (man->connection.out);
+      buffer_list_reset (man->connection.out);
+#ifdef MANAGEMENT_DEF_AUTH
+      in_extra_reset (&man->connection, false);
+#endif
     }
   if (!exiting)
     {
-      if (man->settings.management_forget_disconnect)
-	 ssl_purge_auth ();
-
-      if (man->settings.signal_on_disconnect) {
+#if defined(USE_CRYPTO) && defined(USE_SSL)
+      if (man->settings.flags & MF_FORGET_DISCONNECT)
+	ssl_purge_auth ();
+#endif
+      if (man->settings.flags & MF_SIGNAL) {
       	  int mysig = man_mod_signal (man, SIGUSR1);
 	  if (mysig >= 0)
 	    {
@@ -1092,7 +1390,7 @@
 	    }
       }
 
-      if (man->settings.connect_as_client)
+      if (man->settings.flags & MF_CONNECT_AS_CLIENT)
 	{
 	  msg (D_MANAGEMENT, "MANAGEMENT: Triggering management exit");
 	  throw_signal_soft (SIGTERM, "management-exit");
@@ -1112,6 +1410,9 @@
 
   CLEAR (parms);
   so = status_open (NULL, 0, -1, &man->persist.vout, 0);
+#ifdef MANAGEMENT_DEF_AUTH
+  in_extra_reset (&man->connection, false);
+#endif
 
   if (man_password_needed (man))
     {
@@ -1185,7 +1486,7 @@
       /*
        * Reset output object
        */
-      output_list_reset (man->connection.out);
+      buffer_list_reset (man->connection.out);
 
       /*
        * process command line if complete
@@ -1194,7 +1495,22 @@
 	const unsigned char *line;
 	while ((line = command_line_get (man->connection.in)))
 	  {
-	    man_process_command (man, (char *) line);
+#ifdef MANAGEMENT_DEF_AUTH
+	    if (man->connection.in_extra)
+	      {
+		if (!strcmp ((char *)line, "END"))
+		  {
+		    in_extra_dispatch (man);
+		    in_extra_reset (&man->connection, false);
+		  }
+		else
+		  {
+		    buffer_list_push (man->connection.in_extra, line);
+		  }
+	      }
+	    else
+#endif
+	      man_process_command (man, (char *) line);
 	    if (man->connection.halt)
 	      break;
 	    command_line_next (man->connection.in);
@@ -1231,14 +1547,14 @@
   const int max_send = 256;
   int sent = 0;
 
-  const struct buffer *buf = output_list_peek (man->connection.out);
+  const struct buffer *buf = buffer_list_peek (man->connection.out);
   if (buf && BLEN (buf))
     {
       const int len = min_int (max_send, BLEN (buf));
       sent = send (man->connection.sd_cli, BPTR (buf), len, MSG_NOSIGNAL);
       if (sent >= 0)
 	{
-	  output_list_advance (man->connection.out, sent);
+	  buffer_list_advance (man->connection.out, sent);
 	}
       else if (sent < 0)
 	{
@@ -1329,27 +1645,18 @@
 		   const char *addr,
 		   const int port,
 		   const char *pass_file,
-		   const bool server,
-		   const bool query_passwords,
 		   const int log_history_cache,
 		   const int echo_buffer_size,
 		   const int state_buffer_size,
-		   const bool hold,
-		   const bool signal_on_disconnect,
-		   const bool management_forget_disconnect,
-		   const bool connect_as_client,
 		   const char *write_peer_info_file,
-		   const int remap_sigusr1)
+		   const int remap_sigusr1,
+		   const unsigned int flags)
 {
   if (!ms->defined)
     {
       CLEAR (*ms);
 
-      /*
-       * Are we a server?  If so, it will influence
-       * the way we handle state transitions.
-       */
-      ms->server = server;
+      ms->flags = flags;
 
       /*
        * Get username/password
@@ -1357,34 +1664,6 @@
       if (pass_file)
 	get_user_pass (&ms->up, pass_file, "Management", GET_USER_PASS_PASSWORD_ONLY);
 
-      /*
-       * Should OpenVPN query the management layer for
-       * passwords?
-       */
-      ms->up_query_passwords = query_passwords;
-
-      /*
-       * Should OpenVPN hibernate on startup?
-       */
-      ms->hold = hold;
-
-      /*
-       * Should OpenVPN be signaled if management
-       * disconnects?
-       */
-      ms->signal_on_disconnect = signal_on_disconnect;
-
-      /*
-       * Should OpenVPN forget passwords when managmenet
-       * session disconnects?
-       */
-      ms->management_forget_disconnect = management_forget_disconnect;
-
-      /*
-       * Should OpenVPN connect to management interface as a client
-       * rather than a server?
-       */
-      ms->connect_as_client = connect_as_client;
       ms->write_peer_info_file = string_alloc (write_peer_info_file, NULL);
 
       /*
@@ -1398,7 +1677,7 @@
        * Run management over tunnel, or
        * separate channel?
        */
-      if (streq (addr, "tunnel") && !connect_as_client)
+      if (streq (addr, "tunnel") && !(flags & MF_CONNECT_AS_CLIENT))
 	{
 	  ms->management_over_tunnel = true;
 	}
@@ -1453,7 +1732,7 @@
        * command output from/to the socket.
        */
       man->connection.in = command_line_new (256);
-      man->connection.out = output_list_new (0);
+      man->connection.out = buffer_list_new (0);
 
       /*
        * Initialize event set for standalone usage, when we are
@@ -1467,7 +1746,7 @@
       /*
        * Listen/connect socket
        */
-      if (man->settings.connect_as_client)
+      if (man->settings.flags & MF_CONNECT_AS_CLIENT)
 	man_connect (man);
       else
 	man_listen (man);
@@ -1491,7 +1770,10 @@
   if (mc->in)
     command_line_free (mc->in);
   if (mc->out)
-    output_list_free (mc->out);
+    buffer_list_free (mc->out);
+#ifdef MANAGEMENT_DEF_AUTH
+  in_extra_reset (&man->connection, false);
+#endif
   man_connection_clear (mc);
 }
 
@@ -1516,17 +1798,12 @@
 		 const char *addr,
 		 const int port,
 		 const char *pass_file,
-		 const bool server,
-		 const bool query_passwords,
 		 const int log_history_cache,
 		 const int echo_buffer_size,
 		 const int state_buffer_size,
-		 const bool hold,
-		 const bool signal_on_disconnect,
-		 const bool management_forget_disconnect,
-		 const bool connect_as_client,
 		 const char *write_peer_info_file,
-		 const int remap_sigusr1)
+		 const int remap_sigusr1,
+		 const unsigned int flags)
 {
   bool ret = false;
 
@@ -1538,17 +1815,12 @@
 		     addr,
 		     port,
 		     pass_file,
-		     server,
-		     query_passwords,
 		     log_history_cache,
 		     echo_buffer_size,
 		     state_buffer_size,
-		     hold,
-		     signal_on_disconnect,
-		     management_forget_disconnect,
-		     connect_as_client,
 		     write_peer_info_file,
-		     remap_sigusr1);
+		     remap_sigusr1,
+		     flags);
 
   /*
    * The log is initially sized to MANAGEMENT_LOG_HISTORY_INITIAL_SIZE,
@@ -1607,7 +1879,7 @@
 		      const in_addr_t tun_local_ip,
 		      const in_addr_t tun_remote_ip)
 {
-  if (man->persist.state && (!man->settings.server || state < OPENVPN_STATE_CLIENT_BASE))
+  if (man->persist.state && (!(man->settings.flags & MF_SERVER) || state < OPENVPN_STATE_CLIENT_BASE))
     {
       struct gc_arena gc = gc_new ();
       struct log_entry e;
@@ -1639,6 +1911,79 @@
     }
 }
 
+#ifdef MANAGEMENT_DEF_AUTH
+
+static void
+man_output_env (const struct env_set *es)
+{
+  if (es)
+    {
+      struct env_item *e;
+      for (e = es->list; e != NULL; e = e->next)
+	{
+	  if (e->string)
+	    msg (M_CLIENT, ">CLIENT:ENV,%s", e->string);
+	}
+    }
+  msg (M_CLIENT, ">CLIENT:ENV,END");
+}
+
+void
+management_notify_client_needing_auth (struct management *management,
+				       const unsigned int mda_key_id,
+				       struct man_def_auth_context *mdac,
+				       const struct env_set *es)
+{
+  if (!(mdac->flags & DAF_CONNECTION_CLOSED))
+    {
+      const char *mode = "CONNECT";
+      if (mdac->flags & DAF_CONNECTION_ESTABLISHED)
+	mode = "REAUTH";
+      msg (M_CLIENT, ">CLIENT:%s,%lu,%u", mode, mdac->cid, mda_key_id);
+      man_output_env (es);
+      mdac->flags |= DAF_INITIAL_AUTH;
+    }
+}
+
+void
+management_connection_established (struct management *management,
+				   struct man_def_auth_context *mdac)
+{
+  mdac->flags |= DAF_CONNECTION_ESTABLISHED;
+}
+
+void
+management_notify_client_close (struct management *management,
+				struct man_def_auth_context *mdac,
+				const struct env_set *es)
+{
+  if ((mdac->flags & DAF_INITIAL_AUTH) && !(mdac->flags & DAF_CONNECTION_CLOSED))
+    {
+      msg (M_CLIENT, ">CLIENT:DISCONNECT,%lu", mdac->cid);
+      man_output_env (es);
+      mdac->flags |= DAF_CONNECTION_CLOSED;
+    }
+}
+
+void
+management_learn_addr (struct management *management,
+		       struct man_def_auth_context *mdac,
+		       const struct mroute_addr *addr,
+		       const bool primary)
+{
+  struct gc_arena gc = gc_new ();
+  if ((mdac->flags & DAF_INITIAL_AUTH) && !(mdac->flags & DAF_CONNECTION_CLOSED))
+    {
+      msg (M_CLIENT, ">CLIENT:ADDRESS,%lu,%s,%d",
+	   mdac->cid,
+	   mroute_addr_print_ex (addr, MAPF_SUBNET, &gc),
+	   BOOL_CAST (primary));
+    }
+  gc_free (&gc);
+}
+
+#endif
+
 void
 management_echo (struct management *man, const char *string, const bool pull)
 {
@@ -2037,6 +2382,12 @@
 	  prefix= "NEED-OK";
 	  alert_type = "confirmation";
 	}
+      else if (flags & GET_USER_PASS_NEED_STR)
+        {
+	  up_query_mode = UP_QUERY_NEED_STR;
+	  prefix= "NEED-STR";
+	  alert_type = "string";
+	}
       else if (flags & GET_USER_PASS_PASSWORD_ONLY)
 	{
 	  up_query_mode = UP_QUERY_PASS;
@@ -2054,7 +2405,7 @@
 		  type,
 		  alert_type);
 
-      if (flags & GET_USER_PASS_NEED_OK)
+      if (flags & (GET_USER_PASS_NEED_OK | GET_USER_PASS_NEED_STR))
 	buf_printf (&alert_msg, " MSG:%s", up->username);
 
       man_wait_for_client_connection (man, &signal_received, 0, MWCC_PASSWORD_WAIT);
@@ -2114,7 +2465,7 @@
 bool
 management_would_hold (struct management *man)
 {
-  return man->settings.hold && !man->persist.hold_release && man_standalone_ok (man);
+  return (man->settings.flags & MF_HOLD) && !man->persist.hold_release && man_standalone_ok (man);
 }
 
 /*
@@ -2124,7 +2475,7 @@
 bool
 management_should_daemonize (struct management *man)
 {
-  return management_would_hold (man) || man->settings.up_query_passwords;
+  return management_would_hold (man) || (man->settings.flags & MF_QUERY_PASSWORDS);
 }
 
 /*
@@ -2238,108 +2589,6 @@
 }
 
 /*
- * struct output_list
- */
-
-struct output_list *
-output_list_new (const int max_size)
-{
-  struct output_list *ret;
-  ALLOC_OBJ_CLEAR (ret, struct output_list);
-  ret->max_size = max_size;
-  ret->size = 0;
-  return ret;
-}
-
-void
-output_list_free (struct output_list *ol)
-{
-  output_list_reset (ol);
-  free (ol);
-}
-
-bool
-output_list_defined (const struct output_list *ol)
-{
-  return ol->head != NULL;
-}
-
-void
-output_list_reset (struct output_list *ol)
-{
-  struct output_entry *e = ol->head;
-  while (e)
-    {
-      struct output_entry *next = e->next;
-      free_buf (&e->buf);
-      free (e);
-      e = next;
-    }
-  ol->head = ol->tail = NULL;
-  ol->size = 0;
-}
-
-void
-output_list_push (struct output_list *ol, const unsigned char *str)
-{
-  if (!ol->max_size || ol->size < ol->max_size)
-    {
-      struct output_entry *e;
-      ALLOC_OBJ_CLEAR (e, struct output_entry);
-
-      ++ol->size;
-      if (ol->tail)
-	{
-	  ASSERT (ol->head);
-	  ol->tail->next = e;
-	}
-      else
-	{
-	  ASSERT (!ol->head);
-	  ol->head = e;
-	}
-      e->buf = string_alloc_buf ((const char *) str, NULL);
-      ol->tail = e;
-    }
-}
-
-const struct buffer *
-output_list_peek (struct output_list *ol)
-{
-  if (ol->head)
-    return &ol->head->buf;
-  else
-    return NULL;
-}
-
-static void
-output_list_pop (struct output_list *ol)
-{
-  if (ol->head)
-    {
-      struct output_entry *e = ol->head->next;
-      free_buf (&ol->head->buf);
-      free (ol->head);
-      ol->head = e;
-      --ol->size;
-      if (!e)
-	ol->tail = NULL;
-    }
-}
-
-void
-output_list_advance (struct output_list *ol, int n)
-{
-  if (ol->head)
-    {
-      struct buffer *buf = &ol->head->buf;
-      ASSERT (buf_advance (buf, n));
-      if (!BLEN (buf))
-	output_list_pop (ol);
-    }
-}
-
-/*
  * struct log_entry
  */
 
diff -urN openvpn-2.1_rc7/manage.h openvpn-2.1_rc9/manage.h
--- openvpn-2.1_rc7/manage.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/manage.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -30,6 +30,7 @@
 #include "misc.h"
 #include "event.h"
 #include "socket.h"
+#include "mroute.h"
 
 #define MANAGEMENT_VERSION                      1
 #define MANAGEMENT_N_PASSWORD_RETRIES           3
@@ -38,6 +39,22 @@
 #define MANAGEMENT_STATE_BUFFER_SIZE          100
 
 /*
+ * Management-interface-based deferred authentication
+ */
+#ifdef MANAGEMENT_DEF_AUTH
+struct man_def_auth_context {
+  unsigned long cid;
+
+#define DAF_CONNECTION_ESTABLISHED (1<<0)
+#define DAF_CONNECTION_CLOSED      (1<<1)
+#define DAF_INITIAL_AUTH           (1<<2)
+  unsigned int flags;
+
+  unsigned int mda_key_id_counter;
+};
+#endif
+
+/*
  * Manage build-up of command line
  */
 struct command_line
@@ -55,34 +72,6 @@
 void command_line_next (struct command_line *cl);
 
 /*
- * Manage lists of output strings
- */
-
-struct output_entry
-{
-  struct buffer buf;
-  struct output_entry *next;
-};
-
-struct output_list
-{
-  struct output_entry *head; /* next item to pop/peek */
-  struct output_entry *tail; /* last item pushed */
-  int size;                  /* current number of entries */
-  int max_size;              /* maximum size list should grow to */
-};
-
-struct output_list *output_list_new (const int max_size);
-void output_list_free (struct output_list *ol);
-
-bool output_list_defined (const struct output_list *ol);
-void output_list_reset (struct output_list *ol);
-
-void output_list_push (struct output_list *ol, const unsigned char *str);
-const struct buffer *output_list_peek (struct output_list *ol);
-void output_list_advance (struct output_list *ol, int n);
-
-/*
  * Manage log file history
  */
 
@@ -148,7 +137,8 @@
 }
 
 /*
- * Callbacks for 'status' and 'kill' commands
+ * Callbacks for 'status' and 'kill' commands.
+ * Also for management-based deferred authentication and packet filter.
  */
 struct management_callback
 {
@@ -158,6 +148,20 @@
   int (*kill_by_cn) (void *arg, const char *common_name);
   int (*kill_by_addr) (void *arg, const in_addr_t addr, const int port);
   void (*delete_event) (void *arg, event_t event);
+#ifdef MANAGEMENT_DEF_AUTH
+  bool (*kill_by_cid) (void *arg, const unsigned long cid);
+  bool (*client_auth) (void *arg,
+		       const unsigned long cid,
+		       const unsigned int mda_key_id,
+		       const bool auth,
+		       const char *reason,
+		       struct buffer_list *cc_config); /* ownership transferred */
+#endif
+#ifdef MANAGEMENT_PF
+  bool (*client_pf) (void *arg,
+		     const unsigned long cid,
+		     struct buffer_list *pf_config);   /* ownership transferred */
+#endif
 };
 
 /*
@@ -196,18 +200,13 @@
 
 struct man_settings {
   bool defined;
+  unsigned int flags; /* MF_x flags */
   struct openvpn_sockaddr local;
-  bool up_query_passwords;
   bool management_over_tunnel;
   struct user_pass up;
   int log_history_cache;
   int echo_buffer_size;
   int state_buffer_size;
-  bool server;
-  bool hold;
-  bool signal_on_disconnect;
-  bool management_forget_disconnect;
-  bool connect_as_client;
   char *write_peer_info_file;
 
 /* flags for handling the management interface "signal" command */
@@ -222,6 +221,7 @@
 #define UP_QUERY_USER_PASS 1
 #define UP_QUERY_PASS      2
 #define UP_QUERY_NEED_OK   3
+#define UP_QUERY_NEED_STR  4
 
 /* states */
 #define MS_INITIAL          0  /* all sockets are closed */
@@ -245,8 +245,17 @@
   int password_tries;
 
   struct command_line *in;
-  struct output_list *out;
+  struct buffer_list *out;
 
+#ifdef MANAGEMENT_DEF_AUTH
+# define IEC_UNDEF       0
+# define IEC_CLIENT_AUTH 1
+# define IEC_CLIENT_PF   2
+  int in_extra_cmd;
+  unsigned long in_extra_cid;
+  unsigned int in_extra_kid;
+  struct buffer_list *in_extra;
+#endif
   struct event_set *es;
 
   bool state_realtime;
@@ -273,21 +282,29 @@
 
 struct management *management_init (void);
 
+/* management_open flags */
+# define MF_SERVER            (1<<0)
+# define MF_QUERY_PASSWORDS   (1<<1)
+# define MF_HOLD              (1<<2)
+# define MF_SIGNAL            (1<<3)
+# define MF_FORGET_DISCONNECT (1<<4)
+# define MF_CONNECT_AS_CLIENT (1<<5)
+#ifdef MANAGEMENT_DEF_AUTH
+# define MF_CLIENT_AUTH       (1<<6)
+#endif
+#ifdef MANAGEMENT_PF
+# define MF_CLIENT_PF         (1<<7)
+#endif
 bool management_open (struct management *man,
 		      const char *addr,
 		      const int port,
 		      const char *pass_file,
-		      const bool server,
-		      const bool query_passwords,
 		      const int log_history_cache,
 		      const int echo_buffer_size,
 		      const int state_buffer_size,
-		      const bool hold,
-		      const bool signal_on_disconnect,
-		      const bool management_forget_disconnect,
-		      const bool connect_as_client,
 		      const char *write_peer_info_file,
-		      const int remap_sigusr1);
+		      const int remap_sigusr1,
+		      const unsigned int flags);
 
 void management_close (struct management *man);
 
@@ -315,6 +332,25 @@
 
 void management_event_loop_n_seconds (struct management *man, int sec);
 
+#ifdef MANAGEMENT_DEF_AUTH
+void management_notify_client_needing_auth (struct management *management,
+					    const unsigned int auth_id,
+					    struct man_def_auth_context *mdac,
+					    const struct env_set *es);
+
+void management_connection_established (struct management *management,
+					struct man_def_auth_context *mdac);
+
+void management_notify_client_close (struct management *management,
+				     struct man_def_auth_context *mdac,
+				     const struct env_set *es);
+
+void management_learn_addr (struct management *management,
+			    struct man_def_auth_context *mdac,
+			    const struct mroute_addr *addr,
+			    const bool primary);
+#endif
+
 static inline bool
 management_connected (const struct management *man)
 {
@@ -324,8 +360,24 @@
 static inline bool
 management_query_user_pass_enabled (const struct management *man)
 {
-  return man->settings.up_query_passwords;
+  return BOOL_CAST(man->settings.flags & MF_QUERY_PASSWORDS);
+}
+
+#ifdef MANAGEMENT_PF
+static inline bool
+management_enable_pf (const struct management *man)
+{
+  return man && BOOL_CAST(man->settings.flags & MF_CLIENT_PF);
 }
+#endif
+
+#ifdef MANAGEMENT_DEF_AUTH
+static inline bool
+management_enable_def_auth (const struct management *man)
+{
+  return man && BOOL_CAST(man->settings.flags & MF_CLIENT_AUTH);
+}
+#endif
 
 /*
  * OpenVPN tells the management layer what state it's in
diff -urN openvpn-2.1_rc7/management/management-notes.txt openvpn-2.1_rc9/management/management-notes.txt
--- openvpn-2.1_rc7/management/management-notes.txt	2008-01-23 22:08:39.000000000 +0100
+++ openvpn-2.1_rc9/management/management-notes.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,473 +0,0 @@
-OpenVPN Management Interface Notes
-----------------------------------
-
-The OpenVPN Management interface allows OpenVPN to
-be administratively controlled from an external program via
-a TCP socket.
-
-The interface has been specifically designed for GUI developers
-and those who would like to programmatically or remotely control
-an OpenVPN daemon.
-
-The management interface is implemented using a client/server TCP
-connection, where OpenVPN will listen on a provided IP address
-and port for incoming management client connections.
-
-The management protocol is currently cleartext without an explicit
-security layer.  For this reason, it is recommended that the
-management interface either listen on localhost (127.0.0.1)
-or on the local VPN address.  It's possible to remotely connect
-to the management interface over the VPN itself, though some
-capabilities will be limited in this mode, such as the ability
-to provide private key passwords.
-
-Future versions of the management interface may allow out-of-band
-connections (i.e. not over the VPN) and secured with SSL/TLS.
-
-The management interface is enabled in the OpenVPN
-configuration file using the following directives:
-
---management
---management-query-passwords
---management-log-cache
-
-See the man page for documentation on these directives.
-
-Once OpenVPN has started with the management layer enabled,
-you can telnet to the management port (make sure to use
-a telnet client which understands "raw" mode).
-
-Once connected to the management port, you can use
-the "help" command to list all commands.
-
-COMMAND -- echo
----------------
-
-The echo capability is used to allow GUI-specific
-parameters to be either embedded in the OpenVPN config file
-or pushed to an OpenVPN client from a server.
-
-Command examples:
-
-  echo on      -- turn on real-time notification of echo messages
-  echo all     -- print the current echo history list
-  echo off     -- turn off real-time notification of echo messages
-  echo on all  -- atomically enable real-time notification,
-                  plus show any messages in history buffer
-
-For example, suppose you are developing a OpenVPN GUI and
-you want to give the OpenVPN server the ability to ask
-the GUI to forget any saved passwords.
-
-In the OpenVPN server config file, add:
-
-  push "echo forget-passwords"
-
-When the OpenVPN client receives its pulled list of directives
-from the server, the "echo forget-passwords" directive will
-be in the list, and it will cause the management interface
-to save the "forget-passwords" string in its list of echo
-parameters.
-
-The management client can use "echo all" to output the full
-list of echoed parameters, "echo on" to turn on real-time
-notification of echoed parameters via the ">ECHO:" prefix,
-or "echo off" to turn off real-time notification.
-
-When the GUI connects to the OpenVPN management socket, it
-can issue an "echo all" command, which would produce output
-like this:
-
-  1101519562,forget-passwords
-  END
-
-Essentially the echo command allowed us to pass parameters from
-the OpenVPN server to the OpenVPN client, and then to the
-management client (such as a GUI).  The large integer is the
-unix date/time when the echo parameter was received.
-
-If the management client had issued the command "echo on",
-it would have enabled real-time notifications of echo
-parameters.  In this case, our "forget-passwords" message
-would be output like this:
-
-  >ECHO:1101519562,forget-passwords
-
-Like the log command, the echo command can atomically show
-history while simultaneously activating real-time updates:
-
-  echo on all
-
-The size of the echo buffer is currently hardcoded to 100
-messages.
-
-COMMAND -- exit, quit
----------------------
-
-Close the managment session, and resume listening on the
-management port for connections from other clients. Currently,
-the OpenVPN daemon can at most support a single management client
-any one time.
-
-COMMAND -- help
----------------
-
-Print a summary of commands.
-
-COMMAND -- hold
----------------
-
-The hold command can be used to manipulate the hold flag,
-or release OpenVPN from a hold state.
-
-If the hold flag is set on initial startup or
-restart, OpenVPN will hibernate prior to initializing
-the tunnel until the management interface receives
-a "hold release" command.
-
-The --management-hold directive of OpenVPN can be used
-to start OpenVPN with the hold flag set.
-
-The hold flag setting is persistent and will not
-be reset by restarts.
-
-OpenVPN will indicate that it is in a hold state by
-sending a real-time notification to the management
-client:
-
-  >HOLD:Waiting for hold release
-
-Command examples:
-
-  hold         -- show current hold flag, 0=off, 1=on.
-  hold on      -- turn on hold flag so that future restarts
-                  will hold.
-  hold off     -- turn off hold flag so that future restarts will
-                  not hold.
-  hold release -- leave hold state and start OpenVPN, but
-                  do not alter the current hold flag setting.
-
-COMMAND -- kill
----------------
-
-In server mode, kill a particlar client instance.
-
-Command examples:
-
-  kill Test-Client -- kill the client instance having a
-                      common name of "Test-Client".
-  kill 1.2.3.4:4000 -- kill the client instance having a
-                       source address and port of 1.2.3.4:4000
-
-Use the "status" command to see which clients are connected.
-
-COMMAND -- log
---------------
-
-Show the OpenVPN log file.  Only the most recent n lines
-of the log file are cached by the management interface, where
-n is controlled by the OpenVPN --management-log-cache directive.
-
-Command examples:
-
-  log on     -- Enable real-time output of log messages.
-  log all    -- Show currently cached log file history.
-  log on all -- Atomically show all currently cached log file
-                history then enable real-time notification of
-                new log file messages.
-  log off    -- Turn off real-time notification of log messages.
-  log 20     -- Show the most recent 20 lines of log file history.
-
-Real-time notification format:
-
-Real-time log messages begin with the ">LOG:" prefix followed
-by the following comma-separated fields:
-
-  (a) unix integer date/time,
-  (b) zero or more message flags in a single string:
-      I -- informational
-      F -- fatal error
-      N -- non-fatal error
-      W -- warning
-      D -- debug, and
-  (c) message text.
-
-COMMAND -- mute
----------------
-
-Change the OpenVPN --mute parameter.  The mute parameter is
-used to silence repeating messages of the same message
-category.
-
-Command examples:
-
-  mute 40 -- change the mute parameter to 40
-  mute    -- show the current mute setting
-
-COMMAND -- net
---------------
-
-(Windows Only) Produce output equivalent to the OpenVPN
---show-net directive.  The output includes OpenVPN's view
-of the system network adapter list and routing table based
-on information returned by the Windows IP helper API.
-
-COMMAND -- password and username
---------------------------------
-
-  The password command is used to pass passwords to OpenVPN.
-
-  If OpenVPN is run with the --management-query-passwords
-  directive, it will query the management interface for RSA
-  private key passwords and the --auth-user-pass
-  username/password.
-
-  When OpenVPN needs a password from the management interface,
-  it will produce a real-time ">PASSWORD:" message.
-
-  Example 1:
-
-    >PASSWORD:Need 'Private Key' password
-
-  OpenVPN is indicating that it needs a password of type
-  "Private Key".
-
-  The management client should respond to this query as follows:
-
-    password "Private Key" foo
-
-  Example 2:
-
-    >PASSWORD:Need 'Auth' username/password
-
-  OpenVPN needs a --auth-user-pass password.  The management
-  client should respond:
-
-    username "Auth" foo
-    password "Auth" bar
-
-  The username/password itself can be in quotes, and special
-  characters such as double quote or backslash must be escaped,
-  for example,
-
-    password "Private Key" "foo\"bar"
-
-  The escaping rules are the same as for the config file.
-  See the "Command Parsing" section below for more info.
-
-  The PASSWORD real-time message type can also be used to
-  indicate password or other types of authentication failure:
-
-  Example 3: The private key password is incorrect and OpenVPN
-  is exiting:
-
-    >PASSWORD:Verification Failed: 'Private Key'
-
-  Example 4: The --auth-user-pass username/password failed,
-  and OpenVPN is exiting:
-
-    >PASSWORD:Verification Failed: 'Auth'
-
-COMMAND -- forget-passwords
----------------------------
-
-The forget-passwords command will cause the daemon to forget passwords
-entered during the session.
-
-Command example:
-
-  forget-passwords -- forget passwords entered so far.
-
-COMMAND -- signal
------------------
-
-The signal command will send a signal to the OpenVPN daemon.
-The signal can be one of SIGHUP, SIGTERM, SIGUSR1, or SIGUSR2.
-
-Command example:
-
-  signal SIGUSR1 -- send a SIGUSR1 signal to daemon
-
-COMMAND -- state
-----------------
-
-Show the current OpenVPN state, show state history, or
-enable real-time notification of state changes.
-
-These are the OpenVPN states:
-
-CONNECTING    -- OpenVPN's initial state.
-WAIT          -- (Client only) Waiting for initial response
-                 from server.
-AUTH          -- (Client only) Authenticating with server.
-GET_CONFIG    -- (Client only) Downloading configuration options
-                 from server.
-ASSIGN_IP     -- Assigning IP address to virtual network
-                 interface.
-ADD_ROUTES    -- Adding routes to system.
-CONNECTED     -- Initialization Sequence Completed.
-RECONNECTING  -- A restart has occurred.
-EXITING       -- A graceful exit is in progress.
-
-Command examples:
-
-  state        -- Print current OpenVPN state.
-  state on     -- Enable real-time notification of state changes.
-  state off    -- Disable real-time notification of state changes.
-  state all    -- Print current state history.
-  state 3      -- Print the 3 most recent state transitions.
-  state on all -- Atomically show state history while at the
-                  same time enable real-time state notification
-		  of future state transitions.
-
-The output format consists of 4 comma-separated parameters: 
-  (a) the integer unix date/time,
-  (b) the state name,
-  (c) optional descriptive string (used mostly on RECONNECTING
-      and EXITING to show the reason for the disconnect),
-  (d) optional TUN/TAP local IP address (shown for ASSIGN_IP
-      and CONNECTED), and
-  (e) optional address of remote server (OpenVPN 2.1 or higher).
-
-Real-time state notifications will have a ">STATE:" prefix
-prepended to them.
-
-COMMAND -- status
------------------
-
-Show current daemon status information, in the same format as
-that produced by the OpenVPN --status directive.
-
-Command examples:
-
-status   -- Show status information using the default status
-            format version.
-
-status 2 -- Show status information using status format version 2.
-
-COMMAND -- username
--------------------
-
-See the "password" section above.
-
-COMMAND -- verb
----------------
-
-Change the OpenVPN --verb parameter.  The verb parameter
-controls the output verbosity, and may range from 0 (no output)
-to 15 (maximum output).  See the OpenVPN man page for additional
-info on verbosity levels.
-
-Command examples:
-
-  verb 4  -- change the verb parameter to 4
-  mute    -- show the current verb setting
-
-COMMAND -- version
-------------------
-
-Show the current OpenVPN and Management Interface versions.
-
-
-COMMAND -- auth-retry
----------------------
-
-Set the --auth-retry setting to control how OpenVPN responds to
-username/password authentication errors.  See the manual page
-for more info.
-
-Command examples:
-
-  auth-retry interact -- Don't exit when bad username/passwords are entered.
-                         Query for new input and retry.
-
-COMMAND -- needok  (OpenVPN 2.1 or higher)
---------------------------------------
-
-Confirm a ">NEED-OK" real-time notification, normally used by
-OpenVPN to block while waiting for a specific user action.
-
-Example:
-
-  OpenVPN needs the user to insert a cryptographic token,
-  so it sends a real-time notification:
-
-    >NEED-OK:Need 'token-insertion-request' confirmation MSG:Please insert your cryptographic token
-
-  The management client, if it is a GUI, can flash a dialog
-  box containing the text after the "MSG:" marker to the user.
-  When the user acknowledges the dialog box,
-  the management client can issue this command:
-
-     needok token-insertion-request ok
-  or
-     needok token-insertion-request cancel
-
-OUTPUT FORMAT
--------------
-
-(1) Command success/failure indicated by "SUCCESS: [text]" or
-    "ERROR: [text]".
-
-(2) For commands which print multiple lines of output,
-    the last line will be "END".
-
-(3) Real-time messages will be in the form ">[source]:[text]",
-    where source is "ECHO", "FATAL", "HOLD", "INFO", "LOG",
-    "NEED-OK", "PASSWORD", or "STATE".
-
-REAL-TIME MESSAGE FORMAT
-------------------------
-
-The OpenVPN management interface produces two kinds of
-output: (a) output from a command, or (b) asynchronous,
-real-time output which can be generated at any time.
-
-Real-time messages start with a '>' character in the first
-column and are immediately followed by a type keyword
-indicating the type of real-time message.  The following
-types are currently defined:
-
-ECHO     -- Echo messages as controlled by the "echo" command.
-
-FATAL    -- A fatal error which is output to the log file just
-            prior to OpenVPN exiting.
-
-HOLD     -- Used to indicate that OpenVPN is in a holding state
-            and will not start until it receives a
-            "hold release" command.
-
-INFO     -- Informational messages such as the welcome message.
-
-LOG      -- Log message output as controlled by the "log" command.
-
-NEED-OK  -- OpenVPN needs the end user to do something, such as
-            insert a cryptographic token.  The "needok" command can
-            be used to tell OpenVPN to continue.
-
-PASSWORD -- Used to tell the management client that OpenVPN
-            needs a password, also to indicate password
-            verification failure.
-
-STATE    -- Shows the current OpenVPN state, as controlled
-            by the "state" command.
-
-Command Parsing
----------------
-
-The management interface uses the same command line lexical analyzer
-as is used by the OpenVPN config file parser.
-
-Whitespace is a parameter separator.
-
-Double  quotation characters ("") can be used to enclose
-parameters containing whitespace.
-
-Backslash-based shell escaping is performed, using the following
-mappings:
-
-\\       Maps to a single backslash character (\).
-\"       Pass a literal doublequote character ("), don't
-         interpret it as enclosing a parameter.
-\[SPACE] Pass a literal space or tab character, don't
-         interpret it as a parameter delimiter.
diff -urN openvpn-2.1_rc7/mbuf.c openvpn-2.1_rc9/mbuf.c
--- openvpn-2.1_rc7/mbuf.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mbuf.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if P2MP
diff -urN openvpn-2.1_rc7/mbuf.h openvpn-2.1_rc9/mbuf.h
--- openvpn-2.1_rc7/mbuf.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mbuf.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/memdbg.h openvpn-2.1_rc9/memdbg.h
--- openvpn-2.1_rc7/memdbg.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/memdbg.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -47,6 +47,8 @@
 
 #include "valgrind/memcheck.h"
 
+#define VALGRIND_MAKE_READABLE(addr, len)
+
 #else
 
 #define VALGRIND_MAKE_READABLE(addr, len)
diff -urN openvpn-2.1_rc7/misc.c openvpn-2.1_rc9/misc.c
--- openvpn-2.1_rc7/misc.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/misc.c	2008-07-27 02:38:22.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "buffer.h"
@@ -41,13 +35,17 @@
 #include "manage.h"
 #include "crypto.h"
 #include "route.h"
+#include "win32.h"
 
 #include "memdbg.h"
 
 #ifdef CONFIG_FEATURE_IPROUTE
-const char *iproute_path = IPROUTE_PATH;
+const char *iproute_path = IPROUTE_PATH; /* GLOBAL */
 #endif
 
+/* contains an SSEC_x value defined in misc.h */
+int script_security = SSEC_BUILT_IN; /* GLOBAL */
+
 /* Redefine the top level directory of the filesystem
    to restrict access to files for security */
 void
@@ -201,38 +199,36 @@
 
   if (plugin_defined (plugins, plugin_type))
     {
-      struct buffer cmd = alloc_buf_gc (256, &gc);
-
+      struct argv argv = argv_new ();
       ASSERT (arg);
+      argv_printf (&argv,
+		   "%s %d %d %s %s %s",
+		   arg,
+		   tun_mtu, link_mtu,
+		   ifconfig_local, ifconfig_remote,
+		   context);
 
-      buf_printf (&cmd,
-		  "%s %d %d %s %s %s",
-		  arg,
-		  tun_mtu, link_mtu,
-		  ifconfig_local, ifconfig_remote,
-		  context);
-
-      if (plugin_call (plugins, plugin_type, BSTR (&cmd), NULL, es))
+      if (plugin_call (plugins, plugin_type, &argv, NULL, es) != OPENVPN_PLUGIN_FUNC_SUCCESS)
 	msg (M_FATAL, "ERROR: up/down plugin call failed");
+
+      argv_reset (&argv);
     }
 
   if (command)
     {
-      struct buffer cmd = alloc_buf_gc (256, &gc);
-
+      struct argv argv = argv_new ();
       ASSERT (arg);
-
       setenv_str (es, "script_type", script_type);
-
-      buf_printf (&cmd,
+      argv_printf (&argv,
 		  "%s %s %d %d %s %s %s",
 		  command,
 		  arg,
 		  tun_mtu, link_mtu,
 		  ifconfig_local, ifconfig_remote,
 		  context);
-      msg (M_INFO, "%s", BSTR (&cmd));
-      system_check (BSTR (&cmd), es, S_SCRIPT|S_FATAL, "script failed");
+      argv_msg (M_INFO, &argv);
+      openvpn_execve_check (&argv, es, S_SCRIPT|S_FATAL, "script failed");
+      argv_reset (&argv);
     }
 
   gc_free (&gc);
@@ -380,64 +376,12 @@
 }
 
 /*
- * Wrapper around the system() call.
- */
-int
-openvpn_system (const char *command, const struct env_set *es, unsigned int flags)
-{
-#ifdef HAVE_SYSTEM
-  int ret;
-
-  /*
-   * We need to bracket this code by mutex because system() doesn't
-   * accept an environment list, so we have to use the process-wide
-   * list which is shared between all threads.
-   */
-  mutex_lock_static (L_SYSTEM);
-  perf_push (PERF_SCRIPT);
-
-  /*
-   * add env_set to environment.
-   */
-  if (flags & S_SCRIPT)
-    env_set_add_to_environment (es);
-
-
-  /* debugging */
-  dmsg (D_SCRIPT, "SYSTEM[%u] '%s'", flags, command);
-  if (flags & S_SCRIPT)
-    env_set_print (D_SCRIPT, es);
-
-  /*
-   * execute the command
-   */
-  ret = system (command);
-
-  /* debugging */
-  dmsg (D_SCRIPT, "SYSTEM return=%u", ret);
-
-  /*
-   * remove env_set from environment
-   */
-  if (flags & S_SCRIPT)
-    env_set_remove_from_environment (es);
-
-  perf_pop ();
-  mutex_unlock_static (L_SYSTEM);
-  return ret;
-
-#else
-  msg (M_FATAL, "Sorry but I can't execute the shell command '%s' because this operating system doesn't appear to support the system() call", command);
-  return -1; /* NOTREACHED */
-#endif
-}
-
-/*
  * Warn if a given file is group/others accessible.
  */
 void
 warn_if_group_others_accessible (const char* filename)
 {
+#ifndef WIN32
 #ifdef HAVE_STAT
 #if ENABLE_INLINE_FILES
   if (strcmp (filename, INLINE_FILE_TAG))
@@ -455,6 +399,7 @@
 	}
     }
 #endif
+#endif
 }
 
 /*
@@ -492,35 +437,35 @@
   struct buffer out = alloc_buf_gc (256, gc);
 #ifdef WIN32
   if (stat == -1)
-    buf_printf (&out, "shell command did not execute -- ");
-  buf_printf (&out, "system() returned error code %d", stat);
+    buf_printf (&out, "external program did not execute -- ");
+  buf_printf (&out, "returned error code %d", stat);
 #else
   if (stat == -1)
-    buf_printf (&out, "shell command fork failed");
+    buf_printf (&out, "external program fork failed");
   else if (!WIFEXITED (stat))
-    buf_printf (&out, "shell command did not exit normally");
+    buf_printf (&out, "external program did not exit normally");
   else
     {
       const int cmd_ret = WEXITSTATUS (stat);
       if (!cmd_ret)
-	buf_printf (&out, "shell command exited normally");
+	buf_printf (&out, "external program exited normally");
       else if (cmd_ret == 127)
-	buf_printf (&out, "could not execute shell command");
+	buf_printf (&out, "could not execute external program");
       else
-	buf_printf (&out, "shell command exited with error status: %d", cmd_ret);
+	buf_printf (&out, "external program exited with error status: %d", cmd_ret);
     }
 #endif
   return (const char *)out.data;
 }
 
 /*
- * Run system(), exiting on error.
+ * Wrapper around openvpn_execve
  */
 bool
-system_check (const char *command, const struct env_set *es, unsigned int flags, const char *error_message)
+openvpn_execve_check (const struct argv *a, const struct env_set *es, const unsigned int flags, const char *error_message)
 {
   struct gc_arena gc = gc_new ();
-  const int stat = openvpn_system (command, es, flags);
+  const int stat = openvpn_execve (a, es, flags);
   int ret = false;
 
   if (system_ok (stat))
@@ -536,6 +481,69 @@
   return ret;
 }
 
+bool
+openvpn_execve_allowed (const unsigned int flags)
+{
+  if (flags & S_SCRIPT)
+    return script_security >= SSEC_SCRIPTS;
+  else
+    return script_security >= SSEC_BUILT_IN;
+}
+
+#ifndef WIN32
+/*
+ * Run execve() inside a fork().  Designed to replicate the semantics of system() but
+ * in a safer way that doesn't require the invocation of a shell or the risks
+ * assocated with formatting and parsing a command line.
+ */
+int
+openvpn_execve (const struct argv *a, const struct env_set *es, const unsigned int flags)
+{
+  struct gc_arena gc = gc_new ();
+  int ret = -1;
+
+  if (a && a->argv[0])
+    {
+#if defined(ENABLE_EXECVE)
+      if (openvpn_execve_allowed (flags))
+	{
+	  const char *cmd = a->argv[0];
+	  char *const *argv = a->argv;
+	  char *const *envp = (char *const *)make_env_array (es, true, &gc);
+	  pid_t pid;
+
+	  pid = fork ();
+	  if (pid == (pid_t)0) /* child side */
+	    {
+	      execve (cmd, argv, envp);
+	      exit (127);
+	    }
+	  else if (pid < (pid_t)0) /* fork failed */
+	    ;
+	  else /* parent side */
+	    {
+	      if (waitpid (pid, &ret, 0) != pid)
+		ret = -1;
+	    }
+	}
+      else
+	{
+	  msg (M_WARN, "openvpn_execve: external program may not be called due to setting of --script-security level");
+	}
+#else
+      msg (M_WARN, "openvpn_execve: execve function not available");
+#endif
+    }
+  else
+    {
+      msg (M_WARN, "openvpn_execve: called with empty argv");
+    }
+
+  gc_free (&gc);
+  return ret;
+}
+#endif
+
 /*
  * Initialize random number seed.  random() is only used
  * when "weak" random numbers are acceptable.
@@ -773,7 +781,8 @@
 
 	  while (e)
 	    {
-	      msg (msglevel, "ENV [%d] '%s'", i, e->string);
+	      if (env_safe_to_print (e->string))
+		msg (msglevel, "ENV [%d] '%s'", i, e->string);
 	      ++i;
 	      e = e->next;
 	    }
@@ -904,9 +913,13 @@
 void
 setenv_str_safe (struct env_set *es, const char *name, const char *value)
 {
-  char buf[64];
-  openvpn_snprintf (buf, sizeof(buf), "OPENVPN_%s", name);
-  setenv_str (es, buf, value);
+  uint8_t b[64];
+  struct buffer buf;
+  buf_set_write (&buf, b, sizeof (b));
+  if (buf_printf (&buf, "OPENVPN_%s", name))
+    setenv_str (es, BSTR(&buf), value);
+  else
+    msg (M_WARN, "setenv_str_safe: name overflow");
 }
 
 void
@@ -944,6 +957,7 @@
 	{
 	  const char *str = construct_name_value (name_tmp, val_tmp, &gc);
 	  env_set_add (es, str);
+	  /*msg (M_INFO, "SETENV_ES '%s'", str);*/
 	}
       else
 	env_set_del (es, name_tmp);
@@ -979,6 +993,38 @@
 }
 
 /*
+ * Setenv functions that append an integer index to the name
+ */
+static const char *
+setenv_format_indexed_name (const char *name, const int i, struct gc_arena *gc)
+{
+  struct buffer out = alloc_buf_gc (strlen (name) + 16, gc);
+  if (i >= 0)
+    buf_printf (&out, "%s_%d", name, i);
+  else
+    buf_printf (&out, "%s", name);
+  return BSTR (&out);
+}
+
+void
+setenv_int_i (struct env_set *es, const char *name, const int value, const int i)
+{
+  struct gc_arena gc = gc_new ();
+  const char *name_str = setenv_format_indexed_name (name, i, &gc);
+  setenv_int (es, name_str, value);
+  gc_free (&gc);
+}
+
+void
+setenv_str_i (struct env_set *es, const char *name, const char *value, const int i)
+{
+  struct gc_arena gc = gc_new ();
+  const char *name_str = setenv_format_indexed_name (name, i, &gc);
+  setenv_str (es, name_str, value);
+  gc_free (&gc);
+}
+
+/*
  * taken from busybox networking/ifupdown.c
  */
 unsigned int
@@ -1055,9 +1101,11 @@
   return ret;
 }
 
+#ifdef USE_CRYPTO
+
 /* create a temporary filename in directory */
 const char *
-create_temp_filename (const char *directory, struct gc_arena *gc)
+create_temp_filename (const char *directory, const char *prefix, struct gc_arena *gc)
 {
   static unsigned int counter;
   struct buffer fname = alloc_buf_gc (256, gc);
@@ -1066,13 +1114,20 @@
   ++counter;
   mutex_unlock_static (L_CREATE_TEMP);
 
-  buf_printf (&fname, PACKAGE "_%u_%u.tmp",
-	      openvpn_getpid (),
-	      counter);
+  {
+    uint8_t rndbytes[16];
+    const char *rndstr;
+
+    prng_bytes (rndbytes, sizeof (rndbytes));
+    rndstr = format_hex_ex (rndbytes, sizeof (rndbytes), 40, 0, NULL, gc);
+    buf_printf (&fname, PACKAGE "_%s_%s.tmp", prefix, rndstr);
+  }
 
   return gen_path (directory, BSTR (&fname), gc);
 }
 
+#endif
+
 /*
  * Put a directory and filename together.
  */
@@ -1083,9 +1138,14 @@
 
   if (safe_filename
       && strcmp (safe_filename, ".")
-      && strcmp (safe_filename, ".."))
+      && strcmp (safe_filename, "..")
+#ifdef WIN32
+      && win_safe_filename (safe_filename)
+#endif
+      )
     {
-      struct buffer out = alloc_buf_gc (256, gc);
+      const size_t outsize = strlen(safe_filename) + (directory ? strlen (directory) : 0) + 16;
+      struct buffer out = alloc_buf_gc (outsize, gc);
       char dirsep[2];
 
       dirsep[0] = OS_SPECIFIC_DIRSEP;
@@ -1114,6 +1174,22 @@
 #endif
 }
 
+bool
+absolute_pathname (const char *pathname)
+{
+  if (pathname)
+    {
+      const int c = pathname[0];
+#ifdef WIN32
+      return c == '\\' || (isalpha(c) && pathname[1] == ':' && pathname[2] == '\\');
+#else
+      return c == '/';
+#endif
+    }
+  else
+    return false;
+}
+
 /*
  * Return the next largest power of 2
  * or u if u is a power of 2.
@@ -1230,7 +1306,7 @@
 	      if ((flags & GET_USER_PASS_NOFATAL) != 0)
 		return false;
 	      else
-		msg (M_FATAL, "ERROR: could not read %s username/password/ok from management interface", prefix);
+		msg (M_FATAL, "ERROR: could not read %s username/password/ok/string from management interface", prefix);
 	    }
 	}
       else
@@ -1404,6 +1480,10 @@
       CLEAR (*up);
       up->nocache = nocache;
     }
+  else
+    {
+      msg (M_WARN, "WARNING: this configuration may cache passwords in memory -- use the auth-nocache option to prevent this");
+    }
 }
 
 /*
@@ -1418,10 +1498,34 @@
   return string_mod_const (str, CC_PRINT, CC_CRLF, '.', gc);
 }
 
+static bool
+is_password_env_var (const char *str)
+{
+  return (strncmp (str, "password", 8) == 0);
+}
+
+bool
+env_allowed (const char *str)
+{
+  return (script_security >= SSEC_PW_ENV || !is_password_env_var (str));
+}
+
+bool
+env_safe_to_print (const char *str)
+{
+#ifndef UNSAFE_DEBUG
+  if (is_password_env_var (str))
+    return false;
+#endif
+  return true;
+}
+
 /* Make arrays of strings */
 
 const char **
-make_env_array (const struct env_set *es, struct gc_arena *gc)
+make_env_array (const struct env_set *es,
+		const bool check_allowed,
+		struct gc_arena *gc)
 {
   char **ret = NULL;
   struct env_item *e = NULL;
@@ -1440,12 +1544,14 @@
   /* fill return array */
   if (es)
     {
-      e = es->list;
-      for (i = 0; i < n; ++i)
+      i = 0;
+      for (e = es->list; e != NULL; e = e->next)
 	{
-	  ASSERT (e);
-	  ret[i] = e->string;
-	  e = e->next;
+	  if (!check_allowed || env_allowed (e->string))
+	    {
+	      ASSERT (i < n);
+	      ret[i++] = e->string;
+	    }
 	}
     }
 
@@ -1560,6 +1666,7 @@
   sleep (n);
 }
 
+#if 0
 /*
  * Configure PATH.  On Windows, sometimes PATH is not set correctly
  * by default.
@@ -1601,3 +1708,72 @@
     }
 #endif
 }
+#endif
+
+#ifdef ARGV_TEST
+void
+argv_test (void)
+{
+  struct gc_arena gc = gc_new ();
+  char line[512];
+  const char *s;
+
+  struct argv a;
+  argv_init (&a);
+
+#ifdef WIN32
+  argv_printf (&a, "%s foo bar %s", "c:\\src\\test\\jyargs.exe", "foo bar");
+  //argv_printf (&a, "%s %s %s", "c:\\src\\test files\\batargs.bat", "foo", "bar");  
+#else
+  argv_printf (&a, "./myechox foo bar");
+#endif
+
+  argv_msg_prefix (M_INFO, &a, "ARGV");
+  openvpn_execve_check (&a, NULL, 0, "command failed");
+
+  argv_printf (&a, "this is a %s test of int %d unsigned %u", "FOO", -69, 42);
+  s = argv_str (&a, &gc, PA_BRACKET);
+  printf ("%s\n", s);
+
+  {
+    struct argv b = argv_insert_head (&a, "MARK");
+    s = argv_str (&b, &gc, PA_BRACKET);
+    argv_reset (&b);
+    printf ("%s\n", s);
+  }
+
+  argv_printf (&a, "foo bar %d", 99);
+  s = argv_str (&a, &gc, PA_BRACKET);
+  argv_reset (&a);
+  printf ("%s\n", s);
+
+  s = argv_str (&a, &gc, PA_BRACKET);
+  argv_reset (&a);
+  printf ("%s\n", s);
+
+  argv_printf (&a, "foo bar %d", 99);
+  argv_printf_cat (&a, "bar %d foo", 42);
+  argv_printf_cat (&a, "cool %s %d u %s/%d end", "frood", 4, "hello", 7);
+  s = argv_str (&a, &gc, PA_BRACKET);
+  printf ("%s\n", s);
+
+#if 0
+  while (fgets (line, sizeof(line), stdin) != NULL)
+    {
+      char *term;
+      const char *f = line;
+      int i = 0;
+
+      while ((term = argv_term (&f)) != NULL) 
+	{
+	  printf ("[%d] '%s'\n", i, term);
+	  ++i;
+	  free (term);
+	}
+    }
+#endif
+
+  argv_reset (&a);
+  gc_free (&gc);
+}
+#endif
diff -urN openvpn-2.1_rc7/misc.h openvpn-2.1_rc9/misc.h
--- openvpn-2.1_rc7/misc.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/misc.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -117,17 +117,15 @@
 #define S_SCRIPT (1<<0)
 #define S_FATAL  (1<<1)
 
-/* wrapper around the system() call. */
-int openvpn_system (const char *command, const struct env_set *es, unsigned int flags);
-
-/* interpret the status code returned by system() */
+/* interpret the status code returned by system()/execve() */
 bool system_ok(int);
 int system_executed (int stat);
 const char *system_error_message (int, struct gc_arena *gc);
 
-/* run system() with error check, return true if success,
-   false if error, exit if error and fatal==true */
-bool system_check (const char *command, const struct env_set *es, unsigned int flags, const char *error_message);
+/* wrapper around the execve() call */
+int openvpn_execve (const struct argv *a, const struct env_set *es, const unsigned int flags);
+bool openvpn_execve_check (const struct argv *a, const struct env_set *es, const unsigned int flags, const char *error_message);
+bool openvpn_execve_allowed (const unsigned int flags);
 
 #ifdef HAVE_STRERROR
 /* a thread-safe version of strerror */
@@ -165,6 +163,9 @@
 void setenv_str_safe (struct env_set *es, const char *name, const char *value);
 void setenv_del (struct env_set *es, const char *name);
 
+void setenv_int_i (struct env_set *es, const char *name, const int value, const int i);
+void setenv_str_i (struct env_set *es, const char *name, const char *value, const int i);
+
 /* struct env_set functions */
 
 struct env_set *env_set_create (struct gc_arena *gc);
@@ -181,7 +182,10 @@
 
 /* Make arrays of strings */
 
-const char **make_env_array (const struct env_set *es, struct gc_arena *gc);
+const char **make_env_array (const struct env_set *es,
+			     const bool check_allowed,
+			     struct gc_arena *gc);
+
 const char **make_arg_array (const char *first, const char *parms, struct gc_arena *gc);
 const char **make_extended_arg_array (char **p, struct gc_arena *gc);
 
@@ -206,7 +210,7 @@
 bool test_file (const char *filename);
 
 /* create a temporary filename in directory */
-const char *create_temp_filename (const char *directory, struct gc_arena *gc);
+const char *create_temp_filename (const char *directory, const char *prefix, struct gc_arena *gc);
 
 /* put a directory and filename together */
 const char *gen_path (const char *directory, const char *filename, struct gc_arena *gc);
@@ -214,6 +218,9 @@
 /* delete a file, return true if succeeded */
 bool delete_file (const char *filename);
 
+/* return true if pathname is absolute */
+bool absolute_pathname (const char *pathname);
+
 /* return the next largest power of 2 */
 unsigned int adjust_power_of_2 (unsigned int u);
 
@@ -227,7 +234,11 @@
   bool nocache;
 
 /* max length of username/password */
-# define USER_PASS_LEN 128
+# ifdef ENABLE_PKCS11
+#   define USER_PASS_LEN 4096
+# else
+#   define USER_PASS_LEN 128
+# endif
   char username[USER_PASS_LEN];
   char password[USER_PASS_LEN];
 };
@@ -242,6 +253,7 @@
 #define GET_USER_PASS_PASSWORD_ONLY (1<<2)
 #define GET_USER_PASS_NEED_OK       (1<<3)
 #define GET_USER_PASS_NOFATAL       (1<<4)
+#define GET_USER_PASS_NEED_STR      (1<<5)
 
 bool get_user_pass (struct user_pass *up,
 		    const char *auth_file,
@@ -257,6 +269,12 @@
  */
 const char *safe_print (const char *str, struct gc_arena *gc);
 
+/* returns true if environmental variable safe to print to log */
+bool env_safe_to_print (const char *str);
+
+/* returns true if environmental variable may be passed to an external program */
+bool env_allowed (const char *str);
+
 /*
  * A sleep function that services the management layer for n
  * seconds rather than doing nothing.
@@ -276,4 +294,10 @@
 extern const char *iproute_path;
 #endif
 
+#define SSEC_NONE      0 /* strictly no calling of external programs */
+#define SSEC_BUILT_IN  1 /* only call built-in programs such as ifconfig, route, netsh, etc.*/
+#define SSEC_SCRIPTS   2 /* allow calling of built-in programs and user-defined scripts */
+#define SSEC_PW_ENV    3 /* allow calling of built-in programs and user-defined scripts that may receive a password as an environmental variable */
+extern int script_security; /* GLOBAL */
+
 #endif
diff -urN openvpn-2.1_rc7/mroute.c openvpn-2.1_rc9/mroute.c
--- openvpn-2.1_rc7/mroute.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mroute.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if P2MP_SERVER
@@ -82,87 +76,144 @@
   return not_all_zeros && not_all_ones && !is_mac_mcast_maddr (addr);
 }
 
-/*
- * Given a raw packet in buf, return the src and dest
- * addresses of the packet.
- */
+static inline void
+mroute_get_in_addr_t (struct mroute_addr *ma, const in_addr_t src, unsigned int mask)
+{
+  if (ma)
+    {
+      ma->type = MR_ADDR_IPV4 | mask;
+      ma->netbits = 0;
+      ma->len = 4;
+      *(in_addr_t*)ma->addr = src;
+    }
+}
+
+static inline bool
+mroute_is_mcast (const in_addr_t addr)
+{
+  return ((addr & htonl(IP_MCAST_SUBNET_MASK)) == htonl(IP_MCAST_NETWORK));
+}
+
+#ifdef ENABLE_PF
+
+static unsigned int
+mroute_extract_addr_arp (struct mroute_addr *src,
+			 struct mroute_addr *dest,
+			 const struct buffer *buf)
+{
+  unsigned int ret = 0;
+  if (BLEN (buf) >= (int) sizeof (struct openvpn_arp))
+    {
+      const struct openvpn_arp *arp = (const struct openvpn_arp *) BPTR (buf);
+      if (arp->mac_addr_type == htons(0x0001)
+	  && arp->proto_addr_type == htons(0x0800)
+	  && arp->mac_addr_size == 0x06
+	  && arp->proto_addr_size == 0x04)
+	{
+	  mroute_get_in_addr_t (src, arp->ip_src, MR_ARP);
+	  mroute_get_in_addr_t (dest, arp->ip_dest, MR_ARP);
+
+	  /* multicast packet? */
+	  if (mroute_is_mcast (arp->ip_dest))
+	    ret |= MROUTE_EXTRACT_MCAST;
+
+	  ret |= MROUTE_EXTRACT_SUCCEEDED;
+	}
+    }
+  return ret;
+}
+
+#endif
+
 unsigned int
-mroute_extract_addr_from_packet (struct mroute_addr *src,
-				 struct mroute_addr *dest,
-				 struct buffer *buf,
-				 int tunnel_type)
+mroute_extract_addr_ipv4 (struct mroute_addr *src,
+			  struct mroute_addr *dest,
+			  const struct buffer *buf)
 {
   unsigned int ret = 0;
-  verify_align_4 (buf);
-  if (tunnel_type == DEV_TYPE_TUN)
+  if (BLEN (buf) >= 1)
     {
-      if (BLEN (buf) >= 1)
+      switch (OPENVPN_IPH_GET_VER (*BPTR(buf)))
 	{
-	  switch (OPENVPN_IPH_GET_VER (*BPTR(buf)))
+	case 4:
+	  if (BLEN (buf) >= (int) sizeof (struct openvpn_iphdr))
 	    {
-	    case 4:
-	      if (BLEN (buf) >= (int) sizeof (struct openvpn_iphdr))
-		{
-		  const struct openvpn_iphdr *ip = (const struct openvpn_iphdr *) BPTR (buf);
-		  if (src)
-		    {
-		      src->type = MR_ADDR_IPV4;
-		      src->netbits = 0;
-		      src->len = 4;
-		      memcpy (src->addr, &ip->saddr, 4);
-		    }
-		  if (dest)
-		    {
-		      dest->type = MR_ADDR_IPV4;
-		      dest->netbits = 0;
-		      dest->len = 4;
-		      memcpy (dest->addr, &ip->daddr, 4);
-
-		      /* mcast address? */
-		      if ((ip->daddr & htonl(IP_MCAST_SUBNET_MASK)) == htonl(IP_MCAST_NETWORK))
-			ret |= MROUTE_EXTRACT_MCAST;
-
-		      /* IGMP message? */
-		      if (ip->protocol == OPENVPN_IPPROTO_IGMP)
-			ret |= MROUTE_EXTRACT_IGMP;
-		    }
-		  ret |= MROUTE_EXTRACT_SUCCEEDED;
-		}
-	      break;
-	    case 6:
-	      {
-		msg (M_WARN, "Need IPv6 code in mroute_extract_addr_from_packet"); 
-		break;
-	      }
+	      const struct openvpn_iphdr *ip = (const struct openvpn_iphdr *) BPTR (buf);
+
+	      mroute_get_in_addr_t (src, ip->saddr, 0);
+	      mroute_get_in_addr_t (dest, ip->daddr, 0);
+
+	      /* multicast packet? */
+	      if (mroute_is_mcast (ip->daddr))
+		ret |= MROUTE_EXTRACT_MCAST;
+
+	      /* IGMP message? */
+	      if (ip->protocol == OPENVPN_IPPROTO_IGMP)
+		ret |= MROUTE_EXTRACT_IGMP;
+
+	      ret |= MROUTE_EXTRACT_SUCCEEDED;
 	    }
+	  break;
+	case 6:
+	  {
+	    msg (M_WARN, "Need IPv6 code in mroute_extract_addr_from_packet"); 
+	    break;
+	  }
 	}
     }
-  else if (tunnel_type == DEV_TYPE_TAP)
+  return ret;
+}
+
+unsigned int
+mroute_extract_addr_ether (struct mroute_addr *src,
+			   struct mroute_addr *dest,
+			   struct mroute_addr *esrc,
+			   struct mroute_addr *edest,
+			   const struct buffer *buf)
+{
+  unsigned int ret = 0;
+  if (BLEN (buf) >= (int) sizeof (struct openvpn_ethhdr))
     {
-      if (BLEN (buf) >= (int) sizeof (struct openvpn_ethhdr))
+      const struct openvpn_ethhdr *eth = (const struct openvpn_ethhdr *) BPTR (buf);
+      if (src)
 	{
-	  const struct openvpn_ethhdr *eth = (const struct openvpn_ethhdr *) BPTR (buf);
-	  if (src)
-	    {
-	      src->type = MR_ADDR_ETHER;
-	      src->netbits = 0;
-	      src->len = 6;
-	      memcpy (src->addr, eth->source, 6);
-	    }
-	  if (dest)
+	  src->type = MR_ADDR_ETHER;
+	  src->netbits = 0;
+	  src->len = 6;
+	  memcpy (src->addr, eth->source, 6);
+	}
+      if (dest)
+	{
+	  dest->type = MR_ADDR_ETHER;
+	  dest->netbits = 0;
+	  dest->len = 6;
+	  memcpy (dest->addr, eth->dest, 6);
+
+	  /* ethernet broadcast/multicast packet? */
+	  if (is_mac_mcast_addr (eth->dest))
+	    ret |= MROUTE_EXTRACT_BCAST;
+	}
+	  
+      ret |= MROUTE_EXTRACT_SUCCEEDED;
+
+#ifdef ENABLE_PF
+      if (esrc || edest)
+	{
+	  struct buffer b = *buf;
+	  if (buf_advance (&b, sizeof (struct openvpn_ethhdr)))
 	    {
-	      dest->type = MR_ADDR_ETHER;
-	      dest->netbits = 0;
-	      dest->len = 6;
-	      memcpy (dest->addr, eth->dest, 6);
-
-	      /* ethernet broadcast/multicast packet? */
-	      if (is_mac_mcast_addr (eth->dest))
-		ret |= MROUTE_EXTRACT_BCAST;
+	      switch (ntohs (eth->proto))
+		{
+		case OPENVPN_ETH_P_IPV4:
+		  ret |= (mroute_extract_addr_ipv4 (esrc, edest, &b) << MROUTE_SEC_SHIFT);
+		  break;
+		case OPENVPN_ETH_P_ARP:
+		  ret |= (mroute_extract_addr_arp (esrc, edest, &b) << MROUTE_SEC_SHIFT);
+		  break;
+		}
 	    }
-	  
-	  ret |= MROUTE_EXTRACT_SUCCEEDED;
 	}
+#endif
     }
   return ret;
 }
@@ -235,6 +286,14 @@
 mroute_addr_print (const struct mroute_addr *ma,
 		   struct gc_arena *gc)
 {
+  return mroute_addr_print_ex (ma, MAPF_IA_EMPTY_IF_UNDEF, gc);
+}
+
+const char *
+mroute_addr_print_ex (const struct mroute_addr *ma,
+		      const unsigned int flags,
+		      struct gc_arena *gc)
+{
   struct buffer out = alloc_buf_gc (64, gc);
   if (ma)
     {
@@ -255,9 +314,19 @@
 	    addr = buf_read_u32 (&buf, &status);
 	    if (status)
 	      {
-		buf_printf (&out, "%s", print_in_addr_t (addr, IA_EMPTY_IF_UNDEF, gc));
+		if ((flags & MAPF_SHOW_ARP) && (maddr.type & MR_ARP))
+		  buf_printf (&out, "ARP/");
+		buf_printf (&out, "%s", print_in_addr_t (addr, (flags & MAPF_IA_EMPTY_IF_UNDEF) ? IA_EMPTY_IF_UNDEF : 0, gc));
 		if (maddr.type & MR_WITH_NETBITS)
-		  buf_printf (&out, "/%d", maddr.netbits);
+		  {
+		    if (flags & MAPF_SUBNET)
+		      {
+			const in_addr_t netmask = netbits_to_netmask (maddr.netbits);
+			buf_printf (&out, "/%s", print_in_addr_t (netmask, 0, gc));
+		      }
+		    else
+		      buf_printf (&out, "/%d", maddr.netbits);
+		  }
 	      }
 	    if (maddr.type & MR_WITH_PORT)
 	      {
diff -urN openvpn-2.1_rc7/mroute.h openvpn-2.1_rc9/mroute.h
--- openvpn-2.1_rc7/mroute.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mroute.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -35,10 +35,18 @@
 #define IP_MCAST_NETWORK      ((in_addr_t)224<<24)
 
 /* Return status values for mroute_extract_addr_from_packet */
-#define MROUTE_EXTRACT_SUCCEEDED (1<<1)
-#define MROUTE_EXTRACT_BCAST     (1<<2)
-#define MROUTE_EXTRACT_MCAST     (1<<3)
-#define MROUTE_EXTRACT_IGMP      (1<<4)
+
+#define MROUTE_EXTRACT_SUCCEEDED (1<<0)
+#define MROUTE_EXTRACT_BCAST     (1<<1)
+#define MROUTE_EXTRACT_MCAST     (1<<2)
+#define MROUTE_EXTRACT_IGMP      (1<<3)
+
+#define MROUTE_SEC_EXTRACT_SUCCEEDED (1<<(0+MROUTE_SEC_SHIFT))
+#define MROUTE_SEC_EXTRACT_BCAST     (1<<(1+MROUTE_SEC_SHIFT))
+#define MROUTE_SEC_EXTRACT_MCAST     (1<<(2+MROUTE_SEC_SHIFT))
+#define MROUTE_SEC_EXTRACT_IGMP      (1<<(3+MROUTE_SEC_SHIFT))
+
+#define MROUTE_SEC_SHIFT         4
 
 /*
  * Choose the largest address possible with
@@ -62,6 +70,9 @@
 /* Address type mask indicating that netbits is part of address */
 #define MR_WITH_NETBITS          8
 
+/* Indicates than IPv4 addr was extracted from ARP packet */
+#define MR_ARP                   16
+
 struct mroute_addr {
   uint8_t len;      /* length of address */
   uint8_t unused;
@@ -72,8 +83,7 @@
 };
 
 /*
- * Number of bits in an address.  Should be raised for
- * IPv6.
+ * Number of bits in an address.  Should be raised for IPv6.
  */
 #define MR_HELPER_NET_LEN 32
 
@@ -89,11 +99,6 @@
   int net_len_refcount[MR_HELPER_NET_LEN]; /* refcount of each netlength */
 };
 
-unsigned int mroute_extract_addr_from_packet (struct mroute_addr *src,
-					      struct mroute_addr *dest,
-					      struct buffer *buf,
-					      int tunnel_type);
-
 struct openvpn_sockaddr;
 
 bool mroute_extract_openvpn_sockaddr (struct mroute_addr *addr,
@@ -110,6 +115,13 @@
 const char *mroute_addr_print (const struct mroute_addr *ma,
 			       struct gc_arena *gc);
 
+#define MAPF_SUBNET            (1<<0)
+#define MAPF_IA_EMPTY_IF_UNDEF (1<<1)
+#define MAPF_SHOW_ARP          (1<<2)
+const char *mroute_addr_print_ex (const struct mroute_addr *ma,
+				  const unsigned int flags,
+				  struct gc_arena *gc);
+
 void mroute_addr_mask_host_bits (struct mroute_addr *ma);
 
 struct mroute_helper *mroute_helper_init (int ageable_ttl_secs);
@@ -117,6 +129,36 @@
 void mroute_helper_add_iroute (struct mroute_helper *mh, const struct iroute *ir);
 void mroute_helper_del_iroute (struct mroute_helper *mh, const struct iroute *ir);
 
+/*
+ * Given a raw packet in buf, return the src and dest
+ * addresses of the packet.
+ */
+static inline unsigned int
+mroute_extract_addr_from_packet (struct mroute_addr *src,
+				 struct mroute_addr *dest,
+				 struct mroute_addr *esrc,
+				 struct mroute_addr *edest,
+				 const struct buffer *buf,
+				 int tunnel_type)
+{
+  unsigned int mroute_extract_addr_ipv4 (struct mroute_addr *src,
+					 struct mroute_addr *dest,
+					 const struct buffer *buf);
+
+  unsigned int mroute_extract_addr_ether (struct mroute_addr *src,
+					  struct mroute_addr *dest,
+					  struct mroute_addr *esrc,
+					  struct mroute_addr *edest,
+					  const struct buffer *buf);
+  unsigned int ret = 0;
+  verify_align_4 (buf);
+  if (tunnel_type == DEV_TYPE_TUN)
+    ret = mroute_extract_addr_ipv4 (src, dest, buf);
+  else if (tunnel_type == DEV_TYPE_TAP)
+    ret = mroute_extract_addr_ether (src, dest, esrc, edest, buf);
+  return ret;
+}
+
 static inline void
 mroute_helper_lock (struct mroute_helper *mh)
 {
@@ -163,5 +205,21 @@
   *(in_addr_t*)dest->addr = htonl (src);
 }
 
+static inline in_addr_t
+in_addr_t_from_mroute_addr (const struct mroute_addr *addr)
+{
+  if ((addr->type & MR_ADDR_MASK) == MR_ADDR_IPV4 && addr->netbits == 0 && addr->len == 4)
+    return ntohl(*(in_addr_t*)addr->addr);
+  else
+    return 0;
+}
+
+static inline void
+mroute_addr_reset (struct mroute_addr *ma)
+{
+  ma->len = 0;
+  ma->type = MR_ADDR_NONE;
+}
+
 #endif /* P2MP_SERVER */
 #endif /* MROUTE_H */
diff -urN openvpn-2.1_rc7/mss.c openvpn-2.1_rc9/mss.c
--- openvpn-2.1_rc7/mss.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mss.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 #include "error.h"
 #include "mss.h"
diff -urN openvpn-2.1_rc7/mss.h openvpn-2.1_rc9/mss.h
--- openvpn-2.1_rc7/mss.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mss.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/mtcp.c openvpn-2.1_rc9/mtcp.c
--- openvpn-2.1_rc7/mtcp.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mtcp.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if P2MP_SERVER
diff -urN openvpn-2.1_rc7/mtcp.h openvpn-2.1_rc9/mtcp.h
--- openvpn-2.1_rc7/mtcp.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mtcp.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/mtu.c openvpn-2.1_rc9/mtu.c
--- openvpn-2.1_rc7/mtu.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mtu.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "common.h"
diff -urN openvpn-2.1_rc7/mtu.h openvpn-2.1_rc9/mtu.h
--- openvpn-2.1_rc7/mtu.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mtu.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/mudp.c openvpn-2.1_rc9/mudp.c
--- openvpn-2.1_rc7/mudp.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mudp.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if P2MP_SERVER
diff -urN openvpn-2.1_rc7/mudp.h openvpn-2.1_rc9/mudp.h
--- openvpn-2.1_rc7/mudp.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/mudp.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/multi.c openvpn-2.1_rc9/multi.c
--- openvpn-2.1_rc7/multi.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/multi.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if P2MP_SERVER
@@ -41,6 +35,7 @@
 #include "memdbg.h"
 
 #include "forward-inline.h"
+#include "pf-inline.h"
 
 /*#define MULTI_DEBUG_EVENT_LOOP*/
 
@@ -55,6 +50,16 @@
 }
 #endif
 
+#ifdef MANAGEMENT_DEF_AUTH
+static void
+set_cc_config (struct multi_instance *mi, struct buffer_list *cc_config)
+{
+  if (mi->cc_config)
+    buffer_list_free (mi->cc_config);
+  mi->cc_config = cc_config;
+}
+#endif
+
 static bool
 learn_address_script (const struct multi_context *m,
 		      const struct multi_instance *mi,
@@ -80,36 +85,33 @@
 
   if (plugin_defined (plugins, OPENVPN_PLUGIN_LEARN_ADDRESS))
     {
-      struct buffer cmd = alloc_buf_gc (256, &gc);
-
-      buf_printf (&cmd, "\"%s\" \"%s\"",
-		  op,
-		  mroute_addr_print (addr, &gc));
+      struct argv argv = argv_new ();
+      argv_printf (&argv, "%s %s",
+		   op,
+		   mroute_addr_print (addr, &gc));
       if (mi)
-	buf_printf (&cmd, " \"%s\"", tls_common_name (mi->context.c2.tls_multi, false));
-
-      if (plugin_call (plugins, OPENVPN_PLUGIN_LEARN_ADDRESS, BSTR (&cmd), NULL, es))
+	argv_printf_cat (&argv, "%s", tls_common_name (mi->context.c2.tls_multi, false));
+      if (plugin_call (plugins, OPENVPN_PLUGIN_LEARN_ADDRESS, &argv, NULL, es) != OPENVPN_PLUGIN_FUNC_SUCCESS)
 	{
 	  msg (M_WARN, "WARNING: learn-address plugin call failed");
 	  ret = false;
 	}
+      argv_reset (&argv);
     }
 
   if (m->top.options.learn_address_script)
     {
-      struct buffer cmd = alloc_buf_gc (256, &gc);
-
+      struct argv argv = argv_new ();
       setenv_str (es, "script_type", "learn-address");
-
-      buf_printf (&cmd, "%s \"%s\" \"%s\"",
-		  m->top.options.learn_address_script,
-		  op,
-		  mroute_addr_print (addr, &gc));
+      argv_printf (&argv, "%s %s %s",
+		   m->top.options.learn_address_script,
+		   op,
+		   mroute_addr_print (addr, &gc));
       if (mi)
-	buf_printf (&cmd, " \"%s\"", tls_common_name (mi->context.c2.tls_multi, false));
-
-      if (!system_check (BSTR (&cmd), es, S_SCRIPT, "WARNING: learn-address command failed"))
+	argv_printf_cat (&argv, "%s", tls_common_name (mi->context.c2.tls_multi, false));
+      if (!openvpn_execve_check (&argv, es, S_SCRIPT, "WARNING: learn-address command failed"))
 	ret = false;
+      argv_reset (&argv);
     }
 
   gc_free (&gc);
@@ -204,6 +206,25 @@
   return constrain_int (n_buckets / REAP_DIVISOR, REAP_MIN, REAP_MAX);
 }
 
+#ifdef MANAGEMENT_DEF_AUTH
+
+static uint32_t
+cid_hash_function (const void *key, uint32_t iv)
+{
+  const unsigned long *k = (const unsigned long *)key;
+  return (uint32_t) *k;
+}
+
+static bool
+cid_compare_function (const void *key1, const void *key2)
+{
+  const unsigned long *k1 = (const unsigned long *)key1;
+  const unsigned long *k2 = (const unsigned long *)key2;
+  return *k1 == *k2;
+}
+
+#endif
+
 /*
  * Main initialization function, init multi_context object.
  */
@@ -235,6 +256,7 @@
    * which is seen on the TCP/UDP socket.
    */
   m->hash = hash_init (t->options.real_hash_size,
+		       get_random (),
 		       mroute_addr_hash_function,
 		       mroute_addr_compare_function);
 
@@ -243,6 +265,7 @@
    * which client to route a packet to. 
    */
   m->vhash = hash_init (t->options.virtual_hash_size,
+			get_random (),
 			mroute_addr_hash_function,
 			mroute_addr_compare_function);
 
@@ -252,9 +275,17 @@
    * for fast iteration through the list.
    */
   m->iter = hash_init (1,
+		       get_random (),
 		       mroute_addr_hash_function,
 		       mroute_addr_compare_function);
 
+#ifdef MANAGEMENT_DEF_AUTH
+  m->cid_hash = hash_init (t->options.real_hash_size,
+			   0,
+			   cid_hash_function,
+			   cid_compare_function);
+#endif
+
   /*
    * This is our scheduler, for time-based wakeup
    * events.
@@ -379,6 +410,15 @@
   set_prefix (mi);
 }
 
+static const char *
+mi_prefix (const struct multi_instance *mi)
+{
+  if (mi && mi->msg_prefix)
+    return mi->msg_prefix;
+  else
+    return "UNDEF_I";
+}
+
 /*
  * Tell the route helper about deleted iroutes so
  * that it can update its mask of currently used
@@ -425,23 +465,23 @@
 
       if (plugin_defined (mi->context.plugins, OPENVPN_PLUGIN_CLIENT_DISCONNECT))
 	{
-	  if (plugin_call (mi->context.plugins, OPENVPN_PLUGIN_CLIENT_DISCONNECT, NULL, NULL, mi->context.c2.es))
+	  if (plugin_call (mi->context.plugins, OPENVPN_PLUGIN_CLIENT_DISCONNECT, NULL, NULL, mi->context.c2.es) != OPENVPN_PLUGIN_FUNC_SUCCESS)
 	    msg (M_WARN, "WARNING: client-disconnect plugin call failed");
 	}
 
       if (mi->context.options.client_disconnect_script)
 	{
-	  struct gc_arena gc = gc_new ();
-	  struct buffer cmd = alloc_buf_gc (256, &gc);
-
+	  struct argv argv = argv_new ();
 	  setenv_str (mi->context.c2.es, "script_type", "client-disconnect");
-	  
-	  buf_printf (&cmd, "%s", mi->context.options.client_disconnect_script);
+	  argv_printf (&argv, "%s", mi->context.options.client_disconnect_script);
+	  openvpn_execve_check (&argv, mi->context.c2.es, S_SCRIPT, "client-disconnect command failed");
+	  argv_reset (&argv);
+	}
+#ifdef MANAGEMENT_DEF_AUTH
+      if (management)
+	management_notify_client_close (management, &mi->context.c2.mda_context, mi->context.c2.es);
+#endif
 
-	  system_check (BSTR (&cmd), mi->context.c2.es, S_SCRIPT, "client-disconnect command failed");
-	  
-	  gc_free (&gc);
-	}
     }
 }
 
@@ -473,6 +513,12 @@
 	{
 	  ASSERT (hash_remove (m->iter, &mi->real));
 	}
+#ifdef MANAGEMENT_DEF_AUTH
+      if (mi->did_cid_hash)
+	{
+	  ASSERT (hash_remove (m->cid_hash, &mi->context.c2.mda_context.cid));
+	}
+#endif
 
       schedule_remove_entry (m->schedule, (struct schedule_entry *) mi);
 
@@ -490,6 +536,10 @@
       mbuf_dereference_instance (m->mbuf, mi);
     }
 
+#ifdef MANAGEMENT_DEF_AUTH
+  set_cc_config (mi, NULL);
+#endif
+
   multi_client_disconnect_script (m, mi);
 
   if (mi->did_open_context)
@@ -541,6 +591,9 @@
 	  hash_free (m->hash);
 	  hash_free (m->vhash);
 	  hash_free (m->iter);
+#ifdef MANAGEMENT_DEF_AUTH
+	  hash_free (m->cid_hash);
+#endif
 	  m->hash = NULL;
 
 	  schedule_free (m->schedule);
@@ -611,6 +664,13 @@
     }
   mi->did_iter = true;
 
+#ifdef MANAGEMENT_DEF_AUTH
+  do {
+    mi->context.c2.mda_context.cid = m->cid_counter++;
+  } while (!hash_add (m->cid_hash, &mi->context.c2.mda_context.cid, mi, false));
+  mi->did_cid_hash = true;
+#endif
+
   mi->context.c2.push_reply_deferred = true;
 
   if (!multi_process_post (m, mi, MPP_PRE_SELECT))
@@ -986,7 +1046,8 @@
 multi_learn_in_addr_t (struct multi_context *m,
 		       struct multi_instance *mi,
 		       in_addr_t a,
-		       int netbits) /* -1 if host route, otherwise # of network bits in address */
+		       int netbits, /* -1 if host route, otherwise # of network bits in address */
+		       bool primary)
 {
   struct openvpn_sockaddr remote_si;
   struct mroute_addr addr;
@@ -1001,7 +1062,15 @@
       addr.type |= MR_WITH_NETBITS;
       addr.netbits = (uint8_t) netbits;
     }
-  return multi_learn_addr (m, mi, &addr, 0);
+
+  {
+    struct multi_instance *owner = multi_learn_addr (m, mi, &addr, 0);
+#ifdef MANAGEMENT_DEF_AUTH
+    if (management && owner)
+      management_learn_addr (management, &mi->context.c2.mda_context, &addr, primary);
+#endif
+    return owner;
+  }
 }
 
 /*
@@ -1031,7 +1100,7 @@
 
 	  mroute_helper_add_iroute (m->route_helper, ir);
       
-	  multi_learn_in_addr_t (m, mi, ir->network, ir->netbits);
+	  multi_learn_in_addr_t (m, mi, ir->network, ir->netbits, false);
 	}
     }
   gc_free (&gc);
@@ -1258,7 +1327,7 @@
       for (i = 0; i < config.n; ++i)
 	{
 	  if (config.list[i] && config.list[i]->value)
-	    options_plugin_import (&mi->context.options,
+	    options_string_import (&mi->context.options,
 				   config.list[i]->value,
 				   D_IMPORT_ERRORS|M_OPTERR,
 				   option_permissions_mask,
@@ -1279,6 +1348,46 @@
 
 #endif
 
+#ifdef MANAGEMENT_DEF_AUTH
+
+/*
+ * Called to load management-derived client-connect config
+ */
+static void
+multi_client_connect_mda (struct multi_context *m,
+			  struct multi_instance *mi,
+			  const struct buffer_list *config,
+			  unsigned int option_permissions_mask,
+			  unsigned int *option_types_found)
+{
+  if (config)
+    {
+      struct buffer_entry *be;
+  
+      for (be = config->head; be != NULL; be = be->next)
+	{
+	  const char *opt = BSTR(&be->buf);
+	  options_string_import (&mi->context.options,
+				 opt,
+				 D_IMPORT_ERRORS|M_OPTERR,
+				 option_permissions_mask,
+				 option_types_found,
+				 mi->context.c2.es);
+	}
+
+      /*
+       * If the --client-connect script generates a config file
+       * with an --ifconfig-push directive, it will override any
+       * --ifconfig-push directive from the --client-config-dir
+       * directory or any --ifconfig-pool dynamic address.
+       */
+      multi_select_virtual_addr (m, mi);
+      multi_set_virtual_addr_env (m, mi);
+    }
+}
+
+#endif
+
 static void
 multi_client_connect_setenv (struct multi_context *m,
 			     struct multi_instance *mi)
@@ -1316,7 +1425,7 @@
 static void
 multi_connection_established (struct multi_context *m, struct multi_instance *mi)
 {
-  if (tls_authenticated (mi->context.c2.tls_multi))
+  if (tls_authentication_status (mi->context.c2.tls_multi, 0) == TLS_AUTHENTICATION_SUCCEEDED)
     {
       struct gc_arena gc = gc_new ();
       unsigned int option_types_found = 0;
@@ -1406,11 +1515,11 @@
       /* deprecated callback, use a file for passing back return info */
       if (plugin_defined (mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT))
 	{
-	  const char *dc_file = create_temp_filename (mi->context.options.tmp_dir, &gc);
-
+	  struct argv argv = argv_new ();
+	  const char *dc_file = create_temp_filename (mi->context.options.tmp_dir, "cc", &gc);
+	  argv_printf (&argv, "%s", dc_file);
 	  delete_file (dc_file);
-
-	  if (plugin_call (mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT, dc_file, NULL, mi->context.c2.es))
+	  if (plugin_call (mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT, &argv, NULL, mi->context.c2.es) != OPENVPN_PLUGIN_FUNC_SUCCESS)
 	    {
 	      msg (M_WARN, "WARNING: client-connect plugin call failed");
 	      cc_succeeded = false;
@@ -1420,6 +1529,7 @@
 	      multi_client_connect_post (m, mi, dc_file, option_permissions_mask, &option_types_found);
 	      ++cc_succeeded_count;
 	    }
+	  argv_reset (&argv);
 	}
 
       /* V2 callback, use a plugin_return struct for passing back return info */
@@ -1429,7 +1539,7 @@
 
 	  plugin_return_init (&pr);
 
-	  if (plugin_call (mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT_V2, NULL, &pr, mi->context.c2.es))
+	  if (plugin_call (mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT_V2, NULL, &pr, mi->context.c2.es) != OPENVPN_PLUGIN_FUNC_SUCCESS)
 	    {
 	      msg (M_WARN, "WARNING: client-connect-v2 plugin call failed");
 	      cc_succeeded = false;
@@ -1449,29 +1559,42 @@
        */
       if (mi->context.options.client_connect_script && cc_succeeded)
 	{
-	  struct buffer cmd = alloc_buf_gc (256, &gc);
+	  struct argv argv = argv_new ();
 	  const char *dc_file = NULL;
 
 	  setenv_str (mi->context.c2.es, "script_type", "client-connect");
 
-	  dc_file = create_temp_filename (mi->context.options.tmp_dir, &gc);
+	  dc_file = create_temp_filename (mi->context.options.tmp_dir, "cc", &gc);
 
 	  delete_file (dc_file);
 
-	  buf_printf (&cmd, "%s %s",
-		      mi->context.options.client_connect_script,
-		      dc_file);
+	  argv_printf (&argv, "%s %s",
+		       mi->context.options.client_connect_script,
+		       dc_file);
 
-	  if (system_check (BSTR (&cmd), mi->context.c2.es, S_SCRIPT, "client-connect command failed"))
+	  if (openvpn_execve_check (&argv, mi->context.c2.es, S_SCRIPT, "client-connect command failed"))
 	    {
 	      multi_client_connect_post (m, mi, dc_file, option_permissions_mask, &option_types_found);
 	      ++cc_succeeded_count;
 	    }
 	  else
 	    cc_succeeded = false;
+
+	  argv_reset (&argv);
 	}
 
       /*
+       * Check for client-connect script left by management interface client
+       */
+#ifdef MANAGEMENT_DEF_AUTH
+      if (cc_succeeded && mi->cc_config)
+	{
+	  multi_client_connect_mda (m, mi, mi->cc_config, option_permissions_mask, &option_types_found);
+	  ++cc_succeeded_count;
+	}
+#endif
+
+      /*
        * Check for "disable" directive in client-config-dir file
        * or config file generated by --client-connect script.
        */
@@ -1518,7 +1641,7 @@
 	    {
 	      if (mi->context.c2.push_ifconfig_defined)
 		{
-		  multi_learn_in_addr_t (m, mi, mi->context.c2.push_ifconfig_local, -1);
+		  multi_learn_in_addr_t (m, mi, mi->context.c2.push_ifconfig_local, -1, true);
 		  msg (D_MULTI_LOW, "MULTI: primary virtual IP for %s: %s",
 		       multi_instance_string (mi, false, &gc),
 		       print_in_addr_t (mi->context.c2.push_ifconfig_local, 0, &gc));
@@ -1556,6 +1679,11 @@
       /* set flag so we don't get called again */
       mi->connection_established_flag = true;
 
+#ifdef MANAGEMENT_DEF_AUTH
+      if (management)
+	management_connection_established (management, &mi->context.c2.mda_context);
+#endif
+
       gc_free (&gc);
     }
 
@@ -1609,10 +1737,11 @@
 /*
  * Broadcast a packet to all clients.
  */
-void
+static void
 multi_bcast (struct multi_context *m,
 	     const struct buffer *buf,
-	     struct multi_instance *omit)
+	     const struct multi_instance *sender_instance,
+	     const struct mroute_addr *sender_addr)
 {
   struct hash_iterator hi;
   struct hash_element *he;
@@ -1631,8 +1760,34 @@
       while ((he = hash_iterator_next (&hi)))
 	{
 	  mi = (struct multi_instance *) he->value;
-	  if (mi != omit && !mi->halt)
-	    multi_add_mbuf (m, mi, mb);
+	  if (mi != sender_instance && !mi->halt)
+	    {
+#ifdef ENABLE_PF
+	      if (sender_instance)
+		{
+		  if (!pf_c2c_test (&sender_instance->context, &mi->context, "bcast_c2c"))
+		    {
+		      msg (D_PF_DROPPED_BCAST, "PF: client[%s] -> client[%s] packet dropped by BCAST packet filter",
+			   mi_prefix (sender_instance),
+			   mi_prefix (mi));
+		      continue;
+		    }
+		}
+	      if (sender_addr)
+		{
+		  if (!pf_addr_test (&mi->context, sender_addr, "bcast_src_addr"))
+		    {
+		      struct gc_arena gc = gc_new ();
+		      msg (D_PF_DROPPED_BCAST, "PF: addr[%s] -> client[%s] packet dropped by BCAST packet filter",
+			   mroute_addr_print_ex (sender_addr, MAPF_SHOW_ARP, &gc),
+			   mi_prefix (mi));
+		      gc_free (&gc);
+		      continue;
+		    }
+		}
+#endif
+	      multi_add_mbuf (m, mi, mb);
+	    }
 	}
 
       hash_iterator_free (&hi);
@@ -1792,6 +1947,8 @@
 	      /* extract packet source and dest addresses */
 	      mroute_flags = mroute_extract_addr_from_packet (&src,
 							      &dest,
+							      NULL,
+							      NULL,
 							      &c->c2.to_tun,
 							      DEV_TYPE_TUN);
 
@@ -1814,7 +1971,7 @@
 		  if (mroute_flags & MROUTE_EXTRACT_MCAST)
 		    {
 		      /* for now, treat multicast as broadcast */
-		      multi_bcast (m, &c->c2.to_tun, m->pending);
+		      multi_bcast (m, &c->c2.to_tun, m->pending, NULL);
 		    }
 		  else /* possible client to client routing */
 		    {
@@ -1824,18 +1981,46 @@
 		      /* if dest addr is a known client, route to it */
 		      if (mi)
 			{
-			  multi_unicast (m, &c->c2.to_tun, mi);
-			  register_activity (c, BLEN(&c->c2.to_tun));
+#ifdef ENABLE_PF
+			  if (!pf_c2c_test (c, &mi->context, "tun_c2c"))
+			    {
+			      msg (D_PF_DROPPED, "PF: client -> client[%s] packet dropped by TUN packet filter",
+				   mi_prefix (mi));
+			    }
+			  else
+#endif
+			    {
+			      multi_unicast (m, &c->c2.to_tun, mi);
+			      register_activity (c, BLEN(&c->c2.to_tun));
+			    }
 			  c->c2.to_tun.len = 0;
 			}
 		    }
 		}
+#ifdef ENABLE_PF
+	      if (c->c2.to_tun.len && !pf_addr_test (c, &dest, "tun_dest_addr"))
+		{
+		  msg (D_PF_DROPPED, "PF: client -> addr[%s] packet dropped by TUN packet filter",
+		       mroute_addr_print_ex (&dest, MAPF_SHOW_ARP, &gc));
+		  c->c2.to_tun.len = 0;
+		}
+#endif
 	    }
 	  else if (TUNNEL_TYPE (m->top.c1.tuntap) == DEV_TYPE_TAP)
 	    {
+#ifdef ENABLE_PF
+	      struct mroute_addr edest;
+	      mroute_addr_reset (&edest);
+#endif
 	      /* extract packet source and dest addresses */
 	      mroute_flags = mroute_extract_addr_from_packet (&src,
 							      &dest,
+							      NULL,
+#ifdef ENABLE_PF
+							      &edest,
+#else
+							      NULL,
+#endif
 							      &c->c2.to_tun,
 							      DEV_TYPE_TAP);
 
@@ -1848,7 +2033,7 @@
 			{
 			  if (mroute_flags & (MROUTE_EXTRACT_BCAST|MROUTE_EXTRACT_MCAST))
 			    {
-			      multi_bcast (m, &c->c2.to_tun, m->pending);
+			      multi_bcast (m, &c->c2.to_tun, m->pending, NULL);
 			    }
 			  else /* try client-to-client routing */
 			    {
@@ -1857,12 +2042,30 @@
 			      /* if dest addr is a known client, route to it */
 			      if (mi)
 				{
-				  multi_unicast (m, &c->c2.to_tun, mi);
-				  register_activity (c, BLEN(&c->c2.to_tun));
+#ifdef ENABLE_PF
+				  if (!pf_c2c_test (c, &mi->context, "tap_c2c"))
+				    {
+				      msg (D_PF_DROPPED, "PF: client -> client[%s] packet dropped by TAP packet filter",
+					   mi_prefix (mi));
+				    }
+				  else
+#endif
+				    {
+				      multi_unicast (m, &c->c2.to_tun, mi);
+				      register_activity (c, BLEN(&c->c2.to_tun));
+				    }
 				  c->c2.to_tun.len = 0;
 				}
 			    }
 			}
+#ifdef ENABLE_PF
+		      if (c->c2.to_tun.len && !pf_addr_test (c, &edest, "tap_dest_addr"))
+			{
+			  msg (D_PF_DROPPED, "PF: client -> addr[%s] packet dropped by TAP packet filter",
+			       mroute_addr_print_ex (&edest, MAPF_SHOW_ARP, &gc));
+			  c->c2.to_tun.len = 0;
+			}
+#endif
 		    }
 		  else
 		    {
@@ -1904,6 +2107,20 @@
       struct mroute_addr src, dest;
       const int dev_type = TUNNEL_TYPE (m->top.c1.tuntap);
 
+#ifdef ENABLE_PF
+      struct mroute_addr esrc, *e1, *e2;
+      if (dev_type == DEV_TYPE_TUN)
+	{
+	  e1 = NULL;
+	  e2 = &src;
+	}
+      else
+	{
+	  e1 = e2 = &esrc;
+	  mroute_addr_reset (&esrc);
+	}
+#endif
+
 #ifdef MULTI_DEBUG_EVENT_LOOP
       printf ("TUN -> TCP/UDP [%d]\n", BLEN (&m->top.c2.buf));
 #endif
@@ -1918,6 +2135,12 @@
 
       mroute_flags = mroute_extract_addr_from_packet (&src,
 						      &dest,
+#ifdef ENABLE_PF
+						      e1,
+#else
+						      NULL,
+#endif
+						      NULL,
 						      &m->top.c2.buf,
 						      dev_type);
 
@@ -1929,7 +2152,11 @@
 	  if (mroute_flags & (MROUTE_EXTRACT_BCAST|MROUTE_EXTRACT_MCAST))
 	    {
 	      /* for now, treat multicast as broadcast */
-	      multi_bcast (m, &m->top.c2.buf, NULL);
+#ifdef ENABLE_PF
+	      multi_bcast (m, &m->top.c2.buf, NULL, e2);
+#else
+	      multi_bcast (m, &m->top.c2.buf, NULL, NULL);
+#endif
 	    }
 	  else
 	    {
@@ -1942,17 +2169,28 @@
 		  
 		  set_prefix (m->pending);
 
-		  if (multi_output_queue_ready (m, m->pending))
+#ifdef ENABLE_PF
+		  if (!pf_addr_test (c, e2, "tun_tap_src_addr"))
 		    {
-		      /* transfer packet pointer from top-level context buffer to instance */
-		      c->c2.buf = m->top.c2.buf;
+		      msg (D_PF_DROPPED, "PF: addr[%s] -> client packet dropped by packet filter",
+			   mroute_addr_print_ex (&src, MAPF_SHOW_ARP, &gc));
+		      buf_reset_len (&c->c2.buf);
 		    }
 		  else
-		    {
-		      /* drop packet */
-		      msg (D_MULTI_DROPPED, "MULTI: packet dropped due to output saturation (multi_process_incoming_tun)");
-		      buf_clear (&c->c2.buf);
-		    }
+#endif
+		  {
+		    if (multi_output_queue_ready (m, m->pending))
+		      {
+			/* transfer packet pointer from top-level context buffer to instance */
+			c->c2.buf = m->top.c2.buf;
+		      }
+		    else
+		      {
+			/* drop packet */
+			msg (D_MULTI_DROPPED, "MULTI: packet dropped due to output saturation (multi_process_incoming_tun)");
+			buf_reset_len (&c->c2.buf);
+		      }
+		  }
 	      
 		  /* encrypt in instance context */
 		  process_incoming_tun (c);
@@ -2086,7 +2324,7 @@
 	ASSERT (buf_write_u8 (&buf, get_random () & 0xFF));
 
       for (i = 0; i < parm.n_packets; ++i)
-	multi_bcast (m, &buf, NULL);
+	multi_bcast (m, &buf, NULL, NULL);
 
       gc_free (&gc);
     }
@@ -2256,6 +2494,86 @@
 
 #endif
 
+#ifdef MANAGEMENT_DEF_AUTH
+
+static struct multi_instance *
+lookup_by_cid (struct multi_context *m, const unsigned long cid)
+{
+  if (m)
+    {
+      struct multi_instance *mi = (struct multi_instance *) hash_lookup (m->cid_hash, &cid);
+      if (mi && !mi->halt)
+	return mi;
+    }
+  return NULL;
+}
+
+static bool
+management_kill_by_cid (void *arg, const unsigned long cid)
+{
+  struct multi_context *m = (struct multi_context *) arg;
+  struct multi_instance *mi = lookup_by_cid (m, cid);
+  if (mi)
+    {
+      multi_signal_instance (m, mi, SIGTERM);
+      return true;
+    }
+  else
+    return false;
+}
+
+static bool
+management_client_auth (void *arg,
+			const unsigned long cid,
+			const unsigned int mda_key_id,
+			const bool auth,
+			const char *reason,
+			struct buffer_list *cc_config) /* ownership transferred */
+{
+  struct multi_context *m = (struct multi_context *) arg;
+  struct multi_instance *mi = lookup_by_cid (m, cid);
+  bool cc_config_owned = true;
+  bool ret = false;
+
+  if (mi)
+    {
+      ret = tls_authenticate_key (mi->context.c2.tls_multi, mda_key_id, auth);
+      if (ret)
+	{
+	  if (auth && !mi->connection_established_flag)
+	    {
+	      set_cc_config (mi, cc_config);
+	      cc_config_owned = false;
+	    }
+	  if (!auth && reason)
+	    msg (D_MULTI_LOW, "MULTI: connection rejected: %s", reason);
+	}
+    }
+  if (cc_config_owned && cc_config)
+    buffer_list_free (cc_config);
+  return ret;
+}
+#endif
+
+#ifdef MANAGEMENT_PF
+static bool
+management_client_pf (void *arg,
+		      const unsigned long cid,
+		      struct buffer_list *pf_config) /* ownership transferred */
+{
+  struct multi_context *m = (struct multi_context *) arg;
+  struct multi_instance *mi = lookup_by_cid (m, cid);
+  bool ret = false;
+
+  if (mi && pf_config)
+    ret = pf_load_from_buffer_list (&mi->context, pf_config);
+
+  if (pf_config)
+    buffer_list_free (pf_config);
+  return ret;
+}
+#endif
+
 void
 init_management_callback_multi (struct multi_context *m)
 {
@@ -2270,6 +2588,13 @@
       cb.kill_by_cn = management_callback_kill_by_cn;
       cb.kill_by_addr = management_callback_kill_by_addr;
       cb.delete_event = management_delete_event;
+#ifdef MANAGEMENT_DEF_AUTH
+      cb.kill_by_cid = management_kill_by_cid;
+      cb.client_auth = management_client_auth;
+#endif
+#ifdef MANAGEMENT_PF
+      cb.client_pf = management_client_pf;
+#endif
       management_set_callback (management, &cb);
     }
 #endif
@@ -2289,7 +2614,7 @@
 {
   ASSERT (top->options.mode == MODE_SERVER);
 
-  switch (top->options.proto) {
+  switch (top->options.ce.proto) {
   case PROTO_UDPv4:
     tunnel_server_udp (top);
     break;
diff -urN openvpn-2.1_rc7/multi.h openvpn-2.1_rc9/multi.h
--- openvpn-2.1_rc7/multi.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/multi.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -77,6 +77,10 @@
   bool did_open_context;
   bool did_real_hash;
   bool did_iter;
+#ifdef MANAGEMENT_DEF_AUTH
+  bool did_cid_hash;
+  struct buffer_list *cc_config;
+#endif
   bool connection_established_flag;
   bool did_iroutes;
 
@@ -111,6 +115,11 @@
   int tcp_queue_limit;
   int status_file_version;
 
+#ifdef MANAGEMENT_DEF_AUTH
+  struct hash *cid_hash;
+  unsigned long cid_counter;
+#endif
+
   struct multi_instance *pending;
   struct multi_instance *earliest_wakeup;
   struct multi_instance **mpp_touched;
@@ -143,10 +152,6 @@
 
 const char *multi_instance_string (const struct multi_instance *mi, bool null, struct gc_arena *gc);
 
-void multi_bcast (struct multi_context *m,
-		  const struct buffer *buf,
-		  struct multi_instance *omit);
-
 /*
  * Called by mtcp.c, mudp.c, or other (to be written) protocol drivers
  */
diff -urN openvpn-2.1_rc7/ntlm.c openvpn-2.1_rc9/ntlm.c
--- openvpn-2.1_rc7/ntlm.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/ntlm.c	2008-07-26 08:18:08.000000000 +0200
@@ -3,6 +3,8 @@
  *
  *  Copyright (C) 2004 William Preston
  *
+ *  *NTLMv2 support and domain name parsing by Miroslav Zajic, Nextsoft s.r.o.*
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
@@ -19,12 +21,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if NTLM
@@ -41,6 +37,21 @@
 
 #include "memdbg.h"
 
+
+/* 64bit datatype macros */
+#ifdef _MSC_VER 
+	/* MS compilers */
+#	define UINTEGER64 __int64
+#	define UINT64(c) c ## Ui64
+#else 
+	/* Non MS compilers */
+#	define UINTEGER64 unsigned long long
+#	define UINT64(c) c ## LL
+#endif
+
+
+
+
 static void
 create_des_keys(const unsigned char *hash, unsigned char *key)
 {
@@ -70,6 +81,61 @@
   memcpy (result, md, 16);
 }
 
+static void
+gen_hmac_md5 (const char* data, int data_len, const char* key, int key_len,char *result)
+{
+	unsigned int len;
+
+	HMAC_CTX c;
+	HMAC_Init (&c, key, key_len, EVP_md5());
+	HMAC_Update (&c, (const unsigned char *)data, data_len);
+	HMAC_Final (&c, (unsigned char *)result, &len);
+	HMAC_CTX_cleanup(&c);
+}
+
+static void
+gen_timestamp (unsigned char *timestamp)
+{ 
+	/* Copies 8 bytes long timestamp into "timestamp" buffer. 
+	 * Timestamp is Little-endian, 64-bit signed value representing the number of tenths of a microsecond since January 1, 1601.
+	 */
+
+	UINTEGER64 timestamp_ull;
+
+	timestamp_ull = openvpn_time(NULL);
+	timestamp_ull = (timestamp_ull + UINT64(11644473600)) * UINT64(10000000);
+
+	/* store little endian value */
+	timestamp[0]= timestamp_ull & UINT64(0xFF);
+	timestamp[1]= (timestamp_ull  >> 8)  & UINT64(0xFF);
+	timestamp[2]= (timestamp_ull  >> 16) & UINT64(0xFF);
+	timestamp[3]= (timestamp_ull  >> 24) & UINT64(0xFF);
+	timestamp[4]= (timestamp_ull  >> 32) & UINT64(0xFF);
+	timestamp[5]= (timestamp_ull  >> 40) & UINT64(0xFF);
+	timestamp[6]= (timestamp_ull  >> 48) & UINT64(0xFF);
+	timestamp[7]= (timestamp_ull  >> 56) & UINT64(0xFF);
+}
+
+static void
+gen_nonce (unsigned char *nonce)
+{ 
+	/* Generates 8 random bytes to be used as client nonce */
+	int i;
+
+	for(i=0;i<8;i++){
+		nonce[i] = (unsigned char)get_random();
+	}
+}
+
+unsigned char *my_strupr(unsigned char *str)
+{ 
+	/* converts string to uppercase in place */
+	unsigned char *tmp = str;;
+
+	do *str = toupper(*str); while (*(++str));
+	return tmp;
+}
+
 static int
 unicodize (char *dst, const char *src)
 {
@@ -85,6 +151,18 @@
   return i;
 }
 
+static void
+add_security_buffer(int sb_offset, void *data, int length, unsigned char *msg_buf, int *msg_bufpos)
+{
+	/* Adds security buffer data to a message and sets security buffer's offset and length */
+	msg_buf[sb_offset] = (unsigned char)length;
+	msg_buf[sb_offset + 2] = msg_buf[sb_offset];
+	msg_buf[sb_offset + 4] = (unsigned char)(*msg_bufpos & 0xff);
+	msg_buf[sb_offset + 5] = (unsigned char)((*msg_bufpos >> 8) & 0xff);
+	memcpy(&msg_buf[*msg_bufpos], data, msg_buf[sb_offset]);
+	*msg_bufpos += length;
+}
+
 const char *
 ntlm_phase_1 (const struct http_proxy_info *p, struct gc_arena *gc)
 {
@@ -105,23 +183,58 @@
 const char *
 ntlm_phase_3 (const struct http_proxy_info *p, const char *phase_2, struct gc_arena *gc)
 {
+	/* NTLM handshake
+	 *
+	 * http://davenport.sourceforge.net/ntlm.html
+	 *
+	 */
+	
   char pwbuf[sizeof (p->up.password) * 2]; /* for unicode password */
   char buf2[128]; /* decoded reply from proxy */
-  char phase3[146];
+  unsigned char phase3[464];
 
   char md4_hash[21];
-  char challenge[8], response[24];
-  int i, ret_val, buflen;
+  char challenge[8], ntlm_response[24];
+  int i, ret_val;
   des_cblock key1, key2, key3;
   des_key_schedule sched1, sched2, sched3;
 
-  /* try a minimal NTLM handshake
-   *
-   * http://davenport.sourceforge.net/ntlm.html
-   *
-   */
+	char ntlmv2_response[144];
+	char userdomain_u[256]; /* for uppercase unicode username and domain */
+	char userdomain[128];   /* the same as previous but ascii */
+	char ntlmv2_hash[16];
+	char ntlmv2_hmacmd5[16];
+	char *ntlmv2_blob = ntlmv2_response + 16; /* inside ntlmv2_response, length: 128 */
+	int ntlmv2_blob_size=0;
+	int phase3_bufpos = 0x40; /* offset to next security buffer data to be added */
+	int len;
+
+	char domain[128];
+	char username[128];
+	char *separator;
+
+	bool ntlmv2_enabled = (p->auth_method == HTTP_AUTH_NTLM2);
+
+  CLEAR (buf2);
+
   ASSERT (strlen (p->up.username) > 0);
   ASSERT (strlen (p->up.password) > 0);
+	
+	/* username parsing */
+	separator = strchr(p->up.username, '\\');
+	if (separator == NULL) {
+		strncpy(username, p->up.username, sizeof(username)-1);
+		username[sizeof(username)-1]=0;
+		domain[0]=0;
+	} else {
+		strncpy(username, separator+1, sizeof(username)-1);
+		username[sizeof(username)-1]=0;
+		len = separator - p->up.username;
+		if (len > sizeof(domain) - 1) len = sizeof(domain) - 1;
+		strncpy(domain, p->up.username,  len);
+		domain[len]=0;
+	}
+
 
   /* fill 1st 16 bytes with md4 hash, disregard terminating null */
   gen_md4_hash (pwbuf, unicodize (pwbuf, p->up.password) - 2, md4_hash);
@@ -130,6 +243,9 @@
   memset (md4_hash + 16, 0, 5);
 
   ret_val = base64_decode( phase_2, (void *)buf2);
+  if (ret_val < 0)
+    return NULL;
+
   /* we can be sure that phase_2 is less than 128
    * therefore buf2 needs to be (3/4 * 128) */
 
@@ -139,48 +255,95 @@
     challenge[i] = buf2[i+24];
   }
 
-  create_des_keys ((unsigned char *)md4_hash, key1);
-  des_set_key_unchecked ((des_cblock *)key1, sched1);
-  des_ecb_encrypt ((des_cblock *)challenge, (des_cblock *)response, sched1, DES_ENCRYPT);
-
-  create_des_keys ((unsigned char *)&(md4_hash[7]), key2);
-  des_set_key_unchecked ((des_cblock *)key2, sched2);
-  des_ecb_encrypt ((des_cblock *)challenge, (des_cblock *)&(response[8]), sched2, DES_ENCRYPT);
-
-  create_des_keys ((unsigned char *)&(md4_hash[14]), key3);
-  des_set_key_unchecked ((des_cblock *)key3, sched3);
-  des_ecb_encrypt ((des_cblock *)challenge, (des_cblock *)&(response[16]), sched3, DES_ENCRYPT);
-
-  /* clear reply */
-  memset (phase3, 0, sizeof (phase3));
-
-  strcpy (phase3, "NTLMSSP\0");
-  phase3[8] = 3; /* type 3 */
-
-  buflen = 0x58 + strlen (p->up.username);
-  if (buflen > (int) sizeof (phase3))
-    buflen = sizeof (phase3);
-
-  phase3[0x10] = buflen; /* lm not used */
-  phase3[0x20] = buflen; /* default domain (i.e. proxy's domain) */
-  phase3[0x30] = buflen; /* no workstation name supplied */
-  phase3[0x38] = buflen; /* no session key */
-
-  phase3[0x14] = 24; /* ntlm response is 24 bytes long */
-  phase3[0x16] = phase3[0x14];
-  phase3[0x18] = 0x40; /* ntlm offset */
-  memcpy (&(phase3[0x40]), response, 24);
-
-
-  phase3[0x24] = strlen (p->up.username); /* username in ascii */
-  phase3[0x26] = phase3[0x24];
-  phase3[0x28] = 0x58;
-  strncpy (&(phase3[0x58]), p->up.username, sizeof (phase3) - 0x58);
-
+	if (ntlmv2_enabled){ /* Generate NTLMv2 response */
+		
+		/* NTLMv2 hash */
+	        my_strupr((unsigned char *)strcpy(userdomain, username));
+		if (strlen(username) + strlen(domain) < sizeof(userdomain))
+			strcat(userdomain, domain);
+		else
+			msg (M_INFO, "Warning: Username or domain too long");
+		unicodize (userdomain_u, userdomain);
+		gen_hmac_md5(userdomain_u, 2 * strlen(userdomain), md4_hash, 16, ntlmv2_hash);
+
+		/* NTLMv2 Blob */
+		memset(ntlmv2_blob, 0, 128);                /* Clear blob buffer */ 
+		ntlmv2_blob[0x00]=1;                        /* Signature */
+		ntlmv2_blob[0x01]=1;                        /* Signature */
+		ntlmv2_blob[0x04]=0;                        /* Reserved */
+		gen_timestamp((unsigned char *)&ntlmv2_blob[0x08]);          /* 64-bit Timestamp */
+		gen_nonce((unsigned char *)&ntlmv2_blob[0x10]);              /* 64-bit Client Nonce */
+		ntlmv2_blob[0x18]=0;                        /* Unknown, zero should work */
+
+		/* Add target information block to the blob */
+		int tib_len;
+		if (( *((long *)&buf2[0x14]) & 0x00800000) == 0x00800000){ /* Check for Target Information block */
+			tib_len = buf2[0x28];/* Get Target Information block size */
+			if (tib_len > 96) tib_len = 96;
+			char *tib_ptr = buf2 + buf2[0x2c]; /* Get Target Information block pointer */
+			memcpy(&ntlmv2_blob[0x1c], tib_ptr, tib_len); /* Copy Target Information block into the blob */
+		} else {
+			tib_len = 0;
+		}
+
+		ntlmv2_blob[0x1c + tib_len] = 0;            /* Unknown, zero works */ 
+
+		/* Get blob length */
+		ntlmv2_blob_size = 0x20 + tib_len; 
+
+		/* Add challenge from message 2 */
+		memcpy(&ntlmv2_response[8], challenge, 8);
+
+		/* hmac-md5 */
+		gen_hmac_md5(&ntlmv2_response[8], ntlmv2_blob_size + 8, ntlmv2_hash, 16, ntlmv2_hmacmd5);
+		
+		/* Add hmac-md5 result to the blob */
+		memcpy(ntlmv2_response, ntlmv2_hmacmd5, 16); /* Note: This overwrites challenge previously written at ntlmv2_response[8..15] */
+	
+	} else { /* Generate NTLM response */
+
+		create_des_keys ((unsigned char *)md4_hash, key1);
+		des_set_key_unchecked ((des_cblock *)key1, sched1);
+		des_ecb_encrypt ((des_cblock *)challenge, (des_cblock *)ntlm_response, sched1, DES_ENCRYPT);
+
+		create_des_keys ((unsigned char *)&(md4_hash[7]), key2);
+		des_set_key_unchecked ((des_cblock *)key2, sched2);
+		des_ecb_encrypt ((des_cblock *)challenge, (des_cblock *)&(ntlm_response[8]), sched2, DES_ENCRYPT);
+
+		create_des_keys ((unsigned char *)&(md4_hash[14]), key3);
+		des_set_key_unchecked ((des_cblock *)key3, sched3);
+		des_ecb_encrypt ((des_cblock *)challenge, (des_cblock *)&(ntlm_response[16]), sched3, DES_ENCRYPT);
+	}
+	
+	
+	memset (phase3, 0, sizeof (phase3)); /* clear reply */
+
+	strcpy ((char *)phase3, "NTLMSSP\0"); /* signature */
+	phase3[8] = 3; /* type 3 */
+
+	if (ntlmv2_enabled){ /* NTLMv2 response */
+		add_security_buffer(0x14, ntlmv2_response, ntlmv2_blob_size + 16, phase3, &phase3_bufpos);
+	}else{ /* NTLM response */
+		add_security_buffer(0x14, ntlm_response, 24, phase3, &phase3_bufpos);
+	}
+	
+	/* username in ascii */
+	add_security_buffer(0x24, username, strlen (username), phase3, &phase3_bufpos);
+
+	/* Set domain. If <domain> is empty, default domain will be used (i.e. proxy's domain) */ 
+	add_security_buffer(0x1c, domain, strlen (domain), phase3, &phase3_bufpos);
+	
+
+	/* other security buffers will be empty */
+	phase3[0x10] = phase3_bufpos; /* lm not used */
+	phase3[0x30] = phase3_bufpos; /* no workstation name supplied */
+	phase3[0x38] = phase3_bufpos; /* no session key */
+	
+	/* flags */
   phase3[0x3c] = 0x02; /* negotiate oem */
   phase3[0x3d] = 0x02; /* negotiate ntlm */
 
-  return ((const char *)make_base64_string2 ((unsigned char *)phase3, buflen, gc));
+  return ((const char *)make_base64_string2 ((unsigned char *)phase3, phase3_bufpos, gc));
 }
 
 #else
diff -urN openvpn-2.1_rc7/occ-inline.h openvpn-2.1_rc9/occ-inline.h
--- openvpn-2.1_rc7/occ-inline.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/occ-inline.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/occ.c openvpn-2.1_rc9/occ.c
--- openvpn-2.1_rc7/occ.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/occ.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #ifdef ENABLE_OCC
@@ -155,7 +149,7 @@
 {
   if (++c->c2.occ_n_tries >= OCC_N_TRIES)
     {
-      if (c->options.remote_list)
+      if (c->options.ce.remote)
 	/*
 	 * No OCC_REPLY from peer after repeated attempts.
 	 * Give up.
@@ -375,7 +369,7 @@
 	       c->c2.max_send_size_remote,
 	       c->c2.max_recv_size_local);
 	  if (!c->options.fragment
-	      && c->options.proto == PROTO_UDPv4
+	      && c->options.ce.proto == PROTO_UDPv4
 	      && c->c2.max_send_size_local > TUN_MTU_MIN
 	      && (c->c2.max_recv_size_remote < c->c2.max_send_size_local
 		  || c->c2.max_recv_size_local < c->c2.max_send_size_remote))
diff -urN openvpn-2.1_rc7/occ.h openvpn-2.1_rc9/occ.h
--- openvpn-2.1_rc7/occ.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/occ.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/openvpn-plugin.h openvpn-2.1_rc9/openvpn-plugin.h
--- openvpn-2.1_rc7/openvpn-plugin.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/openvpn-plugin.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -27,6 +27,63 @@
 /*
  * Plug-in types.  These types correspond to the set of script callbacks
  * supported by OpenVPN.
+ *
+ * This is the general call sequence to expect when running in server mode:
+ *
+ * Initial Server Startup:
+ *
+ * FUNC: openvpn_plugin_open_v1
+ * FUNC: openvpn_plugin_client_constructor_v1 (this is the top-level "generic"
+ *                                             client template)
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_UP
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_ROUTE_UP
+ *
+ * New Client Connection:
+ *
+ * FUNC: openvpn_plugin_client_constructor_v1
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_TLS_VERIFY (called once for every cert
+ *                                                     in the server chain)
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_TLS_FINAL
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_IPCHANGE
+ *
+ * [If OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY returned OPENVPN_PLUGIN_FUNC_DEFERRED,
+ * we don't proceed until authentication is verified via auth_control_file]
+ *
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_CLIENT_CONNECT_V2
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_LEARN_ADDRESS
+ * 
+ * [Client session ensues]
+ *
+ * For each "TLS soft reset", according to reneg-sec option (or similar):
+ *
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_ENABLE_PF
+ *
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_TLS_VERIFY (called once for every cert
+ *                                                     in the server chain)
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_TLS_FINAL
+ * 
+ * [If OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY returned OPENVPN_PLUGIN_FUNC_DEFERRED,
+ * we expect that authentication is verified via auth_control_file within
+ * the number of seconds defined by the "hand-window" option.  Data channel traffic
+ * will continue to flow uninterrupted during this period.]
+ *
+ * [Client session continues]
+ *
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_CLIENT_DISCONNECT
+ * FUNC: openvpn_plugin_client_constructor_v1
+ *
+ * [ some time may pass ]
+ *
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_LEARN_ADDRESS (this coincides with a
+ *                                                            lazy free of initial
+ *                                                            learned addr object)
+ * Server Shutdown:
+ *
+ * FUNC: openvpn_plugin_func_v1 OPENVPN_PLUGIN_DOWN
+ * FUNC: openvpn_plugin_client_destructor_v1 (top-level "generic" client)
+ * FUNC: openvpn_plugin_close_v1
  */
 #define OPENVPN_PLUGIN_UP                    0
 #define OPENVPN_PLUGIN_DOWN                  1
@@ -39,7 +96,8 @@
 #define OPENVPN_PLUGIN_LEARN_ADDRESS         8
 #define OPENVPN_PLUGIN_CLIENT_CONNECT_V2     9
 #define OPENVPN_PLUGIN_TLS_FINAL             10
-#define OPENVPN_PLUGIN_N                     11
+#define OPENVPN_PLUGIN_ENABLE_PF             11
+#define OPENVPN_PLUGIN_N                     12
 
 /*
  * Build a mask out of a set of plug-in types.
@@ -57,6 +115,7 @@
  */
 #define OPENVPN_PLUGIN_FUNC_SUCCESS  0
 #define OPENVPN_PLUGIN_FUNC_ERROR    1
+#define OPENVPN_PLUGIN_FUNC_DEFERRED 2
 
 /*
  * For Windows (needs to be modified for MSVC)
@@ -202,6 +261,64 @@
  * RETURN VALUE
  *
  * OPENVPN_PLUGIN_FUNC_SUCCESS on success, OPENVPN_PLUGIN_FUNC_ERROR on failure
+ *
+ * In addition, OPENVPN_PLUGIN_FUNC_DEFERRED may be returned by
+ * OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY.  This enables asynchronous
+ * authentication where the plugin (or one of its agents) may indicate
+ * authentication success/failure some number of seconds after the return
+ * of the OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY handler by writing a single
+ * char to the file named by auth_control_file in the environmental variable
+ * list (envp).
+ *
+ * first char of auth_control_file:
+ * '0' -- indicates auth failure
+ * '1' -- indicates auth success
+ *
+ * OpenVPN will delete the auth_control_file after it goes out of scope.
+ *
+ * If an OPENVPN_PLUGIN_ENABLE_PF handler is defined and returns success
+ * for a particular client instance, packet filtering will be enabled for that
+ * instance.  OpenVPN will then attempt to read the packet filter configuration
+ * from the temporary file named by the environmental variable pf_file.  This
+ * file may be generated asynchronously and may be dynamically updated during the
+ * client session, however the client will be blocked from sending or receiving
+ * VPN tunnel packets until the packet filter file has been generated.  OpenVPN
+ * will periodically test the packet filter file over the life of the client
+ * instance and reload when modified.  OpenVPN will delete the packet filter file
+ * when the client instance goes out of scope.
+ *
+ * Packet filter file grammar:
+ *
+ * [CLIENTS DROP|ACCEPT]
+ * {+|-}common_name1
+ * {+|-}common_name2
+ * . . .
+ * [SUBNETS DROP|ACCEPT]
+ * {+|-}subnet1
+ * {+|-}subnet2
+ * . . .
+ * [END]
+ *
+ * Subnet: IP-ADDRESS | IP-ADDRESS/NUM_NETWORK_BITS
+ *
+ * CLIENTS refers to the set of clients (by their common-name) which
+ * this instance is allowed ('+') to connect to, or is excluded ('-')
+ * from connecting to.  Note that in the case of client-to-client
+ * connections, such communication must be allowed by the packet filter
+ * configuration files of both clients.
+ *
+ * SUBNETS refers to IP addresses or IP address subnets which this
+ * instance may connect to ('+') or is excluded ('-') from connecting
+ * to.
+ *
+ * DROP or ACCEPT defines default policy when there is no explicit match
+ * for a common-name or subnet.  The [END] tag must exist.  A special
+ * purpose tag called [KILL] will immediately kill the client instance.
+ * A given client or subnet rule applies to both incoming and outgoing
+ * packets.
+ *
+ * See plugin/defer/simple.c for an example on using asynchronous
+ * authentication and client-specific packet filtering.
  */
 OPENVPN_PLUGIN_DEF int OPENVPN_PLUGIN_FUNC(openvpn_plugin_func_v2)
      (openvpn_plugin_handle_t handle,
diff -urN openvpn-2.1_rc7/openvpn.8 openvpn-2.1_rc9/openvpn.8
--- openvpn-2.1_rc7/openvpn.8	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/openvpn.8	2008-07-26 08:54:34.000000000 +0200
@@ -4,7 +4,7 @@
 .\"             packet encryption, packet authentication, and
 .\"             packet compression.
 .\"
-.\"  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+.\"  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
 .\"
 .\"  This program is free software; you can redistribute it and/or modify
 .\"  it under the terms of the GNU General Public License version 2
@@ -179,6 +179,8 @@
 [\ \fB\-\-log\fR\ \fIfile\fR\ ]
 [\ \fB\-\-suppress-timestamps\fR\ ]
 [\ \fB\-\-lport\fR\ \fIport\fR\ ]
+[\ \fB\-\-management\-client\-auth\fR\ ]
+[\ \fB\-\-management\-client\-pf\fR\ ]
 [\ \fB\-\-management\-forget\-disconnect\fR\ ]
 [\ \fB\-\-management\-hold\fR\ ]
 [\ \fB\-\-management\-log\-cache\fR\ \fIn\fR\ ]
@@ -213,6 +215,7 @@
 [\ \fB\-\-ping\fR\ \fIn\fR\ ]
 [\ \fB\-\-pkcs11\-cert\-private\fR\ \fI[0|1]...\fR\ ]
 [\ \fB\-\-pkcs11\-id\fR\ \fIname\fR\ ]
+[\ \fB\-\-pkcs11\-id\-management\fR\ ]
 [\ \fB\-\-pkcs11\-pin\-cache\fR\ \fIseconds\fR\ ]
 [\ \fB\-\-pkcs11\-private\-mode\fR\ \fImode...\fR\ ]
 [\ \fB\-\-pkcs11\-protected\-authentication\fR\ \fI[0|1]...\fR\ ]
@@ -249,6 +252,7 @@
 [\ \fB\-\-route\-up\fR\ \fIcmd\fR\ ]
 [\ \fB\-\-route\fR\ \fInetwork\ [netmask]\ [gateway]\ [metric]\fR\ ]
 [\ \fB\-\-rport\fR\ \fIport\fR\ ]
+[\ \fB\-\-script\-security\fR\ \fIlevel\fR\ ]
 [\ \fB\-\-secret\fR\ \fIfile\ [direction]\fR\ ]
 [\ \fB\-\-secret\fR\ \fIfile\fR\ ]
 [\ \fB\-\-server\-bridge\fR\ \fIgateway\ netmask\ pool\-start\-IP\ pool\-end\-IP\fR\ ]
@@ -297,6 +301,7 @@
 [\ \fB\-\-user\fR\ \fIuser\fR\ ]
 [\ \fB\-\-username\-as\-common\-name\fR\ ]
 [\ \fB\-\-verb\fR\ \fIn\fR\ ]
+[\ \fB\-\-win\-sys\fR\ \fIpath|'env'\fR\ ]
 [\ \fB\-\-writepid\fR\ \fIfile\fR\ ]
 .in -4
 .ti +4
@@ -463,11 +468,16 @@
 If unspecified, OpenVPN will bind to all interfaces.
 .\"*********************************************************
 .TP
-.B --remote host [port]
+.B --remote host [port] [proto]
 Remote host name or IP address.  On the client, multiple
 .B --remote
 options may be specified for redundancy, each referring
-to a different OpenVPN server.
+to a different OpenVPN server.  Specifying multiple
+.B --remote
+options for this purpose is a special case of the more
+general connection-profile feature.  See the
+.B <connection>
+documentation below.
 
 The OpenVPN client will try to connect to a server at
 .B host:port
@@ -475,6 +485,10 @@
 .B --remote
 options.
 
+.B proto
+indicates the protocol to use when connecting with the
+remote, and may be "tcp" or "udp".
+
 The client will move on to the next host in the list,
 in the event of connection failure.
 Note that at any given time, the OpenVPN client
@@ -524,10 +538,124 @@
 failover capability.
 .\"*********************************************************
 .TP
+.B <connection>
+Define a client connection
+profile.  Client connection profiles are groups of OpenVPN options that
+describe how to connect to a given OpenVPN server.  Client connection
+profiles are specified within an OpenVPN configuration file, and
+each profile is bracketed by
+.B <connection>
+and
+.B </connection>.
+
+An OpenVPN client will try each connection profile sequentially
+until it achieves a successful connection.  
+
+.B --remote-random
+can be used to initially "scramble" the connection
+list.
+
+Here is an example of connection profile usage:
+
+.RS
+.ft 3
+.nf
+.sp
+client
+dev tun
+
+<connection>
+remote 198.19.34.56 1194 udp
+</connection>
+
+<connection>
+remote 198.19.34.56 443 tcp
+</connection>
+
+<connection>
+remote 198.19.34.56 443 tcp
+http-proxy 192.168.0.8 8080
+http-proxy-retry
+</connection>
+
+<connection>
+remote 198.19.36.99 443 tcp
+http-proxy 192.168.0.8 8080
+http-proxy-retry
+</connection>
+
+persist-key
+persist-tun
+pkcs12 client.p12
+ns-cert-type server
+verb 3
+.ft
+.LP
+.RE
+.fi
+
+First we try to connect to a server at 198.19.34.56:1194 using UDP.
+If that fails, we then try to connect to 198.19.34.56:443 using TCP.
+If that also fails, then try connecting through an HTTP proxy at 
+192.168.0.8:8080 to 198.19.34.56:443 using TCP.  Finally, try to
+connect through the same proxy to a server at 198.19.36.99:443
+using TCP.
+
+The following OpenVPN options may be used inside of
+a
+.B <connection>
+block:
+
+.B bind,
+.B connect-retry,
+.B connect-retry-max,
+.B connect-timeout,
+.B float,
+.B http-proxy,
+.B http-proxy-option,
+.B http-proxy-retry,
+.B http-proxy-timeout,
+.B local,
+.B lport,
+.B nobind,
+.B port,
+.B proto,
+.B remote,
+.B rport,
+.B socks-proxy, and
+.B socks-proxy-retry.
+
+A defaulting mechanism exists for specifying options to apply to
+all
+.B <connection>
+profiles.  If any of the above options (with the exception of
+.B remote
+) appear outside of a
+.B <connection>
+block, but in a configuration file which has one or more
+.B <connection>
+blocks, the option setting will be used as a default for
+.B <connection>
+blocks which follow it in the configuration file.
+
+For example, suppose the
+.B nobind
+option were placed in the sample configuration file above, near
+the top of the file, before the first
+.B <connection>
+block.  The effect would be as if
+.B nobind
+were declared in all
+.B <connection>
+blocks below it.
+
+.\"*********************************************************
+.TP
 .B --remote-random
 When multiple
 .B --remote
-address/ports are specified, initially randomize the order of the list
+address/ports are specified, or if connection profiles are being
+used, initially randomize the order of the list
 as a kind of basic load-balancing measure.
 .\"*********************************************************
 .TP
@@ -1872,6 +2000,24 @@
 from a malicious or compromised server.
 .\"*********************************************************
 .TP
+.B --script-security level
+This directive offers policy-level control over OpenVPN's usage of external programs
+and scripts.  Lower values are more restrictive, higher values are more permissive.  Settings for
+.B level:
+
+.B 0 --
+Strictly no calling of external programs.
+.br
+.B 1 --
+(Default) Only call built-in executables such as ifconfig, ip, route, or netsh.
+.br
+.B 2 --
+Allow calling of built-in executables and user-defined scripts.
+.br
+.B 3 --
+Allow passwords to be passed to scripts via environmental variables (potentially unsafe).
+.\"*********************************************************
+.TP
 .B --disable-occ
 Don't output a warning message if option inconsistencies are detected between
 peers.  An example of an option inconsistency would be where one peer uses
@@ -2356,6 +2502,19 @@
 by the management channel.
 .\"*********************************************************
 .TP
+.B --management-client-auth
+Gives management interface client the responsibility
+to authenticate clients after their client certificate
+has been verified.  See management-notes.txt in OpenVPN
+distribution for detailed notes.
+.\"*********************************************************
+.TP
+.B --management-client-pf
+Management interface clients must specify a packet
+filter file for each connecting client.  See management-notes.txt
+in OpenVPN distribution for detailed notes.
+.\"*********************************************************
+.TP
 .B --plugin module-pathname [init-string]
 Load plug-in module from the file
 .B module-pathname,
@@ -2858,13 +3017,13 @@
 .\"*********************************************************
 .TP
 .B --tcp-queue-limit n
-Maximum number of queued TCP output packets (default=64).
+Maximum number of output packets queued before TCP (default=64).
 
 When OpenVPN is tunneling data from a TUN/TAP device to a
 remote client over a TCP connection, it is possible that the TUN/TAP device
 might produce data at a faster rate than the TCP connection
-can support.  When the number of queued TCP output packets reaches
-this limit for a given client connection,
+can support.  When the number of output packets queued before sending to
+the TCP socket reaches this limit for a given client connection,
 OpenVPN will start to drop outgoing packets directed
 at this client.
 .\"*********************************************************
@@ -3691,6 +3850,13 @@
 option.
 .\"*********************************************************
 .TP
+.B --pkcs11-id-management
+Acquire PKCS#11 id from management interface. In this case a NEED-STR 'pkcs11-id-request'
+real-time message will be triggered, application may use pkcs11-id-count command to
+retrieve available number of certificates, and pkcs11-id-get command to retrieve certificate
+id and certificate body.
+.\"*********************************************************
+.TP
 .B --pkcs11-pin-cache seconds
 Specify how many seconds the PIN can be cached, the default is until the token is removed.
 .\"*********************************************************
@@ -4335,6 +4501,22 @@
 .SS Windows-Specific Options:
 .\"*********************************************************
 .TP
+.B --win-sys path|'env'
+Set the Windows system directory pathname to use when looking for system
+executables such as
+.B route.exe
+and
+.B netsh.exe.
+By default, if this directive is
+not specified, the pathname will be set to "C:\\WINDOWS"
+
+The special string
+.B 'env'
+indicates that the pathname should be read from the
+.B SystemRoot
+environmental variable.
+.\"*********************************************************
+.TP
 .B --ip-win32 method
 When using
 .B --ifconfig
@@ -5615,7 +5797,7 @@
 .I http://www.oberhumer.com/opensource/lzo/
 .\"*********************************************************
 .SH COPYRIGHT
-Copyright (C) 2002-2005 OpenVPN Solutions LLC. This program is free software;
+Copyright (C) 2002-2008 Telethra, Inc. This program is free software;
 you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2
 as published by the Free Software Foundation.
diff -urN openvpn-2.1_rc7/openvpn.c openvpn-2.1_rc9/openvpn.c
--- openvpn-2.1_rc7/openvpn.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/openvpn.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,17 +22,12 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "init.h"
 #include "forward.h"
 #include "multi.h"
+#include "win32.h"
 
 #include "memdbg.h"
 
@@ -136,7 +131,10 @@
 	  gc_init (&c.gc);
 
 	  /* initialize environmental variable store */
-	  c.es = env_set_create (&c.gc);
+	  c.es = env_set_create (NULL);
+#ifdef WIN32
+	  env_set_add_win32 (c.es);
+#endif
 
 #ifdef ENABLE_MANAGEMENT
 	  /* initialize management subsystem */
@@ -144,7 +142,7 @@
 #endif
 
 	  /* initialize options to default state */
-	  init_options (&c.options);
+	  init_options (&c.options, true);
 
 	  /* parse command line options, and read configuration file */
 	  parse_argv (&c.options, argc, argv, M_USAGE, OPT_P_DEFAULT, NULL, c.es);
@@ -175,7 +173,7 @@
 	    break;
 
 	  /* sanity check on options */
-	  options_postprocess (&c.options, c.first_time);
+	  options_postprocess (&c.options);
 
 	  /* show all option settings */
 	  show_settings (&c.options);
@@ -239,6 +237,8 @@
 
   context_gc_free (&c);
 
+  env_set_destroy (c.es);
+
 #ifdef ENABLE_MANAGEMENT
   /* close management interface */
   close_management ();
diff -urN openvpn-2.1_rc7/openvpn.h openvpn-2.1_rc9/openvpn.h
--- openvpn-2.1_rc7/openvpn.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/openvpn.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -46,6 +46,7 @@
 #include "pool.h"
 #include "plugin.h"
 #include "manage.h"
+#include "pf.h"
 
 /*
  * Our global key schedules, packaged thusly
@@ -157,9 +158,6 @@
   /* persist crypto sequence number to/from file */
   struct packet_id_persist pid_persist;
 
-  /* array of remote addresses */
-  struct remote_list *remote_list;
-
   /* TUN/TAP interface */
   struct tuntap *tuntap;
   bool tuntap_owned;
@@ -174,11 +172,13 @@
 #ifdef ENABLE_HTTP_PROXY
   /* HTTP proxy object */
   struct http_proxy_info *http_proxy;
+  bool http_proxy_owned;
 #endif
 
 #ifdef ENABLE_SOCKS
   /* SOCKS proxy object */
   struct socks_proxy_info *socks_proxy;
+  bool socks_proxy_owned;
 #endif
 
 #if P2MP
@@ -430,7 +430,15 @@
   const char *pulled_options_string;
 
   struct event_timeout scheduled_exit;
+#endif
+
+  /* packet filter */
+#ifdef ENABLE_PF
+  struct pf_context pf;
+#endif
 
+#ifdef MANAGEMENT_DEF_AUTH
+  struct man_def_auth_context mda_context;
 #endif
 };
 
diff -urN openvpn-2.1_rc7/openvpn.spec openvpn-2.1_rc9/openvpn.spec
--- openvpn-2.1_rc7/openvpn.spec	2008-01-30 01:38:50.000000000 +0100
+++ openvpn-2.1_rc9/openvpn.spec	2008-07-31 19:46:27.000000000 +0200
@@ -16,7 +16,7 @@
 
 Summary:	OpenVPN is a robust and highly flexible VPN daemon by James Yonan.
 Name:           openvpn
-Version:        2.1_rc7
+Version:        2.1_rc9
 Release:	1
 URL:		http://openvpn.net/
 Source0:	http://prdownloads.sourceforge.net/openvpn/%{name}-%{version}.tar.gz
diff -urN openvpn-2.1_rc7/options.c openvpn-2.1_rc9/options.c
--- openvpn-2.1_rc7/options.c	2008-01-24 01:55:18.000000000 +0100
+++ openvpn-2.1_rc9/options.c	2008-07-31 19:41:26.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -27,12 +27,6 @@
  *   (Christof Meerwald, http://cmeerw.org)
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "buffer.h"
@@ -195,6 +189,10 @@
   "                  flag to add a direct route to DHCP server, bypassing tunnel.\n"
   "                  Add 'bypass-dns' flag to similarly bypass tunnel for DNS.\n"
   "--setenv name value : Set a custom environmental variable to pass to script.\n"
+  "--script-security level : 0 -- strictly no calling of external programs\n"
+  "                          1 -- (default) only call built-ins such as ifconfig\n"
+  "                          2 -- allow calling of built-ins and scripts\n"
+  "                          3 -- allow password to be passed to scripts via env\n"
   "--shaper n      : Restrict output to peer to n bytes per second.\n"
   "--keepalive n m : Helper option for setting timeouts in server mode.  Send\n"
   "                  ping once every n seconds, restart if ping not received\n"
@@ -322,6 +320,15 @@
   "                                 event occurs.\n"
   "--management-log-cache n : Cache n lines of log file history for usage\n"
   "                  by the management channel.\n"
+#ifdef MANAGEMENT_DEF_AUTH
+  "--management-client-auth : gives management interface client the responsibility\n"
+  "                           to authenticate clients after their client certificate\n"
+  "			      has been verified.\n"
+#endif
+#ifdef MANAGEMENT_PF
+  "--management-client-pf : management interface clients must specify a packet\n"
+  "                         filter file for each connecting client.\n"
+#endif
 #endif
 #ifdef ENABLE_PLUGIN
   "--plugin m [str]: Load plug-in module m passing str as an argument\n"
@@ -516,10 +523,11 @@
   "                              4       : Use Decrypt.\n"
   "                              8       : Use Unwrap.\n"
   "--pkcs11-cert-private [0|1] ... : Set if login should be performed before\n"
-  "                              certificate can be accessed. Set for each provider.\n"
-  "--pkcs11-pin-cache seconds  : Number of seconds to cache PIN. The default is -1\n"
-  "                              cache until token is removed.\n"
-  "--pkcs11-id serialized-id   : Identity to use, get using standalone --show-pkcs11-ids\n"
+  "                                  certificate can be accessed. Set for each provider.\n"
+  "--pkcs11-pin-cache seconds      : Number of seconds to cache PIN. The default is -1\n"
+  "                                  cache until token is removed.\n"
+  "--pkcs11-id-management          : Acquire identity from management interface.\n"
+  "--pkcs11-id serialized-id 'id'  : Identity to use, get using standalone --show-pkcs11-ids\n"
 #endif			/* ENABLE_PKCS11 */
  "\n"
   "SSL Library information:\n"
@@ -532,6 +540,8 @@
 #ifdef WIN32
   "\n"
   "Windows Specific:\n"
+  "--win-sys path|'env' : Pathname of Windows system directory, C:\\WINDOWS by default.\n"
+  "                       If specified as 'env', read the pathname from SystemRoot env var.\n"
   "--ip-win32 method : When using --ifconfig on Windows, set TAP-Win32 adapter\n"
   "                    IP address using method = manual, netsh, ipapi,\n"
   "                    dynamic, or adaptive (default = adaptive).\n"
@@ -615,21 +625,25 @@
  * will be set to 0.
  */
 void
-init_options (struct options *o)
+init_options (struct options *o, const bool init_gc)
 {
   CLEAR (*o);
-  gc_init (&o->gc);
+  if (init_gc)
+    {
+      gc_init (&o->gc);
+      o->gc_owned = true;
+    }
   o->mode = MODE_POINT_TO_POINT;
   o->topology = TOP_NET30;
-  o->proto = PROTO_UDPv4;
-  o->connect_retry_seconds = 5;
-  o->connect_timeout = 10;
-  o->connect_retry_max = 0;
-  o->local_port = o->remote_port = OPENVPN_PORT;
+  o->ce.proto = PROTO_UDPv4;
+  o->ce.connect_retry_seconds = 5;
+  o->ce.connect_timeout = 10;
+  o->ce.connect_retry_max = 0;
+  o->ce.local_port = o->ce.remote_port = OPENVPN_PORT;
   o->verbosity = 1;
   o->status_file_update_freq = 60;
   o->status_file_version = 1;
-  o->bind_local = true;
+  o->ce.bind_local = true;
   o->tun_mtu = TUN_MTU_DEFAULT;
   o->link_mtu = LINK_MTU_DEFAULT;
   o->mtu_discover_type = -1;
@@ -705,7 +719,8 @@
 void
 uninit_options (struct options *o)
 {
-  gc_free (&o->gc);
+  if (o->gc_owned)
+    gc_free (&o->gc);
 }
 
 #ifdef ENABLE_DEBUG
@@ -720,46 +735,50 @@
 #endif
 
 void
+setenv_connection_entry (struct env_set *es,
+			 const struct connection_entry *e,
+			 const int i)
+{
+  setenv_str_i (es, "proto", proto2ascii (e->proto, false), i);
+  setenv_str_i (es, "local", e->local, i);
+  setenv_int_i (es, "local_port", e->local_port, i);
+  setenv_str_i (es, "remote", e->local, i);
+  setenv_int_i (es, "remote_port", e->local_port, i);
+
+#ifdef ENABLE_HTTP_PROXY
+  if (e->http_proxy_options)
+    {
+      setenv_str_i (es, "http_proxy_server", e->http_proxy_options->server, i);
+      setenv_int_i (es, "http_proxy_port", e->http_proxy_options->port, i);
+    }
+#endif
+#ifdef ENABLE_SOCKS
+  if (e->socks_proxy_server)
+    {
+      setenv_str_i (es, "socks_proxy_server", e->socks_proxy_server, i);
+      setenv_int_i (es, "socks_proxy_port", e->socks_proxy_port, i);
+    }
+#endif
+}
+
+void
 setenv_settings (struct env_set *es, const struct options *o)
 {
   setenv_str (es, "config", o->config);
-  setenv_str (es, "proto", proto2ascii (o->proto, false));
-  setenv_str (es, "local", o->local);
-  setenv_int (es, "local_port", o->local_port);
   setenv_int (es, "verb", o->verbosity);
   setenv_int (es, "daemon", o->daemon);
   setenv_int (es, "daemon_log_redirect", o->log);
 
-  if (o->remote_list)
+#ifdef ENABLE_CONNECTION
+  if (o->connection_list)
     {
       int i;
-
-      for (i = 0; i < o->remote_list->len; ++i)
-	{
-	  char remote_string[64];
-	  char remote_port_string[64];
-
-	  openvpn_snprintf (remote_string, sizeof (remote_string), "remote_%d", i+1);
-	  openvpn_snprintf (remote_port_string, sizeof (remote_port_string), "remote_port_%d", i+1);
-
-	  setenv_str (es, remote_string,      o->remote_list->array[i].hostname);
-	  setenv_int (es, remote_port_string, o->remote_list->array[i].port);
-	}
+      for (i = 0; i < o->connection_list->len; ++i)
+	setenv_connection_entry (es, o->connection_list->array[i], i+1);
     }
-#ifdef ENABLE_HTTP_PROXY
-    if (o->http_proxy_options)
-      {
-        setenv_str (es, "http_proxy_server", o->http_proxy_options->server);
-        setenv_int (es, "http_proxy_port", o->http_proxy_options->port);
-      }
-#endif
-#ifdef ENABLE_SOCKS
-    if(o->socks_proxy_server)
-      {
-        setenv_str (es, "socks_proxy_server", o->socks_proxy_server);
-        setenv_int (es, "socks_proxy_port", o->socks_proxy_port);
-      }
+  else
 #endif
+    setenv_connection_entry (es, &o->ce, 1);
 }
 
 static in_addr_t
@@ -812,7 +831,7 @@
 bool
 is_stateful_restart (const struct options *o)
 {
-  return is_persist_option (o) || (o->remote_list && o->remote_list->len > 1);
+  return is_persist_option (o) || connection_list_defined (o);
 }
 
 #ifdef WIN32
@@ -871,10 +890,17 @@
     }
   else
     {
-      bool error = false;
-      const in_addr_t addr = get_ip_addr (parm, msglevel, &error);
-      if (!error)
-	array[(*len)++] = addr;
+      if (ip_addr_dotted_quad_safe (parm))
+	{
+	  bool error = false;
+	  const in_addr_t addr = get_ip_addr (parm, msglevel, &error);
+	  if (!error)
+	    array[(*len)++] = addr;
+	}
+      else
+	{
+	  msg (msglevel, "dhcp-option parameter %s '%s' must be an IP address", name, parm);
+	}
     }
 }
 
@@ -979,26 +1005,6 @@
 #endif /* P2MP_SERVER */
 #endif /* P2MP */
 
-#ifdef ENABLE_DEBUG
-static void
-show_remote_list (const struct remote_list *l)
-{
-  if (l)
-    {
-      int i;
-      for (i = 0; i < l->len; ++i)
-	{
-	  msg (D_SHOW_PARMS, "  remote_list[%d] = {'%s', %d}",
-	       i, l->array[i].hostname, l->array[i].port);
-	}
-    }
-  else
-    {
-      msg (D_SHOW_PARMS, "  remote_list = NULL");
-    }
-}
-#endif
-
 #if defined(ENABLE_HTTP_PROXY) && defined(ENABLE_DEBUG)
 static void
 show_http_proxy_options (const struct http_proxy_options *o)
@@ -1038,6 +1044,55 @@
     options->routes = new_route_option_list (&options->gc);
 }
 
+#ifdef ENABLE_DEBUG
+static void
+show_connection_entry (const struct connection_entry *o)
+{
+  msg (D_SHOW_PARMS, "  proto = %s", proto2ascii (o->proto, false));
+  SHOW_STR (local);
+  SHOW_INT (local_port);
+  SHOW_STR (remote);
+  SHOW_INT (remote_port);
+  SHOW_BOOL (remote_float);
+  SHOW_BOOL (bind_defined);
+  SHOW_BOOL (bind_local);
+  SHOW_INT (connect_retry_seconds);
+  SHOW_INT (connect_timeout);
+  SHOW_INT (connect_retry_max);
+
+#ifdef ENABLE_HTTP_PROXY
+  if (o->http_proxy_options)
+    show_http_proxy_options (o->http_proxy_options);
+#endif
+#ifdef ENABLE_SOCKS
+  SHOW_STR (socks_proxy_server);
+  SHOW_INT (socks_proxy_port);
+  SHOW_BOOL (socks_proxy_retry);
+#endif
+}
+
+static void
+show_connection_entries (const struct options *o)
+{
+  msg (D_SHOW_PARMS, "Connection profiles [default]:");
+  show_connection_entry (&o->ce);
+#ifdef ENABLE_CONNECTION
+ if (o->connection_list)
+   {
+     const struct connection_list *l = o->connection_list;
+     int i;
+     for (i = 0; i < l->len; ++i)
+       {
+	 msg (D_SHOW_PARMS, "Connection profiles [%d]:", i);
+	 show_connection_entry (l->array[i]);
+       }
+   }
+#endif
+  msg (D_SHOW_PARMS, "Connection profiles END");
+}
+
+#endif
+
 void
 show_settings (const struct options *o)
 {
@@ -1064,17 +1119,11 @@
 #endif
 #endif
 
-  SHOW_INT (proto);
-  SHOW_STR (local);
-  show_remote_list (o->remote_list);
+  show_connection_entries (o);
+
   SHOW_BOOL (remote_random);
 
-  SHOW_INT (local_port);
-  SHOW_INT (remote_port);
-  SHOW_BOOL (remote_float);
   SHOW_STR (ipchange);
-  SHOW_BOOL (bind_defined);
-  SHOW_BOOL (bind_local);
   SHOW_STR (dev);
   SHOW_STR (dev_type);
   SHOW_STR (dev_node);
@@ -1131,9 +1180,6 @@
 #endif
 
   SHOW_INT (resolve_retry_seconds);
-  SHOW_INT (connect_retry_seconds);
-  SHOW_INT (connect_timeout);
-  SHOW_INT (connect_retry_max);
 
   SHOW_STR (username);
   SHOW_STR (groupname);
@@ -1166,17 +1212,6 @@
   SHOW_INT (sndbuf);
   SHOW_INT (sockflags);
 
-#ifdef ENABLE_HTTP_PROXY
-  if (o->http_proxy_options)
-    show_http_proxy_options (o->http_proxy_options);
-#endif
-
-#ifdef ENABLE_SOCKS
-  SHOW_STR (socks_proxy_server);
-  SHOW_INT (socks_proxy_port);
-  SHOW_BOOL (socks_proxy_retry);
-#endif
-
   SHOW_BOOL (fast_io);
 
 #ifdef USE_LZO
@@ -1200,12 +1235,8 @@
   SHOW_STR (management_user_pass);
   SHOW_INT (management_log_history_cache);
   SHOW_INT (management_echo_buffer_size);
-  SHOW_BOOL (management_query_passwords);
-  SHOW_BOOL (management_hold);
-  SHOW_BOOL (management_client);
-  SHOW_BOOL (management_signal);
-  SHOW_BOOL (management_forget_disconnect);
   SHOW_STR (management_write_peer_info_file);
+  SHOW_INT (management_flags);
 #endif
 #ifdef ENABLE_PLUGIN
   if (o->plugin_list)
@@ -1293,6 +1324,7 @@
   }
   SHOW_INT (pkcs11_pin_cache_period);
   SHOW_STR (pkcs11_id);
+  SHOW_BOOL (pkcs11_id_management);
 #endif			/* ENABLE_PKCS11 */
 
 #if P2MP
@@ -1317,32 +1349,89 @@
 struct http_proxy_options *
 init_http_options_if_undefined (struct options *o)
 {
-  if (!o->http_proxy_options)
+  if (!o->ce.http_proxy_options)
     {
-      ALLOC_OBJ_CLEAR_GC (o->http_proxy_options, struct http_proxy_options, &o->gc);
+      ALLOC_OBJ_CLEAR_GC (o->ce.http_proxy_options, struct http_proxy_options, &o->gc);
       /* http proxy defaults */
-      o->http_proxy_options->timeout = 5;
-      o->http_proxy_options->http_version = "1.0";
+      o->ce.http_proxy_options->timeout = 5;
+      o->ce.http_proxy_options->http_version = "1.0";
     }
-  return o->http_proxy_options;
+  return o->ce.http_proxy_options;
+}
+
+#endif
+
+#if ENABLE_CONNECTION
+
+static struct connection_list *
+alloc_connection_list_if_undef (struct options *options)
+{
+  if (!options->connection_list)
+    ALLOC_OBJ_CLEAR_GC (options->connection_list, struct connection_list, &options->gc);
+  return options->connection_list;
+}
+
+static struct connection_entry *
+alloc_connection_entry (struct options *options, const int msglevel)
+{
+  struct connection_list *l = alloc_connection_list_if_undef (options);
+  struct connection_entry *e;
+
+  if (l->len >= CONNECTION_LIST_SIZE)
+    {
+      msg (msglevel, "Maximum number of 'connection' options (%d) exceeded", CONNECTION_LIST_SIZE);
+      return NULL;
+    }
+  ALLOC_OBJ_GC (e, struct connection_entry, &options->gc);
+  l->array[l->len++] = e;
+  return e;
+}
+
+static struct remote_list *
+alloc_remote_list_if_undef (struct options *options)
+{
+  if (!options->remote_list)
+    ALLOC_OBJ_CLEAR_GC (options->remote_list, struct remote_list, &options->gc);
+  return options->remote_list;
+}
+
+static struct remote_entry *
+alloc_remote_entry (struct options *options, const int msglevel)
+{
+  struct remote_list *l = alloc_remote_list_if_undef (options);
+  struct remote_entry *e;
+
+  if (l->len >= CONNECTION_LIST_SIZE)
+    {
+      msg (msglevel, "Maximum number of 'remote' options (%d) exceeded", CONNECTION_LIST_SIZE);
+      return NULL;
+    }
+  ALLOC_OBJ_GC (e, struct remote_entry, &options->gc);
+  l->array[l->len++] = e;
+  return e;
 }
 
 #endif
 
-/*
- * Sanity check on options.
- * Also set some options based on other
- * options.
- */
 void
-options_postprocess (struct options *options, bool first_time)
+connection_entry_load_re (struct connection_entry *ce, const struct remote_entry *re)
+{
+  if (re->remote)
+    ce->remote = re->remote;
+  if (re->remote_port >= 0)
+    ce->remote_port = re->remote_port;
+  if (re->proto >= 0)
+    ce->proto = re->proto;
+}
+
+static void
+options_postprocess_verify_ce (const struct options *options, const struct connection_entry *ce)
 {
   struct options defaults;
   int dev = DEV_TYPE_UNDEF;
-  int i;
   bool pull = false;
 
-  init_options (&defaults);
+  init_options (&defaults, true);
 
 #ifdef USE_CRYPTO
   if (options->test_crypto)
@@ -1359,31 +1448,11 @@
   dev = dev_type_enum (options->dev, options->dev_type);
 
   /*
-   * Fill in default port number for --remote list
-   */
-  if (options->remote_list)
-    {
-      for (i = 0; i < options->remote_list->len; ++i)
-	{
-	  struct remote_entry *e = &options->remote_list->array[i];
-	  if (e->port < 0)
-	    e->port = options->remote_port;
-	}
-    }
-
-  /*
-   * If --mssfix is supplied without a parameter, default
-   * it to --fragment value, if --fragment is specified.
+   * If "proto tcp" is specified, make sure we know whether it is
+   * tcp-client or tcp-server.
    */
-  if (options->mssfix_default)
-    {
-#ifdef ENABLE_FRAGMENT
-      if (options->fragment)
-	options->mssfix = options->fragment;
-#else
-      msg (M_USAGE, "--mssfix must specify a parameter");
-#endif      
-    }
+  if (ce->proto == PROTO_TCPv4)
+    msg (M_USAGE, "--proto tcp is ambiguous in this context.  Please specify --proto tcp-server or --proto tcp-client");
 
   /*
    * Sanity check on daemon/inetd modes
@@ -1392,13 +1461,13 @@
   if (options->daemon && options->inetd)
     msg (M_USAGE, "only one of --daemon or --inetd may be specified");
 
-  if (options->inetd && (options->local || options->remote_list))
+  if (options->inetd && (ce->local || ce->remote))
     msg (M_USAGE, "--local or --remote cannot be used with --inetd");
 
-  if (options->inetd && options->proto == PROTO_TCPv4_CLIENT)
+  if (options->inetd && ce->proto == PROTO_TCPv4_CLIENT)
     msg (M_USAGE, "--proto tcp-client cannot be used with --inetd");
 
-  if (options->inetd == INETD_NOWAIT && options->proto != PROTO_TCPv4_SERVER)
+  if (options->inetd == INETD_NOWAIT && ce->proto != PROTO_TCPv4_SERVER)
     msg (M_USAGE, "--inetd nowait can only be used with --proto tcp-server");
 
   if (options->inetd == INETD_NOWAIT
@@ -1416,20 +1485,13 @@
     msg (M_USAGE, "--lladdr can only be used in --dev tap mode");
  
   /*
-   * In forking TCP server mode, you don't need to ifconfig
-   * the tap device (the assumption is that it will be bridged).
-   */
-  if (options->inetd == INETD_NOWAIT)
-    options->ifconfig_noexec = true;
-
-  /*
    * Sanity check on TCP mode options
    */
 
-  if (options->connect_retry_defined && options->proto != PROTO_TCPv4_CLIENT)
+  if (ce->connect_retry_defined && ce->proto != PROTO_TCPv4_CLIENT)
     msg (M_USAGE, "--connect-retry doesn't make sense unless also used with --proto tcp-client");
 
-  if (options->connect_timeout_defined && options->proto != PROTO_TCPv4_CLIENT)
+  if (ce->connect_timeout_defined && ce->proto != PROTO_TCPv4_CLIENT)
     msg (M_USAGE, "--connect-timeout doesn't make sense unless also used with --proto tcp-client");
 
   /*
@@ -1439,32 +1501,10 @@
     msg (M_USAGE, "only one of --tun-mtu or --link-mtu may be defined (note that --ifconfig implies --link-mtu %d)", LINK_MTU_DEFAULT);
 
 #ifdef ENABLE_OCC
-  if (options->proto != PROTO_UDPv4 && options->mtu_test)
+  if (ce->proto != PROTO_UDPv4 && options->mtu_test)
     msg (M_USAGE, "--mtu-test only makes sense with --proto udp");
 #endif
 
-  /*
-   * Set MTU defaults
-   */
-  {
-    if (!options->tun_mtu_defined && !options->link_mtu_defined)
-      {
-	options->tun_mtu_defined = true;
-      }
-    if ((dev == DEV_TYPE_TAP) && !options->tun_mtu_extra_defined)
-      {
-	options->tun_mtu_extra_defined = true;
-	options->tun_mtu_extra = TAP_MTU_EXTRA_DEFAULT;
-      }
-  }
-
-  /*
-   * Process helper-type options which map to other, more complex
-   * sequences of options.
-   */
-  helper_client_server (options);
-  helper_keepalive (options);
-
   /* will we be pulling options from server? */
 #if P2MP
   pull = options->pull;
@@ -1474,63 +1514,39 @@
    * Sanity check on --local, --remote, and --ifconfig
    */
 
-  if (options->remote_list)
-    {
-      int i;
-      struct remote_list *l = options->remote_list;
-
-      for (i = 0; i < l->len; ++i)
-	{
-	  const char *remote = l->array[i].hostname;
-	  const int remote_port = l->array[i].port;
-
-	  if (string_defined_equal (options->local, remote)
-	      && options->local_port == remote_port)
-	    msg (M_USAGE, "--remote and --local addresses are the same");
-	
-	  if (string_defined_equal (remote, options->ifconfig_local)
-	      || string_defined_equal (remote, options->ifconfig_remote_netmask))
-	    msg (M_USAGE, "--local and --remote addresses must be distinct from --ifconfig addresses");
-	}
-    }
+  if (string_defined_equal (ce->local, ce->remote)
+      && ce->local_port == ce->remote_port)
+    msg (M_USAGE, "--remote and --local addresses are the same");
+  
+  if (string_defined_equal (ce->remote, options->ifconfig_local)
+      || string_defined_equal (ce->remote, options->ifconfig_remote_netmask))
+    msg (M_USAGE, "--local and --remote addresses must be distinct from --ifconfig addresses");
 
-  if (string_defined_equal (options->local, options->ifconfig_local)
-      || string_defined_equal (options->local, options->ifconfig_remote_netmask))
+  if (string_defined_equal (ce->local, options->ifconfig_local)
+      || string_defined_equal (ce->local, options->ifconfig_remote_netmask))
     msg (M_USAGE, "--local addresses must be distinct from --ifconfig addresses");
 
   if (string_defined_equal (options->ifconfig_local, options->ifconfig_remote_netmask))
     msg (M_USAGE, "local and remote/netmask --ifconfig addresses must be different");
 
-  if (options->bind_defined && !options->bind_local)
+  if (ce->bind_defined && !ce->bind_local)
     msg (M_USAGE, "--bind and --nobind can't be used together");
 
-  if (options->local && !options->bind_local)
+  if (ce->local && !ce->bind_local)
     msg (M_USAGE, "--local and --nobind don't make sense when used together");
 
-  if (options->local_port_defined && !options->bind_local)
+  if (ce->local_port_defined && !ce->bind_local)
     msg (M_USAGE, "--lport and --nobind don't make sense when used together");
 
-  if (!options->remote_list && !options->bind_local)
+  if (!ce->remote && !ce->bind_local)
     msg (M_USAGE, "--nobind doesn't make sense unless used with --remote");
 
-  if (options->proto == PROTO_TCPv4_CLIENT && !options->local && !options->local_port_defined && !options->bind_defined)
-    options->bind_local = false;
-
-#ifdef ENABLE_SOCKS
-  if (options->proto == PROTO_UDPv4 && options->socks_proxy_server && !options->local && !options->local_port_defined && !options->bind_defined)
-    options->bind_local = false;
-#endif
-
-  if (!options->bind_local)
-    options->local_port = 0;
-
   /*
    * Check for consistency of management options
    */
 #ifdef ENABLE_MANAGEMENT
   if (!options->management_addr &&
-      (options->management_query_passwords || options->management_hold || options->management_signal
-       || options->management_forget_disconnect || options->management_client
+      (options->management_flags
        || options->management_write_peer_info_file
        || options->management_log_history_cache != defaults.management_log_history_cache))
     msg (M_USAGE, "--management is not specified, however one or more options which modify the behavior of --management were specified");
@@ -1552,18 +1568,6 @@
 	  && options->tuntap_options.ip_win32_type != IPW32_SET_DHCP_MASQ
 	  && options->tuntap_options.ip_win32_type != IPW32_SET_ADAPTIVE)
 	msg (M_USAGE, "--dhcp-options requires --ip-win32 dynamic or adaptive");
-
-      if ((dev == DEV_TYPE_TUN || dev == DEV_TYPE_TAP) && !options->route_delay_defined)
-	{
-	  options->route_delay_defined = true;
-	  options->route_delay = 5; /* Vista sometimes has a race without this */
-	}
-
-      if (options->ifconfig_noexec)
-	{
-	  options->tuntap_options.ip_win32_type = IPW32_SET_MANUAL;
-	  options->ifconfig_noexec = false;
-	}
 #endif
 
   /*
@@ -1571,34 +1575,34 @@
    */
 
 #ifdef ENABLE_FRAGMENT
-  if (options->proto != PROTO_UDPv4 && options->fragment)
+  if (ce->proto != PROTO_UDPv4 && options->fragment)
     msg (M_USAGE, "--fragment can only be used with --proto udp");
 #endif
 
 #ifdef ENABLE_OCC
-  if (options->proto != PROTO_UDPv4 && options->explicit_exit_notification)
+  if (ce->proto != PROTO_UDPv4 && options->explicit_exit_notification)
     msg (M_USAGE, "--explicit-exit-notify can only be used with --proto udp");
 #endif
 
-  if (!options->remote_list && options->proto == PROTO_TCPv4_CLIENT)
+  if (!ce->remote && ce->proto == PROTO_TCPv4_CLIENT)
     msg (M_USAGE, "--remote MUST be used in TCP Client mode");
 
 #ifdef ENABLE_HTTP_PROXY
-  if ((options->http_proxy_options || options->auto_proxy_info) && options->proto != PROTO_TCPv4_CLIENT)
+  if ((ce->http_proxy_options || options->auto_proxy_info) && ce->proto != PROTO_TCPv4_CLIENT)
     msg (M_USAGE, "--http-proxy or --auto-proxy MUST be used in TCP Client mode (i.e. --proto tcp-client)");
 #endif
 
 #if defined(ENABLE_HTTP_PROXY) && defined(ENABLE_SOCKS)
-  if (options->http_proxy_options && options->socks_proxy_server)
+  if (ce->http_proxy_options && ce->socks_proxy_server)
     msg (M_USAGE, "--http-proxy can not be used together with --socks-proxy");
 #endif
 
 #ifdef ENABLE_SOCKS
-  if (options->socks_proxy_server && options->proto == PROTO_TCPv4_SERVER)
+  if (ce->socks_proxy_server && ce->proto == PROTO_TCPv4_SERVER)
     msg (M_USAGE, "--socks-proxy can not be used in TCP Server mode");
 #endif
 
-  if (options->proto == PROTO_TCPv4_SERVER && remote_list_len (options->remote_list) > 1)
+  if (ce->proto == PROTO_TCPv4_SERVER && connection_list_defined (options))
     msg (M_USAGE, "TCP server mode allows at most one --remote address");
 
 #if P2MP_SERVER
@@ -1608,41 +1612,34 @@
    */
   if (options->mode == MODE_SERVER)
     {
-#ifdef WIN32
-      /*
-       * We need to explicitly set --tap-sleep because
-       * we do not schedule event timers in the top-level context.
-       */
-      options->tuntap_options.tap_sleep = 10;
-      if (options->route_delay_defined && options->route_delay)
-	options->tuntap_options.tap_sleep = options->route_delay;	
-      options->route_delay_defined = false;
-#endif
-
       if (!(dev == DEV_TYPE_TUN || dev == DEV_TYPE_TAP))
 	msg (M_USAGE, "--mode server only works with --dev tun or --dev tap");
       if (options->pull)
 	msg (M_USAGE, "--pull cannot be used with --mode server");
-      if (!(options->proto == PROTO_UDPv4 || options->proto == PROTO_TCPv4_SERVER))
+      if (!(ce->proto == PROTO_UDPv4 || ce->proto == PROTO_TCPv4_SERVER))
 	msg (M_USAGE, "--mode server currently only supports --proto udp or --proto tcp-server");
 #if PORT_SHARE
-      if ((options->port_share_host || options->port_share_port) && options->proto != PROTO_TCPv4_SERVER)
+      if ((options->port_share_host || options->port_share_port) && ce->proto != PROTO_TCPv4_SERVER)
 	msg (M_USAGE, "--port-share only works in TCP server mode (--proto tcp-server)");
 #endif
       if (!options->tls_server)
 	msg (M_USAGE, "--mode server requires --tls-server");
-      if (options->remote_list)
+      if (ce->remote)
 	msg (M_USAGE, "--remote cannot be used with --mode server");
-      if (!options->bind_local)
+      if (!ce->bind_local)
 	msg (M_USAGE, "--nobind cannot be used with --mode server");
 #ifdef ENABLE_HTTP_PROXY
-      if (options->http_proxy_options)
+      if (ce->http_proxy_options)
 	msg (M_USAGE, "--http-proxy cannot be used with --mode server");
 #endif
 #ifdef ENABLE_SOCKS
-      if (options->socks_proxy_server)
+      if (ce->socks_proxy_server)
 	msg (M_USAGE, "--socks-proxy cannot be used with --mode server");
 #endif
+#ifdef ENABLE_CONNECTION
+      if (options->connection_list)
+	msg (M_USAGE, "<connection> cannot be used with --mode server");
+#endif
       if (options->tun_ipv6)
 	msg (M_USAGE, "--tun-ipv6 cannot be used with --mode server");
       if (options->shaper)
@@ -1651,9 +1648,9 @@
 	msg (M_USAGE, "--inetd cannot be used with --mode server");
       if (options->ipchange)
 	msg (M_USAGE, "--ipchange cannot be used with --mode server (use --client-connect instead)");
-      if (!(options->proto == PROTO_UDPv4 || options->proto == PROTO_TCPv4_SERVER))
+      if (!(ce->proto == PROTO_UDPv4 || ce->proto == PROTO_TCPv4_SERVER))
 	msg (M_USAGE, "--mode server currently only supports --proto udp or --proto tcp-server");
-      if (options->proto != PROTO_UDPv4 && (options->cf_max || options->cf_per))
+      if (ce->proto != PROTO_UDPv4 && (options->cf_max || options->cf_per))
 	msg (M_USAGE, "--connect-freq only works with --mode server --proto udp.  Try --max-clients instead.");
       if (!(dev == DEV_TYPE_TAP || (dev == DEV_TYPE_TUN && options->topology == TOP_SUBNET)) && options->ifconfig_pool_netmask)
 	msg (M_USAGE, "The third parameter to --ifconfig-pool (netmask) is only valid in --dev tap mode");
@@ -1676,12 +1673,15 @@
       if (options->key_method != 2)
 	msg (M_USAGE, "--mode server requires --key-method 2");
 
-      if (PLUGIN_OPTION_LIST (options) == NULL)
 	{
-	  if (options->client_cert_not_required && !options->auth_user_pass_verify_script)
-	    msg (M_USAGE, "--client-cert-not-required must be used with an --auth-user-pass-verify script");
-	  if (options->username_as_common_name && !options->auth_user_pass_verify_script)
-	    msg (M_USAGE, "--username-as-common-name must be used with an --auth-user-pass-verify script");
+	  const bool ccnr = (options->auth_user_pass_verify_script
+			     || PLUGIN_OPTION_LIST (options)
+			     || MAN_CLIENT_AUTH_ENABLED (options));
+	  const char *postfix = "must be used with --management-client-auth, an --auth-user-pass-verify script, or plugin";
+	  if (options->client_cert_not_required && !ccnr)
+	    msg (M_USAGE, "--client-cert-not-required %s", postfix);
+	  if (options->username_as_common_name && !ccnr)
+	    msg (M_USAGE, "--username-as-common-name %s", postfix);
 	}
     }
   else
@@ -1730,7 +1730,7 @@
   /*
    * Check consistency of replay options
    */
-  if ((options->proto != PROTO_UDPv4)
+  if ((ce->proto != PROTO_UDPv4)
       && (options->replay_window != defaults.replay_window
 	  || options->replay_time != defaults.replay_time))
     msg (M_USAGE, "--replay-window only makes sense with --proto udp");
@@ -1740,13 +1740,6 @@
 	  || options->replay_time != defaults.replay_time))
     msg (M_USAGE, "--replay-window doesn't make sense when replay protection is disabled with --no-replay");
 
-  /* 
-   * Don't use replay window for TCP mode (i.e. require that packets
-   * be strictly in sequence).
-   */
-  if (link_socket_proto_connection_oriented (options->proto))
-    options->replay_window = options->replay_time = 0;
-
   /*
    * SSL/TLS mode sanity checks.
    */
@@ -1766,8 +1759,11 @@
       if (options->pkcs11_providers[0])
        {
         notnull (options->ca_file, "CA file (--ca)");
-	notnull (options->pkcs11_id, "PKCS#11 id (--pkcs11-id)");
 
+	if (options->pkcs11_id_management && options->pkcs11_id != NULL)
+	  msg(M_USAGE, "Parameter --pkcs11-id cannot be used when --pkcs11-id-management is also specified.");
+	if (!options->pkcs11_id_management && options->pkcs11_id == NULL)
+	  msg(M_USAGE, "Parameter --pkcs11-id or --pkcs11-id-management should be specified.");
 	if (options->cert_file)
 	  msg(M_USAGE, "Parameter --cert cannot be used when --pkcs11-provider is also specified.");
 	if (options->priv_key_file)
@@ -1870,6 +1866,7 @@
       MUST_BE_UNDEF (pkcs11_providers[0]);
       MUST_BE_UNDEF (pkcs11_private_mode[0]);
       MUST_BE_UNDEF (pkcs11_id);
+      MUST_BE_UNDEF (pkcs11_id_management);
 #endif
 
       if (pull)
@@ -1880,30 +1877,211 @@
 #endif /* USE_SSL */
 
 #if P2MP
+  if (options->auth_user_pass_file && !options->pull)
+    msg (M_USAGE, "--auth-user-pass requires --pull");
+#endif
+
+  uninit_options (&defaults);
+}
+
+static void
+options_postprocess_mutate_ce (struct options *o, struct connection_entry *ce)
+{
+#if P2MP_SERVER
+  if (o->server_defined || o->server_bridge_defined)
+    {
+      if (ce->proto == PROTO_TCPv4)
+	ce->proto = PROTO_TCPv4_SERVER;
+    }
+#endif
+#if P2MP
+  if (o->client)
+    {
+      if (ce->proto == PROTO_TCPv4)
+	ce->proto = PROTO_TCPv4_CLIENT;
+    }
+#endif
+
+  if (ce->proto == PROTO_TCPv4_CLIENT && !ce->local && !ce->local_port_defined && !ce->bind_defined)
+    ce->bind_local = false;
+
+#ifdef ENABLE_SOCKS
+  if (ce->proto == PROTO_UDPv4 && ce->socks_proxy_server && !ce->local && !ce->local_port_defined && !ce->bind_defined)
+    ce->bind_local = false;
+#endif
+
+  if (!ce->bind_local)
+    ce->local_port = 0;
+}
+
+static void
+options_postprocess_mutate_invariant (struct options *options)
+{
+  const int dev = dev_type_enum (options->dev, options->dev_type);
+
   /*
-   * In pull mode, we usually import --ping/--ping-restart parameters from
-   * the server.  However we should also set an initial default --ping-restart
-   * for the period of time before we pull the --ping-restart parameter
-   * from the server.
+   * If --mssfix is supplied without a parameter, default
+   * it to --fragment value, if --fragment is specified.
    */
-  if (options->pull
-      && options->ping_rec_timeout_action == PING_UNDEF
-      && options->proto == PROTO_UDPv4)
+  if (options->mssfix_default)
     {
-      options->ping_rec_timeout = PRE_PULL_INITIAL_PING_RESTART;
-      options->ping_rec_timeout_action = PING_RESTART;
+#ifdef ENABLE_FRAGMENT
+      if (options->fragment)
+	options->mssfix = options->fragment;
+#else
+      msg (M_USAGE, "--mssfix must specify a parameter");
+#endif      
     }
 
-  if (options->auth_user_pass_file && !options->pull)
-    msg (M_USAGE, "--auth-user-pass requires --pull");
+  /*
+   * In forking TCP server mode, you don't need to ifconfig
+   * the tap device (the assumption is that it will be bridged).
+   */
+  if (options->inetd == INETD_NOWAIT)
+    options->ifconfig_noexec = true;
+
+  /*
+   * Set MTU defaults
+   */
+  {
+    if (!options->tun_mtu_defined && !options->link_mtu_defined)
+      {
+	options->tun_mtu_defined = true;
+      }
+    if ((dev == DEV_TYPE_TAP) && !options->tun_mtu_extra_defined)
+      {
+	options->tun_mtu_extra_defined = true;
+	options->tun_mtu_extra = TAP_MTU_EXTRA_DEFAULT;
+      }
+  }
+
+#ifdef WIN32
+  if ((dev == DEV_TYPE_TUN || dev == DEV_TYPE_TAP) && !options->route_delay_defined)
+    {
+      if (options->mode == MODE_POINT_TO_POINT)
+	{
+	  options->route_delay_defined = true;
+	  options->route_delay = 5; /* Vista sometimes has a race without this */
+	}
+    }
+
+  if (options->ifconfig_noexec)
+    {
+      options->tuntap_options.ip_win32_type = IPW32_SET_MANUAL;
+      options->ifconfig_noexec = false;
+    }
+#endif
 
+#if P2MP_SERVER
+  /*
+   * Check consistency of --mode server options.
+   */
+  if (options->mode == MODE_SERVER)
+    {
+#ifdef WIN32
+      /*
+       * We need to explicitly set --tap-sleep because
+       * we do not schedule event timers in the top-level context.
+       */
+      options->tuntap_options.tap_sleep = 10;
+      if (options->route_delay_defined && options->route_delay)
+	options->tuntap_options.tap_sleep = options->route_delay;	
+      options->route_delay_defined = false;
+#endif
+    }
+#endif
+}
+
+static void
+options_postprocess_verify (const struct options *o)
+{
+#ifdef ENABLE_CONNECTION
+  if (o->connection_list)
+    {
+      int i;
+      for (i = 0; i < o->connection_list->len; ++i)
+	options_postprocess_verify_ce (o, o->connection_list->array[i]);
+    }
+  else
+#endif
+    options_postprocess_verify_ce (o, &o->ce);
+}
+
+static void
+options_postprocess_mutate (struct options *o)
+{
+  /*
+   * Process helper-type options which map to other, more complex
+   * sequences of options.
+   */
+  helper_client_server (o);
+  helper_keepalive (o);
+
+  options_postprocess_mutate_invariant (o);
+
+#ifdef ENABLE_CONNECTION
+  if (o->remote_list && !o->connection_list)
+    {
+      /*
+       * For compatibility with 2.0.x, map multiple --remote options
+       * into connection list (connection lists added in 2.1).
+       */
+      if (o->remote_list->len > 1)
+	{
+	  const struct remote_list *rl = o->remote_list;
+	  int i;
+	  for (i = 0; i < rl->len; ++i)
+	    {
+	      const struct remote_entry *re = rl->array[i];
+	      struct connection_entry ce = o->ce;
+	      struct connection_entry *ace;
+
+	      ASSERT (re->remote);
+	      connection_entry_load_re (&ce, re);
+	      ace = alloc_connection_entry (o, M_USAGE);
+	      ASSERT (ace);
+	      *ace = ce;
+	    }
+	}
+      else if (o->remote_list->len == 1) /* one --remote option specfied */
+	{
+	  connection_entry_load_re (&o->ce, o->remote_list->array[0]);
+	}
+      else
+	{
+	  ASSERT (0);
+	}
+    }
+  if (o->connection_list)
+    {
+      int i;
+      for (i = 0; i < o->connection_list->len; ++i)
+	options_postprocess_mutate_ce (o, o->connection_list->array[i]);
+    }
+  else
+#endif
+    options_postprocess_mutate_ce (o, &o->ce);  
+
+#if P2MP
   /*
    * Save certain parms before modifying options via --pull
    */
-  pre_pull_save (options);
+  pre_pull_save (o);
 #endif
 }
 
+/*
+ * Sanity check on options.
+ * Also set some options based on other
+ * options.
+ */
+void
+options_postprocess (struct options *options)
+{
+  options_postprocess_mutate (options);
+  options_postprocess_verify (options);
+}
+
 #if P2MP
 
 /*
@@ -2016,7 +2194,7 @@
   buf_printf (&out, ",dev-type %s", dev_type_string (o->dev, o->dev_type));
   buf_printf (&out, ",link-mtu %d", EXPANDED_SIZE (frame));
   buf_printf (&out, ",tun-mtu %d", PAYLOAD_SIZE (frame));
-  buf_printf (&out, ",proto %s", proto2ascii (proto_remote (o->proto, remote), true));
+  buf_printf (&out, ",proto %s", proto2ascii (proto_remote (o->ce.proto, remote), true));
   if (o->tun_ipv6)
     buf_printf (&out, ",tun-ipv6");
 
@@ -2324,20 +2502,24 @@
       struct buffer value = alloc_buf_gc (OPTION_PARM_SIZE, &gc);
       int i;
       bool first = true;
+      bool good = true;
 
-      buf_printf (&name, "foreign_option_%d", o->foreign_option_index + 1);
+      good &= buf_printf (&name, "foreign_option_%d", o->foreign_option_index + 1);
       ++o->foreign_option_index;
       for (i = 0; i < len; ++i)
 	{
 	  if (argv[i])
 	    {
 	      if (!first)
-		buf_printf (&value, " ");
-	      buf_printf (&value, "%s", argv[i]);
+		good &= buf_printf (&value, " ");
+	      good &= buf_printf (&value, "%s", argv[i]);
 	      first = false;
 	    }
 	}
-      setenv_str (es, BSTR(&name), BSTR(&value));
+      if (good)
+	setenv_str (es, BSTR(&name), BSTR(&value));
+      else
+	msg (M_WARN, "foreign_option: name/value overflow");
       gc_free (&gc);
     }
 }
@@ -2444,13 +2626,13 @@
 #else
 
   struct options o;
-  init_options (&o);
+  init_options (&o, true);
 
 #if defined(USE_CRYPTO) && defined(USE_SSL)
   fprintf (fp, usage_message,
 	   title_string,
-	   o.connect_retry_seconds,
-	   o.local_port, o.remote_port,
+	   o.ce.connect_retry_seconds,
+	   o.ce.local_port, o.ce.remote_port,
 	   TUN_MTU_DEFAULT, TAP_MTU_EXTRA_DEFAULT,
 	   o.verbosity,
 	   o.authname, o.ciphername,
@@ -2460,8 +2642,8 @@
 #elif defined(USE_CRYPTO)
   fprintf (fp, usage_message,
 	   title_string,
-	   o.connect_retry_seconds,
-	   o.local_port, o.remote_port,
+	   o.ce.connect_retry_seconds,
+	   o.ce.local_port, o.ce.remote_port,
 	   TUN_MTU_DEFAULT, TAP_MTU_EXTRA_DEFAULT,
 	   o.verbosity,
 	   o.authname, o.ciphername,
@@ -2469,8 +2651,8 @@
 #else
   fprintf (fp, usage_message,
 	   title_string,
-	   o.connect_retry_seconds,
-	   o.local_port, o.remote_port,
+	   o.ce.connect_retry_seconds,
+	   o.ce.local_port, o.ce.remote_port,
 	   TUN_MTU_DEFAULT, TAP_MTU_EXTRA_DEFAULT,
 	   o.verbosity);
 #endif
@@ -2493,7 +2675,7 @@
 {
   msg (M_INFO|M_NOPREFIX, "%s", title_string);
   msg (M_INFO|M_NOPREFIX, "Developed by James Yonan");
-  msg (M_INFO|M_NOPREFIX, "Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>");
+  msg (M_INFO|M_NOPREFIX, "Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>");
   openvpn_exit (OPENVPN_EXIT_STATUS_USAGE); /* exit point */
 }
 
@@ -2733,7 +2915,7 @@
     {
       if (!strncmp (line, close_tag, strlen (close_tag)))
 	break;
-      buf_printf (&buf, line);
+      buf_printf (&buf, "%s", line);
     }
   ret = string_alloc (BSTR (&buf), gc);
   buf_clear (&buf);
@@ -2850,14 +3032,14 @@
 }
 
 static void
-read_config_string (struct options *options,
+read_config_string (const char *prefix,
+		    struct options *options,
 		    const char *config,
 		    const int msglevel,
 		    const unsigned int permission_mask,
 		    unsigned int *option_types_found,
 		    struct env_set *es)
 {
-  const char *file = "[CONFIG-STRING]";
   char line[OPTION_LINE_SIZE];
   struct buffer multiline;
   int line_num = 0;
@@ -2869,7 +3051,7 @@
       char *p[MAX_PARMS];
       CLEAR (p);
       ++line_num;
-      if (parse_line (line, p, SIZE (p), file, line_num, msglevel, &options->gc))
+      if (parse_line (line, p, SIZE (p), prefix, line_num, msglevel, &options->gc))
 	{
 	  bypass_doubledash (&p[0]);
 #if ENABLE_INLINE_FILES
@@ -2983,20 +3165,16 @@
 		    es);
 }
 
-#ifdef ENABLE_PLUGIN
-
-void options_plugin_import (struct options *options,
+void options_string_import (struct options *options,
 			    const char *config,
 			    const int msglevel,
 			    const unsigned int permission_mask,
 			    unsigned int *option_types_found,
 			    struct env_set *es)
 {
-  read_config_string (options, config, msglevel, permission_mask, option_types_found, es);
+  read_config_string ("[CONFIG-STRING]", options, config, msglevel, permission_mask, option_types_found, es);
 }
 
-#endif
-
 #if P2MP
 
 #define VERIFY_PERMISSION(mask) { if (!verify_permission(p[0], (mask), permission_mask, option_types_found, msglevel)) goto err; }
@@ -3071,6 +3249,7 @@
 {
   struct gc_arena gc = gc_new ();
   ASSERT (MAX_PARMS >= 5);
+  const bool pull_mode = BOOL_CAST (permission_mask & OPT_P_PULL_MODE);
 
   if (!file)
     {
@@ -3097,11 +3276,18 @@
 
       read_config_file (options, p[1], level, file, line, msglevel, permission_mask, option_types_found, es);
     }
+#if 0
+  else if (streq (p[0], "foreign-option") && p[1])
+    {
+      VERIFY_PERMISSION (OPT_P_IPWIN32);
+      foreign_option (options, p, 3, es);
+    }
+#endif
   else if (streq (p[0], "echo") || streq (p[0], "parameter"))
     {
       struct buffer string = alloc_buf_gc (OPTION_PARM_SIZE, &gc);
       int j;
-      const bool pull_mode = BOOL_CAST (permission_mask & OPT_P_PULL_MODE);
+      bool good = true;
 
       VERIFY_PERMISSION (OPT_P_ECHO);
 
@@ -3110,16 +3296,21 @@
 	  if (!p[j])
 	    break;
 	  if (j > 1)
-	    buf_printf (&string, " ");
-	  buf_printf (&string, "%s", p[j]);
+	    good &= buf_printf (&string, " ");
+	  good &= buf_printf (&string, "%s", p[j]);
 	}
-      msg (M_INFO, "%s:%s",
-	   pull_mode ? "ECHO-PULL" : "ECHO",
-	   BSTR (&string));
+      if (good)
+	{
+	  msg (M_INFO, "%s:%s",
+	       pull_mode ? "ECHO-PULL" : "ECHO",
+	       BSTR (&string));
 #ifdef ENABLE_MANAGEMENT
-      if (management)
-	management_echo (management, BSTR (&string), pull_mode);
+	  if (management)
+	    management_echo (management, BSTR (&string), pull_mode);
 #endif
+	}
+      else
+	msg (M_WARN, "echo/parameter option overflow");
     }
 #ifdef ENABLE_MANAGEMENT
   else if (streq (p[0], "management") && p[1] && p[2])
@@ -3144,29 +3335,43 @@
   else if (streq (p[0], "management-query-passwords"))
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->management_query_passwords = true;
+      options->management_flags |= MF_QUERY_PASSWORDS;
     }
   else if (streq (p[0], "management-hold"))
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->management_hold = true;
+      options->management_flags |= MF_HOLD;
     }
   else if (streq (p[0], "management-signal"))
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->management_signal = true;
+      options->management_flags |= MF_SIGNAL;
     }
   else if (streq (p[0], "management-forget-disconnect"))
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->management_forget_disconnect = true;
+      options->management_flags |= MF_FORGET_DISCONNECT;
     }
   else if (streq (p[0], "management-client"))
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->management_client = true;
+      options->management_flags |= MF_CONNECT_AS_CLIENT;
       options->management_write_peer_info_file = p[1];
     }
+#ifdef MANAGEMENT_DEF_AUTH
+  else if (streq (p[0], "management-client-auth"))
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      options->management_flags |= MF_CLIENT_AUTH;
+    }
+#endif
+#ifdef MANAGEMENT_PF
+  else if (streq (p[0], "management-client-pf"))
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      options->management_flags |= (MF_CLIENT_PF | MF_CLIENT_AUTH);
+    }
+#endif
   else if (streq (p[0], "management-log-cache") && p[1])
     {
       int cache;
@@ -3227,7 +3432,13 @@
   else if (streq (p[0], "lladdr") && p[1])
     {
       VERIFY_PERMISSION (OPT_P_UP);
-      options->lladdr = p[1];
+      if (ip_addr_dotted_quad_safe (p[1]))
+	options->lladdr = p[1];
+      else
+	{
+	  msg (msglevel, "lladdr parm '%s' must be an IP address", p[1]);
+	  goto err;
+	}
     }
   else if (streq (p[0], "topology") && p[1])
     {
@@ -3242,15 +3453,23 @@
 #ifdef CONFIG_FEATURE_IPROUTE
   else if (streq (p[0], "iproute") && p[1])
     {
-      VERIFY_PERMISSION (OPT_P_UP);
+      VERIFY_PERMISSION (OPT_P_GENERAL);
       iproute_path = p[1];
     }
 #endif
   else if (streq (p[0], "ifconfig") && p[1] && p[2])
     {
       VERIFY_PERMISSION (OPT_P_UP);
-      options->ifconfig_local = p[1];
-      options->ifconfig_remote_netmask = p[2];
+      if (ip_addr_dotted_quad_safe (p[1]) && ip_addr_dotted_quad_safe (p[2]))
+	{
+	  options->ifconfig_local = p[1];
+	  options->ifconfig_remote_netmask = p[2];
+	}
+      else
+	{
+	  msg (msglevel, "ifconfig parms '%s' and '%s' must be IP addresses", p[1], p[2]);
+	  goto err;
+	}
     }
   else if (streq (p[0], "ifconfig-noexec"))
     {
@@ -3264,41 +3483,82 @@
     }
   else if (streq (p[0], "local") && p[1])
     {
-      VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->local = p[1];
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+      options->ce.local = p[1];
     }
   else if (streq (p[0], "remote-random"))
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
       options->remote_random = true;
     }
-  else if (streq (p[0], "remote") && p[1])
+#if ENABLE_CONNECTION
+  else if (streq (p[0], "connection") && p[1])
     {
-      struct remote_list *l;
-      struct remote_entry e;
-
       VERIFY_PERMISSION (OPT_P_GENERAL);
-      if (!options->remote_list)
-	ALLOC_OBJ_CLEAR_GC (options->remote_list, struct remote_list, &options->gc);
-      l = options->remote_list;
-      if (l->len >= REMOTE_LIST_SIZE)
+      if (streq (p[1], INLINE_FILE_TAG) && p[2])
 	{
-	  msg (msglevel, "Maximum number of --remote options (%d) exceeded", REMOTE_LIST_SIZE);
-	  goto err;
+	  struct options sub;
+	  struct connection_entry *e;
+
+	  init_options (&sub, true);
+	  sub.ce = options->ce;
+	  read_config_string ("[CONNECTION-OPTIONS]", &sub, p[2], msglevel, OPT_P_CONNECTION, option_types_found, es);
+	  if (!sub.ce.remote)
+	    {
+	      msg (msglevel, "Each 'connection' block must contain exactly one 'remote' directive");
+	      goto err;
+	    }
+
+	  e = alloc_connection_entry (options, msglevel);
+	  if (!e)
+	    goto err;
+	  *e = sub.ce;
+	  gc_transfer (&options->gc, &sub.gc);
+	  uninit_options (&sub);
 	}
-      e.hostname = p[1];
+    }
+#endif
+  else if (streq (p[0], "remote") && p[1])
+    {
+      struct remote_entry re;
+      re.remote = NULL;
+      re.remote_port = re.proto = -1;
+
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+      re.remote = p[1];
       if (p[2])
 	{
-	  e.port = atoi (p[2]);
-	  if (!legal_ipv4_port (e.port))
+	  const int port = atoi (p[2]);
+	  if (!legal_ipv4_port (port))
 	    {
-	      msg (msglevel, "port number associated with host %s is out of range", e.hostname);
+	      msg (msglevel, "remote: port number associated with host %s is out of range", p[1]);
 	      goto err;
 	    }
+	  re.remote_port = port;
+	  if (p[3])
+	    {
+	      const int proto = ascii2proto (p[3]);
+	      if (proto < 0)
+		{
+		  msg (msglevel, "remote: bad protocol associated with host %s: '%s'", p[1], p[3]);
+		  goto err;
+		}
+	      re.proto = proto;
+	    }
+	}
+#ifdef ENABLE_CONNECTION
+      if (permission_mask & OPT_P_GENERAL)
+	{
+	  struct remote_entry *e = alloc_remote_entry (options, msglevel);
+	  if (!e)
+	    goto err;
+	  *e = re;
+	}
+      else if (permission_mask & OPT_P_CONNECTION)
+#endif
+	{
+	  connection_entry_load_re (&options->ce, &re);
 	}
-      else
-	e.port = -1;
-      l->array[l->len++] = e;
     }
   else if (streq (p[0], "resolv-retry") && p[1])
     {
@@ -3310,20 +3570,20 @@
     }
   else if (streq (p[0], "connect-retry") && p[1])
     {
-      VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->connect_retry_seconds = positive_atoi (p[1]);
-      options->connect_retry_defined = true;
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+      options->ce.connect_retry_seconds = positive_atoi (p[1]);
+      options->ce.connect_retry_defined = true;
     }
   else if (streq (p[0], "connect-timeout") && p[1])
     {
-      VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->connect_timeout = positive_atoi (p[1]);
-      options->connect_timeout_defined = true;
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+      options->ce.connect_timeout = positive_atoi (p[1]);
+      options->ce.connect_timeout_defined = true;
     }
   else if (streq (p[0], "connect-retry-max") && p[1])
     {
-      VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->connect_retry_max = positive_atoi (p[1]);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+      options->ce.connect_retry_max = positive_atoi (p[1]);
     }
   else if (streq (p[0], "ipchange") && p[1])
     {
@@ -3334,8 +3594,8 @@
     }
   else if (streq (p[0], "float"))
     {
-      VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->remote_float = true;
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+      options->ce.remote_float = true;
     }
 #ifdef ENABLE_DEBUG
   else if (streq (p[0], "gremlin") && p[1])
@@ -3670,54 +3930,54 @@
     {
       int port;
 
-      VERIFY_PERMISSION (OPT_P_GENERAL);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
       port = atoi (p[1]);
       if (!legal_ipv4_port (port))
 	{
 	  msg (msglevel, "Bad port number: %s", p[1]);
 	  goto err;
 	}
-      options->port_option_used = true;
-      options->local_port = options->remote_port = port;
+      options->ce.port_option_used = true;
+      options->ce.local_port = options->ce.remote_port = port;
     }
   else if (streq (p[0], "lport") && p[1])
     {
       int port;
 
-      VERIFY_PERMISSION (OPT_P_GENERAL);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
       port = atoi (p[1]);
       if (!legal_ipv4_port (port))
 	{
 	  msg (msglevel, "Bad local port number: %s", p[1]);
 	  goto err;
 	}
-      options->local_port_defined = true;
-      options->port_option_used = true;
-      options->local_port = port;
+      options->ce.local_port_defined = true;
+      options->ce.port_option_used = true;
+      options->ce.local_port = port;
     }
   else if (streq (p[0], "rport") && p[1])
     {
       int port;
 
-      VERIFY_PERMISSION (OPT_P_GENERAL);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
       port = atoi (p[1]);
       if (!legal_ipv4_port (port))
 	{
 	  msg (msglevel, "Bad remote port number: %s", p[1]);
 	  goto err;
 	}
-      options->port_option_used = true;
-      options->remote_port = port;
+      options->ce.port_option_used = true;
+      options->ce.remote_port = port;
     }
   else if (streq (p[0], "bind"))
     {
-      VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->bind_defined = true;
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+      options->ce.bind_defined = true;
     }
   else if (streq (p[0], "nobind"))
     {
-      VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->bind_local = false;
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+      options->ce.bind_local = false;
     }
   else if (streq (p[0], "fast-io"))
     {
@@ -3734,7 +3994,7 @@
   else if (streq (p[0], "proto") && p[1])
     {
       int proto;
-      VERIFY_PERMISSION (OPT_P_GENERAL);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
       proto = ascii2proto (p[1]);
       if (proto < 0)
 	{
@@ -3743,7 +4003,7 @@
 	       proto2ascii_all (&gc));
 	  goto err;
 	}
-      options->proto = proto;
+      options->ce.proto = proto;
     }
 #ifdef GENERAL_PROXY_SUPPORT
   else if (streq (p[0], "auto-proxy"))
@@ -3782,7 +4042,7 @@
     {
       struct http_proxy_options *ho;
 
-      VERIFY_PERMISSION (OPT_P_GENERAL);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
 
       {
 	int port;
@@ -3827,7 +4087,7 @@
   else if (streq (p[0], "http-proxy-retry"))
     {
       struct http_proxy_options *ho;
-      VERIFY_PERMISSION (OPT_P_GENERAL);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
       ho = init_http_options_if_undefined (options);
       ho->retry = true;
     }
@@ -3835,7 +4095,7 @@
     {
       struct http_proxy_options *ho;
 
-      VERIFY_PERMISSION (OPT_P_GENERAL);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
       ho = init_http_options_if_undefined (options);
       ho->timeout = positive_atoi (p[1]);
     }
@@ -3843,7 +4103,7 @@
     {
       struct http_proxy_options *ho;
 
-      VERIFY_PERMISSION (OPT_P_GENERAL);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
       ho = init_http_options_if_undefined (options);
 
       if (streq (p[1], "VERSION") && p[2])
@@ -3863,7 +4123,7 @@
 #ifdef ENABLE_SOCKS
   else if (streq (p[0], "socks-proxy") && p[1])
     {
-      VERIFY_PERMISSION (OPT_P_GENERAL);
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
 
       if (p[2])
 	{
@@ -3874,18 +4134,18 @@
 	      msg (msglevel, "Bad socks-proxy port number: %s", p[2]);
 	      goto err;
 	    }
-          options->socks_proxy_port = port;
+          options->ce.socks_proxy_port = port;
 	}
       else
 	{
-	  options->socks_proxy_port = 1080;
+	  options->ce.socks_proxy_port = 1080;
 	}
-      options->socks_proxy_server = p[1];
+      options->ce.socks_proxy_server = p[1];
     }
   else if (streq (p[0], "socks-proxy-retry"))
     {
-      VERIFY_PERMISSION (OPT_P_GENERAL);
-      options->socks_proxy_retry = true;
+      VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+      options->ce.socks_proxy_retry = true;
     }
 #endif
   else if (streq (p[0], "keepalive") && p[1] && p[2])
@@ -3954,12 +4214,38 @@
     {
       VERIFY_PERMISSION (OPT_P_ROUTE);
       rol_check_alloc (options);
+      if (pull_mode)
+	{
+	  if (!ip_addr_dotted_quad_safe (p[1]) && !is_special_addr (p[1]))
+	    {
+	      msg (msglevel, "route parameter network/IP '%s' is not an IP address", p[1]);
+	      goto err;
+	    }
+	  if (p[2] && !ip_addr_dotted_quad_safe (p[2]))
+	    {
+	      msg (msglevel, "route parameter netmask '%s' is not an IP address", p[2]);
+	      goto err;
+	    }
+	  if (p[3] && !ip_addr_dotted_quad_safe (p[3]) && !is_special_addr (p[3]))
+	    {
+	      msg (msglevel, "route parameter gateway '%s' is not an IP address", p[3]);
+	      goto err;
+	    }
+	}
       add_route_to_option_list (options->routes, p[1], p[2], p[3], p[4]);
     }
   else if (streq (p[0], "route-gateway") && p[1])
     {
       VERIFY_PERMISSION (OPT_P_ROUTE_EXTRAS);
-      options->route_default_gateway = p[1];      
+      if (ip_addr_dotted_quad_safe (p[1]) || is_special_addr (p[1]))
+	{
+	  options->route_default_gateway = p[1];
+	}
+      else
+	{
+	  msg (msglevel, "route-gateway parm '%s' must be an IP address", p[1]);
+	  goto err;
+	}
     }
   else if (streq (p[0], "route-metric") && p[1])
     {
@@ -4023,16 +4309,21 @@
 	}
       options->routes->flags |= RG_ENABLE;
     }
-  else if (streq (p[0], "setenv") && p[1] && p[2])
+  else if (streq (p[0], "setenv") && p[1])
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
-      setenv_str (es, p[1], p[2]);
+      setenv_str (es, p[1], p[2] ? p[2] : "");
     }
-  else if (streq (p[0], "setenv-safe") && p[1] && p[2])
+  else if (streq (p[0], "setenv-safe") && p[1])
     {
       VERIFY_PERMISSION (OPT_P_SETENV);
-      setenv_str_safe (es, p[1], p[2]);
+      setenv_str_safe (es, p[1], p[2] ? p[2] : "");
     }
+  else if (streq (p[0], "script-security") && p[1])
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      script_security = atoi (p[1]);
+    }  
   else if (streq (p[0], "mssfix"))
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
@@ -4402,6 +4693,14 @@
     }
 #endif
 #ifdef WIN32
+  else if (streq (p[0], "win-sys") && p[1])
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      if (streq (p[1], "env"))
+	set_win_sys_path_via_env (es);
+      else
+	set_win_sys_path (p[1], es);
+    }
   else if (streq (p[0], "route-method") && p[1])
     {
       VERIFY_PERMISSION (OPT_P_ROUTE_EXTRAS);
@@ -5137,6 +5436,11 @@
       VERIFY_PERMISSION (OPT_P_GENERAL);
       options->pkcs11_id = p[1];
     }
+  else if (streq (p[0], "pkcs11-id-management"))
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      options->pkcs11_id_management = true;
+    }
 #endif
 #ifdef TUNSETPERSIST
   else if (streq (p[0], "rmtun"))
diff -urN openvpn-2.1_rc7/options.h openvpn-2.1_rc9/options.h
--- openvpn-2.1_rc7/options.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/options.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -82,10 +82,65 @@
 
 #endif
 
+struct connection_entry
+{
+  int proto;
+  int local_port;
+  bool local_port_defined;
+  int remote_port;
+  bool port_option_used;
+  const char *local;
+  const char *remote;
+  bool remote_float;
+  bool bind_defined;
+  bool bind_local;
+  int connect_retry_seconds;
+  bool connect_retry_defined;
+  int connect_retry_max;
+  int connect_timeout;
+  bool connect_timeout_defined;
+#ifdef ENABLE_HTTP_PROXY
+  struct http_proxy_options *http_proxy_options;
+#endif  
+#ifdef ENABLE_SOCKS
+  const char *socks_proxy_server;
+  int socks_proxy_port;
+  bool socks_proxy_retry;
+#endif
+};
+
+struct remote_entry
+{
+  const char *remote;
+  int remote_port;
+  int proto;
+};
+
+#ifdef ENABLE_CONNECTION
+
+#define CONNECTION_LIST_SIZE 64
+
+struct connection_list
+{
+  int len;
+  int current;
+  bool no_advance;
+  struct connection_entry *array[CONNECTION_LIST_SIZE];
+};
+
+struct remote_list
+{
+  int len;
+  struct remote_entry *array[CONNECTION_LIST_SIZE];
+};
+
+#endif
+
 /* Command line options */
 struct options
 {
   struct gc_arena gc;
+  bool gc_owned;
 
   /* first config file */
   const char *config;
@@ -111,17 +166,19 @@
 #endif
 
   /* Networking parms */
-  const char *local;
-  int local_port;
-  bool local_port_defined;
-  int remote_port;
-  bool port_option_used;
-  bool remote_float;
+  struct connection_entry ce;
+
+#ifdef ENABLE_CONNECTION
+  struct connection_list *connection_list;
   struct remote_list *remote_list;
+#endif
+
+#ifdef GENERAL_PROXY_SUPPORT
+  struct auto_proxy_info *auto_proxy_info;
+#endif
+
   bool remote_random;
   const char *ipchange;
-  bool bind_defined;
-  bool bind_local;
   const char *dev;
   const char *dev_type;
   const char *dev_node;
@@ -141,14 +198,6 @@
   bool tun_mtu_defined;  /* true if user overriding parm with command line option */
   bool link_mtu_defined; /* true if user overriding parm with command line option */
 
-  /* Protocol type (PROTO_UDP or PROTO_TCP) */
-  int proto;
-  int connect_retry_seconds;
-  int connect_retry_max;
-  bool connect_retry_defined;
-  int connect_timeout;
-  bool connect_timeout_defined;
-
   /* Advanced MTU negotiation and datagram fragmentation options */
   int mtu_discover_type; /* used if OS supports setting Path MTU discovery options on socket */
 
@@ -254,21 +303,6 @@
   struct route_option_list *routes;
   bool route_nopull;
 
-#ifdef GENERAL_PROXY_SUPPORT
-  struct auto_proxy_info *auto_proxy_info;
-#endif
-
-#ifdef ENABLE_HTTP_PROXY
-  struct http_proxy_options *http_proxy_options;
-#endif
-
-#ifdef ENABLE_SOCKS
-  /* socks proxy */
-  const char *socks_proxy_server;
-  int socks_proxy_port;
-  bool socks_proxy_retry;
-#endif
-
 #ifdef ENABLE_OCC
   /* Enable options consistency check between peers */
   bool occ;
@@ -281,12 +315,10 @@
   int management_log_history_cache;
   int management_echo_buffer_size;
   int management_state_buffer_size;
-  bool management_query_passwords;
-  bool management_hold;
-  bool management_signal;
-  bool management_forget_disconnect;
-  bool management_client;
   const char *management_write_peer_info_file;
+
+  /* Mask of MF_ values of manage.h */
+  unsigned int management_flags;
 #endif
 
 #ifdef ENABLE_PLUGIN
@@ -419,6 +451,7 @@
   bool pkcs11_cert_private[MAX_PARMS];
   int pkcs11_pin_cache_period;
   const char *pkcs11_id;
+  bool pkcs11_id_management;
 #endif
 
 #ifdef WIN32
@@ -500,6 +533,7 @@
 #define OPT_P_PLUGIN          (1<<24)
 #define OPT_P_SOCKBUF         (1<<25)
 #define OPT_P_SOCKFLAGS       (1<<26)
+#define OPT_P_CONNECTION      (1<<27)
 
 #define OPT_P_DEFAULT   (~(OPT_P_INSTANCE|OPT_P_PULL_MODE))
 
@@ -536,6 +570,12 @@
 #define PLUGIN_OPTION_LIST(opt) (NULL)
 #endif
 
+#ifdef MANAGEMENT_DEF_AUTH
+#define MAN_CLIENT_AUTH_ENABLED(opt) ((opt)->management_flags & MF_CLIENT_AUTH)
+#else
+#define MAN_CLIENT_AUTH_ENABLED(opt) (false)
+#endif
+
 void parse_argv (struct options *options,
 		 const int argc,
 		 char *argv[],
@@ -548,7 +588,7 @@
 
 void usage_small (void);
 
-void init_options (struct options *o);
+void init_options (struct options *o, const bool init_gc);
 void uninit_options (struct options *o);
 
 void setenv_settings (struct env_set *es, const struct options *o);
@@ -573,7 +613,7 @@
 
 #endif
 
-void options_postprocess (struct options *options, bool first_time);
+void options_postprocess (struct options *options);
 
 void pre_pull_save (struct options *o);
 void pre_pull_restore (struct options *o);
@@ -631,15 +671,33 @@
 
 #endif
 
-#ifdef ENABLE_PLUGIN
-
-void options_plugin_import (struct options *options,
+void options_string_import (struct options *options,
 			    const char *config,
 			    const int msglevel,
 			    const unsigned int permission_mask,
 			    unsigned int *option_types_found,
 			    struct env_set *es);
 
+/*
+ * inline functions
+ */
+static inline bool
+connection_list_defined (const struct options *o)
+{
+#ifdef ENABLE_CONNECTION
+  return o->connection_list != NULL;
+#else
+  return false;
+#endif
+}
+
+static inline void
+connection_list_set_no_advance (struct options *o)
+{
+#ifdef ENABLE_CONNECTION
+  if (o->connection_list)
+    o->connection_list->no_advance = true;
 #endif
+}
 
 #endif
diff -urN openvpn-2.1_rc7/otime.c openvpn-2.1_rc9/otime.c
--- openvpn-2.1_rc7/otime.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/otime.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "otime.h"
diff -urN openvpn-2.1_rc7/otime.h openvpn-2.1_rc9/otime.h
--- openvpn-2.1_rc7/otime.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/otime.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/packet_id.c openvpn-2.1_rc9/packet_id.c
--- openvpn-2.1_rc7/packet_id.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/packet_id.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -31,16 +31,10 @@
  * to IPSec.
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
+#include "syshead.h"
 
 #ifdef USE_CRYPTO
 
-#include "syshead.h"
-
 #include "packet_id.h"
 #include "misc.h"
 #include "integer.h"
@@ -215,12 +209,12 @@
     {
       /*
        * In non-backtrack mode, all sequence number series must
-       * begin at 1 and must increment linearly without gaps.
+       * begin at some number n > 0 and must increment linearly without gaps.
        *
        * This mode is used with TCP.
        */
       if (pin->time == p->time)
-	return pin->id == p->id + 1;
+	return !p->id || pin->id == p->id + 1;
       else if (pin->time < p->time) /* if time goes back, reject */
 	return false;
       else                          /* time moved forward */
diff -urN openvpn-2.1_rc7/packet_id.h openvpn-2.1_rc9/packet_id.h
--- openvpn-2.1_rc7/packet_id.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/packet_id.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/perf.c openvpn-2.1_rc9/perf.c
--- openvpn-2.1_rc7/perf.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/perf.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "perf.h"
diff -urN openvpn-2.1_rc7/perf.h openvpn-2.1_rc9/perf.h
--- openvpn-2.1_rc7/perf.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/perf.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/pf-inline.h openvpn-2.1_rc9/pf-inline.h
--- openvpn-2.1_rc7/pf-inline.h	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/pf-inline.h	2008-07-26 08:18:08.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ *  OpenVPN -- An application to securely tunnel IP networks
+ *             over a single TCP/UDP port, with support for SSL/TLS-based
+ *             session authentication and key exchange,
+ *             packet encryption, packet authentication, and
+ *             packet compression.
+ *
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program (see the file COPYING included with this
+ *  distribution); if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if defined(ENABLE_PF) && !defined(PF_INLINE_H)
+#define PF_INLINE_H
+
+/*
+ * Inline functions
+ */
+
+#define PCT_SRC  1
+#define PCT_DEST 2
+static inline bool
+pf_c2c_test (const struct context *src, const struct context *dest, const char *prefix)
+{
+  bool pf_cn_test (struct pf_set *pfs, const struct tls_multi *tm, const int type, const char *prefix);
+  return  (!src->c2.pf.enabled  || pf_cn_test (src->c2.pf.pfs,  dest->c2.tls_multi, PCT_DEST, prefix))
+       && (!dest->c2.pf.enabled || pf_cn_test (dest->c2.pf.pfs, src->c2.tls_multi,  PCT_SRC,  prefix));
+}
+
+static inline bool
+pf_addr_test (const struct context *src, const struct mroute_addr *dest, const char *prefix)
+{
+  bool pf_addr_test_dowork (const struct context *src, const struct mroute_addr *dest, const char *prefix);
+
+  if (src->c2.pf.enabled)
+    return pf_addr_test_dowork (src, dest, prefix);
+  else
+    return true;
+}
+
+static inline bool
+pf_kill_test (const struct pf_set *pfs)
+{
+  return pfs->kill;
+}
+
+#endif
diff -urN openvpn-2.1_rc7/pf.c openvpn-2.1_rc9/pf.c
--- openvpn-2.1_rc7/pf.c	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/pf.c	2008-07-26 08:18:08.000000000 +0200
@@ -0,0 +1,705 @@
+/*
+ *  OpenVPN -- An application to securely tunnel IP networks
+ *             over a single TCP/UDP port, with support for SSL/TLS-based
+ *             session authentication and key exchange,
+ *             packet encryption, packet authentication, and
+ *             packet compression.
+ *
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program (see the file COPYING included with this
+ *  distribution); if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* packet filter functions */
+
+#include "syshead.h"
+
+#if defined(ENABLE_PF)
+
+#include "init.h"
+
+#include "memdbg.h"
+
+#include "pf-inline.h"
+
+static void
+pf_destroy (struct pf_set *pfs)
+{
+  if (pfs)
+    {
+      if (pfs->cns.hash_table)
+	hash_free (pfs->cns.hash_table);
+
+      {
+	struct pf_cn_elem *l = pfs->cns.list;
+	while (l)
+	  {
+	    struct pf_cn_elem *next = l->next;
+	    free (l->rule.cn);
+	    free (l);
+	    l = next;
+	  }
+      }
+      {
+	struct pf_subnet *l = pfs->sns.list;
+	while (l)
+	  {
+	    struct pf_subnet *next = l->next;
+	    free (l);
+	    l = next;
+	  }
+      }
+      free (pfs);
+    }
+}
+
+static bool
+add_client (const char *line, const char *prefix, const int line_num, struct pf_cn_elem ***next, const bool exclude)
+{
+  struct pf_cn_elem *e;
+  ALLOC_OBJ_CLEAR (e, struct pf_cn_elem);
+  e->rule.exclude = exclude;
+  e->rule.cn = string_alloc (line, NULL);
+  **next = e;
+  *next = &e->next;
+  return true;
+}
+
+static bool
+add_subnet (const char *line, const char *prefix, const int line_num, struct pf_subnet ***next, const bool exclude)
+{
+  struct in_addr network;
+  in_addr_t netmask = 0;
+
+  if (strcmp (line, "unknown"))
+    {
+      int netbits = 32;
+      char *div = strchr (line, '/');
+
+      if (div)
+	{
+	  *div++ = '\0';
+	  if (sscanf (div, "%d", &netbits) != 1)
+	    {
+	      msg (D_PF_INFO, "PF: %s/%d: bad '/n' subnet specifier: '%s'", prefix, line_num, div);
+	      return false;
+	    }
+	  if (netbits < 0 || netbits > 32)
+	    {
+	      msg (D_PF_INFO, "PF: %s/%d: bad '/n' subnet specifier: must be between 0 and 32: '%s'", prefix, line_num, div);
+	      return false;
+	    }
+	}
+
+      if (openvpn_inet_aton (line, &network) != OIA_IP)
+	{
+	  msg (D_PF_INFO, "PF: %s/%d: bad network address: '%s'", prefix, line_num, line);
+	  return false;
+	}
+      netmask = netbits_to_netmask (netbits);
+    }
+  else
+    {
+      /* match special "unknown" tag for addresses unrecognized by mroute */
+      network.s_addr = htonl(0);
+      netmask = ~0;
+    }
+
+  {
+    struct pf_subnet *e;
+    ALLOC_OBJ_CLEAR (e, struct pf_subnet);
+    e->rule.exclude = exclude;
+    e->rule.network = ntohl (network.s_addr);
+    e->rule.netmask = netmask;
+    **next = e;
+    *next = &e->next;
+    return true;
+  }
+}
+
+static uint32_t
+cn_hash_function (const void *key, uint32_t iv)
+{
+  return hash_func ((uint8_t *)key, strlen ((char *)key) + 1, iv);
+}
+
+static bool
+cn_compare_function (const void *key1, const void *key2)
+{
+  return !strcmp((const char *)key1, (const char *)key2);
+}
+
+static bool
+genhash (struct pf_cn_set *cns, const char *prefix, const int n_clients)
+{
+  struct pf_cn_elem *e;
+  bool status = true;
+  int n_buckets = n_clients;
+
+  if (n_buckets < 16)
+    n_buckets = 16;
+  cns->hash_table = hash_init (n_buckets, 0, cn_hash_function, cn_compare_function);
+  for (e = cns->list; e != NULL; e = e->next)
+    {
+      if (!hash_add (cns->hash_table, e->rule.cn, &e->rule, false))
+	{
+	  msg (D_PF_INFO, "PF: %s: duplicate common name in [clients] section: '%s'", prefix, e->rule.cn);
+	  status = false;
+	}
+    }
+  
+  return status;
+}
+
+static struct pf_set *
+pf_init (const struct buffer_list *bl, const char *prefix, const bool allow_kill)
+{
+# define MODE_UNDEF   0
+# define MODE_CLIENTS 1
+# define MODE_SUBNETS 2
+  int mode = MODE_UNDEF;
+  int line_num = 0;
+  int n_clients = 0;
+  int n_subnets = 0;
+  int n_errors = 0;
+  struct pf_set *pfs = NULL;
+  char line[PF_MAX_LINE_LEN];
+
+  ALLOC_OBJ_CLEAR (pfs, struct pf_set);
+  if (bl)
+    {
+      struct pf_cn_elem **cl = &pfs->cns.list;
+      struct pf_subnet **sl = &pfs->sns.list;
+      struct buffer_entry *be;
+
+      for (be = bl->head; be != NULL; be = be->next)
+	{
+	  ++line_num;
+	  strncpynt (line, BSTR(&be->buf), sizeof(line));
+	  rm_trailing_chars (line, "\r\n\t ");
+	  if (line[0] == '\0' || line[0] == '#')
+	    ;
+	  else if (line[0] == '+' || line[0] == '-')
+	    {
+	      bool exclude = (line[0] == '-');
+
+	      if (line[1] =='\0')
+		{
+		  msg (D_PF_INFO, "PF: %s/%d: no data after +/-: '%s'", prefix, line_num, line);
+		  ++n_errors;
+		}
+	      else if (mode == MODE_CLIENTS)
+		{
+		  if (add_client (&line[1], prefix, line_num, &cl, exclude))
+		    ++n_clients;
+		  else
+		    ++n_errors;
+		}
+	      else if (mode == MODE_SUBNETS)
+		{
+		  if (add_subnet (&line[1], prefix, line_num, &sl, exclude))
+		    ++n_subnets;
+		  else
+		    ++n_errors;
+		}
+	      else if (mode == MODE_UNDEF)
+		;
+	      else
+		{
+		  ASSERT (0);
+		}
+	    }
+	  else if (line[0] == '[')
+	    {
+	      if (!strcasecmp (line, "[clients accept]"))
+		{
+		  mode = MODE_CLIENTS;
+		  pfs->cns.default_allow = true;
+		}
+	      else if (!strcasecmp (line, "[clients drop]"))
+		{
+		  mode = MODE_CLIENTS;
+		  pfs->cns.default_allow = false;
+		}
+	      else if (!strcasecmp (line, "[subnets accept]"))
+		{
+		  mode = MODE_SUBNETS;
+		  pfs->sns.default_allow = true;
+		}
+	      else if (!strcasecmp (line, "[subnets drop]"))
+		{
+		  mode = MODE_SUBNETS;
+		  pfs->sns.default_allow = false;
+		}
+	      else if (!strcasecmp (line, "[end]"))
+		goto done;
+	      else if (allow_kill && !strcasecmp (line, "[kill]"))
+		goto kill;
+	      else
+		{
+		  mode = MODE_UNDEF;
+		  msg (D_PF_INFO, "PF: %s/%d unknown tag: '%s'", prefix, line_num, line);
+		  ++n_errors;
+		}
+	    }
+	  else
+	    {
+	      msg (D_PF_INFO, "PF: %s/%d line must begin with '+', '-', or '[' : '%s'", prefix, line_num, line);
+	      ++n_errors;
+	    }
+	}
+      ++n_errors;
+      msg (D_PF_INFO, "PF: %s: missing [end]", prefix);
+    }
+  else
+    {
+      msg (D_PF_INFO, "PF: %s: cannot open", prefix);
+      ++n_errors;
+    }
+
+ done:
+  if (bl)
+    {
+      if (!n_errors)
+	{
+	  if (!genhash (&pfs->cns, prefix, n_clients))
+	    ++n_errors;
+	}
+      if (n_errors)
+	msg (D_PF_INFO, "PF: %s rejected due to %d error(s)", prefix, n_errors);
+    }
+  if (n_errors)
+    {
+      pf_destroy (pfs);
+      pfs = NULL;
+    }
+  return pfs;
+  
+ kill:
+  pf_destroy (pfs);
+  ALLOC_OBJ_CLEAR (pfs, struct pf_set);
+  pfs->kill = true;
+  return pfs;
+}
+
+#ifdef PLUGIN_PF
+static struct pf_set *
+pf_init_from_file (const char *fn)
+{
+  struct buffer_list *bl = buffer_list_file (fn, PF_MAX_LINE_LEN);
+  if (bl)
+    {
+      struct pf_set *pfs = pf_init (bl, fn, true);
+      buffer_list_free (bl);
+      return pfs;
+    }
+  else
+    {
+      msg (D_PF_INFO|M_ERRNO, "PF: %s: cannot open", fn);
+      return NULL;
+    }
+}
+#endif
+
+#ifdef ENABLE_DEBUG
+
+static const char *
+drop_accept (const bool accept)
+{
+  return accept ? "ACCEPT" : "DROP"; 
+}
+
+static const char *
+pct_name (const int type)
+{
+  switch (type)
+    {
+    case PCT_SRC:
+      return "SRC";
+    case PCT_DEST:
+      return "DEST";
+    default:
+      return "???";
+    }
+}
+
+static void
+pf_cn_test_print (const char *prefix,
+		  const int type,
+		  const char *prefix2,
+		  const char *cn,
+		  const bool allow,
+		  const struct pf_cn *rule)
+{
+  if (rule)
+    {
+      dmsg (D_PF_DEBUG, "PF: %s/%s/%s %s %s rule=[%s %s]",
+	   prefix, prefix2, pct_name (type),
+	   cn, drop_accept (allow),
+	   rule->cn, drop_accept (!rule->exclude));
+    }
+  else
+    {
+      dmsg (D_PF_DEBUG, "PF: %s/%s/%s %s %s",
+	   prefix, prefix2, pct_name (type),
+	   cn, drop_accept (allow));
+    }
+}
+
+static void
+pf_addr_test_print (const char *prefix,
+		    const char *prefix2,
+		    const struct context *src,
+		    const struct mroute_addr *dest,
+		    const bool allow,
+		    const struct ipv4_subnet *rule)
+{
+  struct gc_arena gc = gc_new ();
+  if (rule)
+    {
+      dmsg (D_PF_DEBUG, "PF: %s/%s %s %s %s rule=[%s/%s %s]",
+	   prefix,
+	   prefix2,
+	   tls_common_name (src->c2.tls_multi, false),
+	   mroute_addr_print_ex (dest, MAPF_SHOW_ARP, &gc),
+	   drop_accept (allow),
+	   print_in_addr_t (rule->network, 0, &gc),
+	   print_in_addr_t (rule->netmask, 0, &gc),
+	   drop_accept (!rule->exclude));
+    }
+  else
+    {
+      dmsg (D_PF_DEBUG, "PF: %s/%s %s %s %s",
+	   prefix,
+	   prefix2,
+	   tls_common_name (src->c2.tls_multi, false),
+	   mroute_addr_print_ex (dest, MAPF_SHOW_ARP, &gc),
+	   drop_accept (allow));
+    }
+  gc_free (&gc);
+}
+
+#endif
+
+static inline struct pf_cn *
+lookup_cn_rule (struct hash *h, const char *cn, const uint32_t cn_hash)
+{
+  struct hash_element *he = hash_lookup_fast (h, hash_bucket (h, cn_hash), cn, cn_hash);
+  if (he)
+    return (struct pf_cn *) he->value;
+  else
+    return NULL;
+}
+
+bool
+pf_cn_test (struct pf_set *pfs, const struct tls_multi *tm, const int type, const char *prefix)
+{
+  if (!pfs->kill)
+    {
+      const char *cn;
+      uint32_t cn_hash;
+      if (tls_common_name_hash (tm, &cn, &cn_hash))
+	{
+	  const struct pf_cn *rule = lookup_cn_rule (pfs->cns.hash_table, cn, cn_hash);
+	  if (rule)
+	    {
+#ifdef ENABLE_DEBUG
+	      if (check_debug_level (D_PF_DEBUG))
+		pf_cn_test_print ("PF_CN_MATCH", type, prefix, cn, !rule->exclude, rule);
+#endif
+	      if (!rule->exclude)
+		return true;
+	      else
+		return false;
+	    }
+	  else
+	    {
+#ifdef ENABLE_DEBUG
+	      if (check_debug_level (D_PF_DEBUG))
+		pf_cn_test_print ("PF_CN_DEFAULT", type, prefix, cn, pfs->cns.default_allow, NULL);
+#endif
+	      if (pfs->cns.default_allow)
+		return true;
+	      else
+		return false;
+	    }
+	}
+    }
+#ifdef ENABLE_DEBUG
+  if (check_debug_level (D_PF_DEBUG))
+    pf_cn_test_print ("PF_CN_FAULT", type, prefix, tls_common_name (tm, false), false, NULL);
+#endif
+  return false;
+}
+
+bool
+pf_addr_test_dowork (const struct context *src, const struct mroute_addr *dest, const char *prefix)
+{
+  struct pf_set *pfs = src->c2.pf.pfs;
+  if (pfs && !pfs->kill)
+    {
+      const in_addr_t addr = in_addr_t_from_mroute_addr (dest);
+      const struct pf_subnet *se = pfs->sns.list;
+      while (se)
+	{
+	  if ((addr & se->rule.netmask) == se->rule.network)
+	    {
+#ifdef ENABLE_DEBUG
+	      if (check_debug_level (D_PF_DEBUG))
+		pf_addr_test_print ("PF_ADDR_MATCH", prefix, src, dest, !se->rule.exclude, &se->rule);
+#endif
+	      return !se->rule.exclude;
+	    }
+	  se = se->next;
+	}
+#ifdef ENABLE_DEBUG
+      if (check_debug_level (D_PF_DEBUG))
+	pf_addr_test_print ("PF_ADDR_DEFAULT", prefix, src, dest, pfs->sns.default_allow, NULL);
+#endif
+      return pfs->sns.default_allow;
+    }
+  else
+    {
+#ifdef ENABLE_DEBUG
+      if (check_debug_level (D_PF_DEBUG))
+	pf_addr_test_print ("PF_ADDR_FAULT", prefix, src, dest, false, NULL);
+#endif
+      return false;
+    }
+}
+
+#ifdef PLUGIN_PF
+void
+pf_check_reload (struct context *c)
+{
+  const int slow_wakeup = 15;
+  const int fast_wakeup = 1;
+  const int wakeup_transition = 60;
+  bool reloaded = false;
+
+  if (c->c2.pf.enabled
+      && c->c2.pf.filename
+      && event_timeout_trigger (&c->c2.pf.reload, &c->c2.timeval, ETT_DEFAULT))
+    {
+      struct stat s;
+      if (!stat (c->c2.pf.filename, &s))
+	{
+	  if (s.st_mtime > c->c2.pf.file_last_mod)
+	    {
+	      struct pf_set *pfs = pf_init_from_file (c->c2.pf.filename);
+	      if (pfs)
+		{
+		  if (c->c2.pf.pfs)
+		    pf_destroy (c->c2.pf.pfs);
+		  c->c2.pf.pfs = pfs;
+		  reloaded = true;
+		  if (pf_kill_test (pfs))
+		    {
+		      c->sig->signal_received = SIGTERM;
+		      c->sig->signal_text = "pf-kill";
+		    }
+		}
+	      c->c2.pf.file_last_mod = s.st_mtime;
+	    }
+	}
+      {
+	int wakeup = slow_wakeup;
+	if (!c->c2.pf.pfs && c->c2.pf.n_check_reload < wakeup_transition)
+	  wakeup = fast_wakeup;
+	event_timeout_init (&c->c2.pf.reload, wakeup, now);
+	reset_coarse_timers (c);
+	c->c2.pf.n_check_reload++;
+      }
+    }
+#ifdef ENABLE_DEBUG
+  if (reloaded && check_debug_level (D_PF_DEBUG))
+    pf_context_print (&c->c2.pf, "pf_check_reload", D_PF_DEBUG);
+#endif
+}
+#endif
+
+#ifdef MANAGEMENT_PF
+bool
+pf_load_from_buffer_list (struct context *c, const struct buffer_list *config)
+{
+  struct pf_set *pfs = pf_init (config, "[SERVER-PF]", false);
+  if (pfs)
+    {
+      if (c->c2.pf.pfs)
+	pf_destroy (c->c2.pf.pfs);
+      c->c2.pf.pfs = pfs;
+      return true;
+    }
+  else
+    return false;
+}
+#endif
+
+void
+pf_init_context (struct context *c)
+{
+  struct gc_arena gc = gc_new ();
+#ifdef PLUGIN_PF
+  if (plugin_defined (c->plugins, OPENVPN_PLUGIN_ENABLE_PF))
+    {
+      const char *pf_file = create_temp_filename (c->options.tmp_dir, "pf", &gc);
+      delete_file (pf_file);
+      setenv_str (c->c2.es, "pf_file", pf_file);
+
+      if (plugin_call (c->plugins, OPENVPN_PLUGIN_ENABLE_PF, NULL, NULL, c->c2.es) == OPENVPN_PLUGIN_FUNC_SUCCESS)
+	{
+	  event_timeout_init (&c->c2.pf.reload, 1, now);
+	  c->c2.pf.filename = string_alloc (pf_file, NULL);
+	  c->c2.pf.enabled = true;
+#ifdef ENABLE_DEBUG
+	  if (check_debug_level (D_PF_DEBUG))
+	    pf_context_print (&c->c2.pf, "pf_init_context#1", D_PF_DEBUG);
+#endif
+	}
+      else
+	{
+	  msg (M_WARN, "WARNING: OPENVPN_PLUGIN_ENABLE_PF disabled");
+	}
+    }
+#endif
+#ifdef MANAGEMENT_PF
+  if (!c->c2.pf.enabled && management_enable_pf (management))
+    {
+      c->c2.pf.enabled = true;
+#ifdef ENABLE_DEBUG
+      if (check_debug_level (D_PF_DEBUG))
+	pf_context_print (&c->c2.pf, "pf_init_context#2", D_PF_DEBUG);
+#endif
+    }
+#endif
+  gc_free (&gc);
+}
+
+void
+pf_destroy_context (struct pf_context *pfc)
+{
+#ifdef PLUGIN_PF
+  if (pfc->filename)
+    {
+      delete_file (pfc->filename);
+      free (pfc->filename);
+    }
+#endif
+  if (pfc->pfs)
+    pf_destroy (pfc->pfs);
+}
+
+#ifdef ENABLE_DEBUG
+
+static void
+pf_subnet_set_print (const struct pf_subnet_set *s, const int lev)
+{
+  struct gc_arena gc = gc_new ();
+  if (s)
+    {
+      struct pf_subnet *e;
+
+      msg (lev, "  ----- struct pf_subnet_set -----");
+      msg (lev, "  default_allow=%s", drop_accept (s->default_allow));
+
+      for (e = s->list; e != NULL; e = e->next)
+	{
+	  msg (lev, "   %s/%s %s",
+	       print_in_addr_t (e->rule.network, 0, &gc),
+	       print_in_addr_t (e->rule.netmask, 0, &gc),
+	       drop_accept (!e->rule.exclude));
+	}
+    }
+  gc_free (&gc);
+}
+
+static void
+pf_cn_set_print (const struct pf_cn_set *s, const int lev)
+{
+  if (s)
+    {
+      struct hash_iterator hi;
+      struct hash_element *he;
+
+      msg (lev, "  ----- struct pf_cn_set -----");
+      msg (lev, "  default_allow=%s", drop_accept (s->default_allow));
+
+      if (s->hash_table)
+	{
+	  hash_iterator_init (s->hash_table, &hi, false);
+	  while ((he = hash_iterator_next (&hi)))
+	    {
+	      struct pf_cn *e = (struct pf_cn *)he->value;
+	      msg (lev, "   %s %s",
+		   e->cn,
+		   drop_accept (!e->exclude));
+	    }
+
+	  msg (lev, "  ----------");
+
+	  {
+	    struct pf_cn_elem *ce;
+	    for (ce = s->list; ce != NULL; ce = ce->next)
+	      {
+		struct pf_cn *e = lookup_cn_rule (s->hash_table, ce->rule.cn, cn_hash_function (ce->rule.cn, 0));
+		if (e)
+		  {
+		    msg (lev, "   %s %s",
+			 e->cn,
+			 drop_accept (!e->exclude));
+		  }
+		else
+		  {
+		    msg (lev, "   %s LOOKUP FAILED", ce->rule.cn);
+		  }
+	      }
+	  }
+	}
+    }
+}
+
+static void
+pf_set_print (const struct pf_set *pfs, const int lev)
+{
+  if (pfs)
+    {
+      msg (lev, " ----- struct pf_set -----");
+      msg (lev, " kill=%d", pfs->kill);
+      pf_subnet_set_print (&pfs->sns, lev);
+      pf_cn_set_print (&pfs->cns, lev);
+    }
+}
+
+void
+pf_context_print (const struct pf_context *pfc, const char *prefix, const int lev)
+{
+  msg (lev, "----- %s : struct pf_context -----", prefix);
+  if (pfc)
+    {
+      msg (lev, "enabled=%d", pfc->enabled);
+#ifdef PLUGIN_PF
+      msg (lev, "filename='%s'", np(pfc->filename));
+      msg (lev, "file_last_mod=%u", (unsigned int)pfc->file_last_mod);
+      msg (lev, "n_check_reload=%u", pfc->n_check_reload);
+      msg (lev, "reload=[%d,%u,%u]", pfc->reload.defined, pfc->reload.n, (unsigned int)pfc->reload.last);
+#endif
+      pf_set_print (pfc->pfs, lev);
+    }
+  msg (lev, "--------------------");
+}
+
+#endif
+
+#endif
diff -urN openvpn-2.1_rc7/pf.h openvpn-2.1_rc9/pf.h
--- openvpn-2.1_rc7/pf.h	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/pf.h	2008-07-26 08:18:08.000000000 +0200
@@ -0,0 +1,102 @@
+/*
+ *  OpenVPN -- An application to securely tunnel IP networks
+ *             over a single TCP/UDP port, with support for SSL/TLS-based
+ *             session authentication and key exchange,
+ *             packet encryption, packet authentication, and
+ *             packet compression.
+ *
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program (see the file COPYING included with this
+ *  distribution); if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* packet filter functions */
+
+#if defined(ENABLE_PF) && !defined(OPENVPN_PF_H)
+#define OPENVPN_PF_H
+
+#include "list.h"
+#include "mroute.h"
+
+#define PF_MAX_LINE_LEN 256
+
+struct context;
+
+struct ipv4_subnet {
+  bool exclude;
+  in_addr_t network;
+  in_addr_t netmask;
+};
+
+struct pf_subnet {
+  struct pf_subnet *next;
+  struct ipv4_subnet rule;
+};
+
+struct pf_subnet_set {
+  bool default_allow;
+  struct pf_subnet *list;
+};
+
+struct pf_cn {
+  bool exclude;
+  char *cn;
+};
+
+struct pf_cn_elem {
+  struct pf_cn_elem *next;
+  struct pf_cn rule;
+};
+
+struct pf_cn_set {
+  bool default_allow;
+  struct pf_cn_elem *list;
+  struct hash *hash_table;
+};
+
+struct pf_set {
+  bool kill;
+  struct pf_subnet_set sns;
+  struct pf_cn_set cns;
+};
+
+struct pf_context {
+  bool enabled;
+  struct pf_set *pfs;
+#ifdef PLUGIN_PF
+  char *filename;
+  time_t file_last_mod;
+  unsigned int n_check_reload;
+  struct event_timeout reload;
+#endif
+};
+
+void pf_init_context (struct context *c);
+
+void pf_destroy_context (struct pf_context *pfc);
+
+#ifdef PLUGIN_PF
+void pf_check_reload (struct context *c);
+#endif
+
+#ifdef MANAGEMENT_PF
+bool pf_load_from_buffer_list (struct context *c, const struct buffer_list *config);
+#endif
+
+#ifdef ENABLE_DEBUG
+void pf_context_print (const struct pf_context *pfc, const char *prefix, const int lev);
+#endif
+
+#endif
diff -urN openvpn-2.1_rc7/ping-inline.h openvpn-2.1_rc9/ping-inline.h
--- openvpn-2.1_rc7/ping-inline.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/ping-inline.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/ping.c openvpn-2.1_rc9/ping.c
--- openvpn-2.1_rc7/ping.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/ping.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "ping.h"
diff -urN openvpn-2.1_rc7/ping.h openvpn-2.1_rc9/ping.h
--- openvpn-2.1_rc7/ping.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/ping.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/pkcs11.c openvpn-2.1_rc9/pkcs11.c
--- openvpn-2.1_rc7/pkcs11.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/pkcs11.c	2008-07-26 10:28:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#if defined(WIN32)
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if defined(ENABLE_PKCS11)
@@ -37,6 +31,7 @@
 #include "basic.h"
 #include "error.h"
 #include "manage.h"
+#include "base64.h"
 #include "pkcs11.h"
 
 static
@@ -168,7 +163,7 @@
 	const pkcs11h_token_id_t token,
 	const unsigned retry
 ) {
-	static struct user_pass token_resp;
+	struct user_pass token_resp;
 
 	(void)global_data;
 	(void)user_data;
@@ -211,7 +206,7 @@
 	char * const pin,
 	const size_t pin_max
 ) {
-	static struct user_pass token_pass;
+	struct user_pass token_pass;
 	char prompt[1024];
 
 	(void)global_data;
@@ -389,8 +384,226 @@
 }
 
 int
+pkcs11_management_id_count () {
+	pkcs11h_certificate_id_list_t id_list = NULL;
+	pkcs11h_certificate_id_list_t t = NULL;
+	CK_RV rv = CKR_OK;
+	int count = 0;
+
+	dmsg (
+		D_PKCS11_DEBUG,
+		"PKCS#11: pkcs11_management_id_count - entered"
+	);
+
+	if (
+		(rv = pkcs11h_certificate_enumCertificateIds (
+			PKCS11H_ENUM_METHOD_CACHE_EXIST,
+			NULL,
+			PKCS11H_PROMPT_MASK_ALLOW_ALL,
+			NULL,
+			&id_list
+		)) != CKR_OK
+	) {
+		msg (M_WARN, "PKCS#11: Cannot get certificate list %ld-'%s'", rv, pkcs11h_getMessage (rv));
+		goto cleanup;
+	}
+
+	for (count = 0, t = id_list; t != NULL; t = t->next) {
+		count++;
+	}
+
+cleanup:
+
+	if (id_list != NULL) {
+		pkcs11h_certificate_freeCertificateIdList (id_list);
+		id_list = NULL;
+	}
+
+	dmsg (
+		D_PKCS11_DEBUG,
+		"PKCS#11: pkcs11_management_id_count - return count=%d",
+		count
+	);
+
+	return count;
+}
+
+bool
+pkcs11_management_id_get (
+	const int index,
+	char ** id,
+	char **base64
+) {
+	pkcs11h_certificate_id_list_t id_list = NULL;
+	pkcs11h_certificate_id_list_t entry = NULL;
+#if 0 /* certificate_id seems to be unused -- JY */
+	pkcs11h_certificate_id_t certificate_id = NULL;
+#endif
+	pkcs11h_certificate_t certificate = NULL;
+	CK_RV rv = CKR_OK;
+	char *certificate_blob = NULL;
+	size_t certificate_blob_size = 0;
+	size_t max;
+	char *internal_id = NULL;
+	char *internal_base64 = NULL;
+	int count = 0;
+	bool success = false;
+
+	ASSERT (id!=NULL);
+	ASSERT (base64!=NULL);
+
+	dmsg (
+		D_PKCS11_DEBUG,
+		"PKCS#11: pkcs11_management_id_get - entered index=%d",
+		index
+	);
+
+	*id = NULL;
+	*base64 = NULL;
+
+	if (
+		(rv = pkcs11h_certificate_enumCertificateIds (
+			PKCS11H_ENUM_METHOD_CACHE_EXIST,
+			NULL,
+			PKCS11H_PROMPT_MASK_ALLOW_ALL,
+			NULL,
+			&id_list
+		)) != CKR_OK
+	) {
+		msg (M_WARN, "PKCS#11: Cannot get certificate list %ld-'%s'", rv, pkcs11h_getMessage (rv));
+		goto cleanup;
+	}
+
+	entry = id_list;
+	count = 0;
+	while (entry != NULL && count != index) {
+		count++;
+		entry = entry->next;
+	}
+
+	if (entry == NULL) {
+		dmsg (
+			D_PKCS11_DEBUG,
+			"PKCS#11: pkcs11_management_id_get - no certificate at index=%d",
+			index
+		);
+		goto cleanup;
+	}
+
+	if (
+		(rv = pkcs11h_certificate_serializeCertificateId (
+			NULL,
+			&max,
+			entry->certificate_id
+		)) != CKR_OK
+	) {
+		msg (M_WARN, "PKCS#11: Cannot serialize certificate id %ld-'%s'", rv, pkcs11h_getMessage (rv));
+		goto cleanup;
+	}
+
+	if ((internal_id = (char *)malloc (max)) == NULL) {
+		msg (M_FATAL, "PKCS#11: Cannot allocate memory");
+		goto cleanup;
+	}
+
+	if (
+		(rv = pkcs11h_certificate_serializeCertificateId (
+			internal_id,
+			&max,
+			entry->certificate_id
+		)) != CKR_OK
+	) {
+		msg (M_WARN, "PKCS#11: Cannot serialize certificate id %ld-'%s'", rv, pkcs11h_getMessage (rv));
+		goto cleanup;
+	}
+
+	if (
+		(rv = pkcs11h_certificate_create (
+			entry->certificate_id,
+			NULL,
+			PKCS11H_PROMPT_MASK_ALLOW_ALL,
+			PKCS11H_PIN_CACHE_INFINITE,
+			&certificate
+		)) != CKR_OK
+	) {
+		msg (M_WARN, "PKCS#11: Cannot get certificate %ld-'%s'", rv, pkcs11h_getMessage (rv));
+		goto cleanup;
+	}
+
+	if (
+		(rv = pkcs11h_certificate_getCertificateBlob (
+			certificate,
+			NULL,
+			&certificate_blob_size
+		)) != CKR_OK
+	) {
+		msg (M_WARN, "PKCS#11: Cannot get certificate blob %ld-'%s'", rv, pkcs11h_getMessage (rv));
+		goto cleanup;
+	}
+
+	if ((certificate_blob = (char *)malloc (certificate_blob_size)) == NULL) {
+		msg (M_FATAL, "PKCS#11: Cannot allocate memory");
+		goto cleanup;
+	}
+
+	if (
+		(rv = pkcs11h_certificate_getCertificateBlob (
+			certificate,
+			certificate_blob,
+			&certificate_blob_size
+		)) != CKR_OK
+	) {
+		msg (M_WARN, "PKCS#11: Cannot get certificate blob %ld-'%s'", rv, pkcs11h_getMessage (rv));
+		goto cleanup;
+	}
+
+	if (base64_encode (certificate_blob, certificate_blob_size, &internal_base64) == -1) {
+		msg (M_WARN, "PKCS#11: Cannot encode certificate");
+		goto cleanup;
+	}
+
+	*id = internal_id;
+	internal_id = NULL;
+	*base64 = internal_base64;
+	internal_base64 = NULL;
+	success = true;
+	
+cleanup:
+
+	if (id_list != NULL) {
+		pkcs11h_certificate_freeCertificateIdList (id_list);
+		id_list = NULL;
+	}
+
+	if (internal_id != NULL) {
+		free (internal_id);
+		internal_id = NULL;
+	}
+
+	if (internal_base64 != NULL) {
+		free (internal_base64);
+		internal_base64 = NULL;
+	}
+
+	if (certificate_blob != NULL) {
+		free (certificate_blob);
+		certificate_blob = NULL;
+	}
+
+	dmsg (
+		D_PKCS11_DEBUG,
+		"PKCS#11: pkcs11_management_id_get - return success=%d, id='%s'",
+		success ? 1 : 0,
+		*id
+	);
+
+	return success;
+}
+
+int
 SSL_CTX_use_pkcs11 (
 	SSL_CTX * const ssl_ctx,
+	bool pkcs11_id_management,
 	const char * const pkcs11_id
 ) {
 	X509 *x509 = NULL;
@@ -403,23 +616,60 @@
 	bool ok = false;
 
 	ASSERT (ssl_ctx!=NULL);
-	ASSERT (pkcs11_id!=NULL);
+	ASSERT (pkcs11_id_management || pkcs11_id!=NULL);
 
 	dmsg (
 		D_PKCS11_DEBUG,
-		"PKCS#11: SSL_CTX_use_pkcs11 - entered - ssl_ctx=%p, pkcs11_id='%s'",
+		"PKCS#11: SSL_CTX_use_pkcs11 - entered - ssl_ctx=%p, pkcs11_id_management=%d, pkcs11_id='%s'",
 		(void *)ssl_ctx,
+		pkcs11_id_management ? 1 : 0,
 		pkcs11_id
 	);
 
-	if (
-		(rv = pkcs11h_certificate_deserializeCertificateId (
-			&certificate_id,
-			pkcs11_id
-		)) != CKR_OK
-	) {
-		msg (M_WARN, "PKCS#11: Cannot deserialize id %ld-'%s'", rv, pkcs11h_getMessage (rv));
-		goto cleanup;
+	if (pkcs11_id_management) {
+		struct user_pass id_resp;
+
+		CLEAR (id_resp);
+
+		id_resp.defined = false;
+		id_resp.nocache = true;
+		openvpn_snprintf (
+			id_resp.username,
+			sizeof (id_resp.username),
+			"Please specify PKCS#11 id to use"
+		);
+
+		if (
+			!get_user_pass (
+				&id_resp,
+				NULL,
+				"pkcs11-id-request",
+				GET_USER_PASS_MANAGEMENT|GET_USER_PASS_NEED_STR|GET_USER_PASS_NOFATAL
+			)
+		) {
+			goto cleanup;
+		}
+
+		if (
+			(rv = pkcs11h_certificate_deserializeCertificateId (
+				&certificate_id,
+				id_resp.password
+			)) != CKR_OK
+		) {
+			msg (M_WARN, "PKCS#11: Cannot deserialize id %ld-'%s'", rv, pkcs11h_getMessage (rv));
+			goto cleanup;
+		}
+	}
+	else {
+		if (
+			(rv = pkcs11h_certificate_deserializeCertificateId (
+				&certificate_id,
+				pkcs11_id
+			)) != CKR_OK
+		) {
+			msg (M_WARN, "PKCS#11: Cannot deserialize id %ld-'%s'", rv, pkcs11h_getMessage (rv));
+			goto cleanup;
+		}
 	}
 
 	if (
diff -urN openvpn-2.1_rc7/pkcs11.h openvpn-2.1_rc9/pkcs11.h
--- openvpn-2.1_rc7/pkcs11.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/pkcs11.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -53,8 +53,19 @@
 pkcs11_logout();
 
 int
+pkcs11_management_id_count ();
+
+bool
+pkcs11_management_id_get (
+	const int index,
+	char ** id,
+	char **base64
+);
+
+int
 SSL_CTX_use_pkcs11 (
 	SSL_CTX * const ssl_ctx,
+	bool pkcs11_id_management,
 	const char * const pkcs11_id
 );
 
diff -urN openvpn-2.1_rc7/plugin/auth-pam/auth-pam.c openvpn-2.1_rc9/plugin/auth-pam/auth-pam.c
--- openvpn-2.1_rc7/plugin/auth-pam/auth-pam.c	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/plugin/auth-pam/auth-pam.c	2008-07-14 20:49:16.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -715,8 +715,14 @@
 	    }
 
 	  if (DEBUG (verb))
-	    fprintf (stderr, "AUTH-PAM: BACKGROUND: USER/PASS: %s/%s\n",
-		     up.username, up.password);
+	    {
+#if 0
+	      fprintf (stderr, "AUTH-PAM: BACKGROUND: USER/PASS: %s/%s\n",
+		       up.username, up.password);
+#else
+	      fprintf (stderr, "AUTH-PAM: BACKGROUND: USER: %s\n", up.username);
+#endif
+	    }
 
 	  if (pam_auth (service, &up)) /* Succeeded */
 	    {
diff -urN openvpn-2.1_rc7/plugin/defer/README openvpn-2.1_rc9/plugin/defer/README
--- openvpn-2.1_rc7/plugin/defer/README	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/plugin/defer/README	2008-06-13 09:54:56.000000000 +0200
@@ -0,0 +1,16 @@
+OpenVPN plugin examples.
+
+Examples provided:
+
+simple.c -- using the --auth-user-pass-verify callback,
+            test deferred authentication.
+
+To build:
+
+  ./build simple (Linux/BSD/etc.)
+  ./winbuild simple (MinGW on Windows)
+
+To use in OpenVPN, add to config file:
+
+  plugin simple.so (Linux/BSD/etc.)
+  plugin simple.dll (MinGW on Windows)
diff -urN openvpn-2.1_rc7/plugin/defer/build openvpn-2.1_rc9/plugin/defer/build
--- openvpn-2.1_rc7/plugin/defer/build	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/plugin/defer/build	2008-06-13 09:54:56.000000000 +0200
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+#
+# Build an OpenVPN plugin module on *nix.  The argument should
+# be the base name of the C source file (without the .c).
+#
+
+# This directory is where we will look for openvpn-plugin.h
+INCLUDE="-I../.."
+
+CC_FLAGS="-O2 -Wall -g"
+
+gcc $CC_FLAGS -fPIC -c $INCLUDE $1.c && \
+gcc $CC_FLAGS -fPIC -shared -Wl,-soname,$1.so -o $1.so $1.o -lc
diff -urN openvpn-2.1_rc7/plugin/defer/simple.c openvpn-2.1_rc9/plugin/defer/simple.c
--- openvpn-2.1_rc7/plugin/defer/simple.c	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/plugin/defer/simple.c	2008-07-14 20:49:16.000000000 +0200
@@ -0,0 +1,305 @@
+/*
+ *  OpenVPN -- An application to securely tunnel IP networks
+ *             over a single TCP/UDP port, with support for SSL/TLS-based
+ *             session authentication and key exchange,
+ *             packet encryption, packet authentication, and
+ *             packet compression.
+ *
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program (see the file COPYING included with this
+ *  distribution); if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This file implements a simple OpenVPN plugin module which
+ * will test deferred authentication and packet filtering.
+ * 
+ * Will run on Windows or *nix.
+ *
+ * Sample usage:
+ *
+ * setenv test_deferred_auth 20
+ * setenv test_packet_filter 10
+ * plugin plugin/defer/simple.so
+ *
+ * This will enable deferred authentication to occur 20
+ * seconds after the normal TLS authentication process,
+ * and will cause a packet filter file to be generated 10
+ * seconds after the initial TLS negotiation, using
+ * {common-name}.pf as the source.
+ *
+ * Sample packet filter configuration:
+ *
+ * [CLIENTS DROP]
+ * +otherclient
+ * [SUBNETS DROP]
+ * +10.0.0.0/8
+ * -10.10.0.8
+ * [END]
+ *
+ * See the README file for build instructions.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "openvpn-plugin.h"
+
+/* bool definitions */
+#define bool int
+#define true 1
+#define false 0
+
+/*
+ * Our context, where we keep our state.
+ */
+
+struct plugin_context {
+  int test_deferred_auth;
+  int test_packet_filter;
+};
+
+struct plugin_per_client_context {
+  int n_calls;
+  bool generated_pf_file;
+};
+
+/*
+ * Given an environmental variable name, search
+ * the envp array for its value, returning it
+ * if found or NULL otherwise.
+ */
+static const char *
+get_env (const char *name, const char *envp[])
+{
+  if (envp)
+    {
+      int i;
+      const int namelen = strlen (name);
+      for (i = 0; envp[i]; ++i)
+	{
+	  if (!strncmp (envp[i], name, namelen))
+	    {
+	      const char *cp = envp[i] + namelen;
+	      if (*cp == '=')
+		return cp + 1;
+	    }
+	}
+    }
+  return NULL;
+}
+
+/* used for safe printf of possible NULL strings */
+static const char *
+np (const char *str)
+{
+  if (str)
+    return str;
+  else
+    return "[NULL]";
+}
+
+static int
+atoi_null0 (const char *str)
+{
+  if (str)
+    return atoi (str);
+  else
+    return 0;
+}
+
+OPENVPN_EXPORT openvpn_plugin_handle_t
+openvpn_plugin_open_v1 (unsigned int *type_mask, const char *argv[], const char *envp[])
+{
+  struct plugin_context *context;
+
+  printf ("FUNC: openvpn_plugin_open_v1\n");
+
+  /*
+   * Allocate our context
+   */
+  context = (struct plugin_context *) calloc (1, sizeof (struct plugin_context));
+
+  context->test_deferred_auth = atoi_null0 (get_env ("test_deferred_auth", envp));
+  printf ("TEST_DEFERRED_AUTH %d\n", context->test_deferred_auth);
+
+  context->test_packet_filter = atoi_null0 (get_env ("test_packet_filter", envp));
+  printf ("TEST_PACKET_FILTER %d\n", context->test_packet_filter);
+
+  /*
+   * Which callbacks to intercept.
+   */
+  *type_mask =
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_UP) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_DOWN) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_ROUTE_UP) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_IPCHANGE) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_TLS_VERIFY) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_CLIENT_CONNECT_V2) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_CLIENT_DISCONNECT) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_LEARN_ADDRESS) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_TLS_FINAL) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_ENABLE_PF);
+
+  return (openvpn_plugin_handle_t) context;
+}
+
+static int
+auth_user_pass_verify (struct plugin_context *context, struct plugin_per_client_context *pcc, const char *argv[], const char *envp[])
+{
+  if (context->test_deferred_auth)
+    {
+      /* get username/password from envp string array */
+      const char *username = get_env ("username", envp);
+      const char *password = get_env ("password", envp);
+
+      /* get auth_control_file filename from envp string array*/
+      const char *auth_control_file = get_env ("auth_control_file", envp);
+
+      printf ("DEFER u='%s' p='%s' acf='%s'\n",
+	      np(username),
+	      np(password),
+	      np(auth_control_file));
+
+      /* Authenticate asynchronously in n seconds */
+      if (auth_control_file)
+	{
+	  char buf[256];
+	  int auth = 2;
+	  sscanf (username, "%d", &auth);
+	  snprintf (buf, sizeof(buf), "( sleep %d ; echo AUTH %s %d ; echo %d >%s ) &",
+		    context->test_deferred_auth,
+		    auth_control_file,
+		    auth,
+		    pcc->n_calls < auth,
+		    auth_control_file);
+	  printf ("%s\n", buf);
+	  system (buf);
+	  pcc->n_calls++;
+	  return OPENVPN_PLUGIN_FUNC_DEFERRED;
+	}
+      else
+	return OPENVPN_PLUGIN_FUNC_ERROR;
+    }
+  else
+    return OPENVPN_PLUGIN_FUNC_SUCCESS;
+}
+
+static int
+tls_final (struct plugin_context *context, struct plugin_per_client_context *pcc, const char *argv[], const char *envp[])
+{
+  if (context->test_packet_filter)
+    {
+      if (!pcc->generated_pf_file)
+	{
+	  const char *pff = get_env ("pf_file", envp);
+	  const char *cn = get_env ("username", envp);
+	  if (pff && cn)
+	    {
+	      char buf[256];
+	      snprintf (buf, sizeof(buf), "( sleep %d ; echo PF %s/%s ; cp \"%s.pf\" \"%s\" ) &",
+			context->test_packet_filter, cn, pff, cn, pff);
+	      printf ("%s\n", buf);
+	      system (buf);
+	      pcc->generated_pf_file = true;
+	      return OPENVPN_PLUGIN_FUNC_SUCCESS;
+	    }
+	  else
+	    return OPENVPN_PLUGIN_FUNC_ERROR;
+	}
+      else
+	return OPENVPN_PLUGIN_FUNC_ERROR;
+    }
+  else
+    return OPENVPN_PLUGIN_FUNC_SUCCESS;
+}
+
+OPENVPN_EXPORT int
+openvpn_plugin_func_v2 (openvpn_plugin_handle_t handle,
+			const int type,
+			const char *argv[],
+			const char *envp[],
+			void *per_client_context,
+			struct openvpn_plugin_string_list **return_list)
+{
+  struct plugin_context *context = (struct plugin_context *) handle;
+  struct plugin_per_client_context *pcc = (struct plugin_per_client_context *) per_client_context;
+  switch (type)
+    {
+    case OPENVPN_PLUGIN_UP:
+      printf ("OPENVPN_PLUGIN_UP\n");
+      return OPENVPN_PLUGIN_FUNC_SUCCESS;
+    case OPENVPN_PLUGIN_DOWN:
+      printf ("OPENVPN_PLUGIN_DOWN\n");
+      return OPENVPN_PLUGIN_FUNC_SUCCESS;
+    case OPENVPN_PLUGIN_ROUTE_UP:
+      printf ("OPENVPN_PLUGIN_ROUTE_UP\n");
+      return OPENVPN_PLUGIN_FUNC_SUCCESS;
+    case OPENVPN_PLUGIN_IPCHANGE:
+      printf ("OPENVPN_PLUGIN_IPCHANGE\n");
+      return OPENVPN_PLUGIN_FUNC_SUCCESS;
+    case OPENVPN_PLUGIN_TLS_VERIFY:
+      printf ("OPENVPN_PLUGIN_TLS_VERIFY\n");
+      return OPENVPN_PLUGIN_FUNC_SUCCESS;
+    case OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY:
+      printf ("OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY\n");
+      return auth_user_pass_verify (context, pcc, argv, envp);
+    case OPENVPN_PLUGIN_CLIENT_CONNECT_V2:
+      printf ("OPENVPN_PLUGIN_CLIENT_CONNECT_V2\n");
+      return OPENVPN_PLUGIN_FUNC_SUCCESS;
+    case OPENVPN_PLUGIN_CLIENT_DISCONNECT:
+      printf ("OPENVPN_PLUGIN_CLIENT_DISCONNECT\n");
+      return OPENVPN_PLUGIN_FUNC_SUCCESS;
+    case OPENVPN_PLUGIN_LEARN_ADDRESS:
+      printf ("OPENVPN_PLUGIN_LEARN_ADDRESS\n");
+      return OPENVPN_PLUGIN_FUNC_SUCCESS;
+    case OPENVPN_PLUGIN_TLS_FINAL:
+      printf ("OPENVPN_PLUGIN_TLS_FINAL\n");
+      return tls_final (context, pcc, argv, envp);
+    case OPENVPN_PLUGIN_ENABLE_PF:
+      printf ("OPENVPN_PLUGIN_ENABLE_PF\n");
+      if (context->test_packet_filter)
+	return OPENVPN_PLUGIN_FUNC_SUCCESS;
+      else
+	return OPENVPN_PLUGIN_FUNC_ERROR;
+    default:
+      printf ("OPENVPN_PLUGIN_?\n");
+      return OPENVPN_PLUGIN_FUNC_ERROR;
+    }
+}
+
+OPENVPN_EXPORT void *
+openvpn_plugin_client_constructor_v1 (openvpn_plugin_handle_t handle)
+{
+  printf ("FUNC: openvpn_plugin_client_constructor_v1\n");
+  return calloc (1, sizeof (struct plugin_per_client_context));
+}
+
+OPENVPN_EXPORT void
+openvpn_plugin_client_destructor_v1 (openvpn_plugin_handle_t handle, void *per_client_context)
+{
+  printf ("FUNC: openvpn_plugin_client_destructor_v1\n");
+  free (per_client_context);
+}
+
+OPENVPN_EXPORT void
+openvpn_plugin_close_v1 (openvpn_plugin_handle_t handle)
+{
+  struct plugin_context *context = (struct plugin_context *) handle;
+  printf ("FUNC: openvpn_plugin_close_v1\n");
+  free (context);
+}
diff -urN openvpn-2.1_rc7/plugin/defer/simple.def openvpn-2.1_rc9/plugin/defer/simple.def
--- openvpn-2.1_rc7/plugin/defer/simple.def	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/plugin/defer/simple.def	2008-06-13 09:54:56.000000000 +0200
@@ -0,0 +1,6 @@
+LIBRARY   OpenVPN_PLUGIN_SAMPLE
+DESCRIPTION "Sample OpenVPN plug-in module."
+EXPORTS
+   openvpn_plugin_open_v1   @1
+   openvpn_plugin_func_v1   @2
+   openvpn_plugin_close_v1  @3
diff -urN openvpn-2.1_rc7/plugin/defer/winbuild openvpn-2.1_rc9/plugin/defer/winbuild
--- openvpn-2.1_rc7/plugin/defer/winbuild	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/plugin/defer/winbuild	2008-06-13 09:54:56.000000000 +0200
@@ -0,0 +1,18 @@
+#
+# Build an OpenVPN plugin module on Windows/MinGW.
+# The argument should be the base name of the C source file
+# (without the .c).
+#
+
+# This directory is where we will look for openvpn-plugin.h
+INCLUDE="-I.."
+
+CC_FLAGS="-O2 -Wall"
+
+gcc -DBUILD_DLL $CC_FLAGS $INCLUDE -c $1.c
+gcc --disable-stdcall-fixup -mdll -DBUILD_DLL -o junk.tmp -Wl,--base-file,base.tmp $1.o
+rm junk.tmp
+dlltool --dllname $1.dll --base-file base.tmp --output-exp temp.exp --input-def $1.def
+rm base.tmp
+gcc --enable-stdcall-fixup -mdll -DBUILD_DLL -o $1.dll $1.o -Wl,temp.exp
+rm temp.exp
diff -urN openvpn-2.1_rc7/plugin/down-root/down-root.c openvpn-2.1_rc9/plugin/down-root/down-root.c
--- openvpn-2.1_rc7/plugin/down-root/down-root.c	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/plugin/down-root/down-root.c	2008-07-14 20:49:16.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/plugin/examples/build openvpn-2.1_rc9/plugin/examples/build
--- openvpn-2.1_rc7/plugin/examples/build	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/plugin/examples/build	2008-06-13 09:54:56.000000000 +0200
@@ -8,7 +8,7 @@
 # This directory is where we will look for openvpn-plugin.h
 INCLUDE="-I../.."
 
-CC_FLAGS="-O2 -Wall"
+CC_FLAGS="-O2 -Wall -g"
 
 gcc $CC_FLAGS -fPIC -c $INCLUDE $1.c && \
-gcc -fPIC -shared -Wl,-soname,$1.so -o $1.so $1.o -lc
+gcc $CC_FLAGS -fPIC -shared -Wl,-soname,$1.so -o $1.so $1.o -lc
diff -urN openvpn-2.1_rc7/plugin/examples/log.c openvpn-2.1_rc9/plugin/examples/log.c
--- openvpn-2.1_rc7/plugin/examples/log.c	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/plugin/examples/log.c	2008-07-24 11:10:13.000000000 +0200
@@ -0,0 +1,184 @@
+/*
+ *  OpenVPN -- An application to securely tunnel IP networks
+ *             over a single TCP/UDP port, with support for SSL/TLS-based
+ *             session authentication and key exchange,
+ *             packet encryption, packet authentication, and
+ *             packet compression.
+ *
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program (see the file COPYING included with this
+ *  distribution); if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This plugin is similar to simple.c, except it also logs extra information
+ * to stdout for every plugin method called by OpenVPN.
+ *
+ * See the README file for build instructions.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "openvpn-plugin.h"
+
+/*
+ * Our context, where we keep our state.
+ */
+struct plugin_context {
+  const char *username;
+  const char *password;
+};
+
+/*
+ * Given an environmental variable name, search
+ * the envp array for its value, returning it
+ * if found or NULL otherwise.
+ */
+static const char *
+get_env (const char *name, const char *envp[])
+{
+  if (envp)
+    {
+      int i;
+      const int namelen = strlen (name);
+      for (i = 0; envp[i]; ++i)
+	{
+	  if (!strncmp (envp[i], name, namelen))
+	    {
+	      const char *cp = envp[i] + namelen;
+	      if (*cp == '=')
+		return cp + 1;
+	    }
+	}
+    }
+  return NULL;
+}
+
+OPENVPN_EXPORT openvpn_plugin_handle_t
+openvpn_plugin_open_v1 (unsigned int *type_mask, const char *argv[], const char *envp[])
+{
+  struct plugin_context *context;
+
+  /*
+   * Allocate our context
+   */
+  context = (struct plugin_context *) calloc (1, sizeof (struct plugin_context));
+
+  /*
+   * Set the username/password we will require.
+   */
+  context->username = "foo";
+  context->password = "bar";
+
+  /*
+   * Which callbacks to intercept.
+   */
+  *type_mask =
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_UP) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_DOWN) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_ROUTE_UP) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_IPCHANGE) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_TLS_VERIFY) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_CLIENT_CONNECT_V2) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_CLIENT_DISCONNECT) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_LEARN_ADDRESS) |
+    OPENVPN_PLUGIN_MASK (OPENVPN_PLUGIN_TLS_FINAL);
+
+  return (openvpn_plugin_handle_t) context;
+}
+
+void
+show (const int type, const char *argv[], const char *envp[])
+{
+  size_t i;
+  switch (type)
+    {
+    case OPENVPN_PLUGIN_UP:
+      printf ("OPENVPN_PLUGIN_UP\n");
+      break;
+    case OPENVPN_PLUGIN_DOWN:
+      printf ("OPENVPN_PLUGIN_DOWN\n");
+      break;
+    case OPENVPN_PLUGIN_ROUTE_UP:
+      printf ("OPENVPN_PLUGIN_ROUTE_UP\n");
+      break;
+    case OPENVPN_PLUGIN_IPCHANGE:
+      printf ("OPENVPN_PLUGIN_IPCHANGE\n");
+      break;
+    case OPENVPN_PLUGIN_TLS_VERIFY:
+      printf ("OPENVPN_PLUGIN_TLS_VERIFY\n");
+      break;
+    case OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY:
+      printf ("OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY\n");
+      break;
+    case OPENVPN_PLUGIN_CLIENT_CONNECT_V2:
+      printf ("OPENVPN_PLUGIN_CLIENT_CONNECT_V2\n");
+      break;
+    case OPENVPN_PLUGIN_CLIENT_DISCONNECT:
+      printf ("OPENVPN_PLUGIN_CLIENT_DISCONNECT\n");
+      break;
+    case OPENVPN_PLUGIN_LEARN_ADDRESS:
+      printf ("OPENVPN_PLUGIN_LEARN_ADDRESS\n");
+      break;
+    case OPENVPN_PLUGIN_TLS_FINAL:
+      printf ("OPENVPN_PLUGIN_TLS_FINAL\n");
+      break;
+    default:
+      printf ("OPENVPN_PLUGIN_?\n");
+      break;
+    }
+
+  printf ("ARGV\n");
+  for (i = 0; argv[i] != NULL; ++i)
+    printf ("%d '%s'\n", (int)i, argv[i]);
+
+  printf ("ENVP\n");
+  for (i = 0; envp[i] != NULL; ++i)
+    printf ("%d '%s'\n", (int)i, envp[i]);
+}
+
+OPENVPN_EXPORT int
+openvpn_plugin_func_v1 (openvpn_plugin_handle_t handle, const int type, const char *argv[], const char *envp[])
+{
+  struct plugin_context *context = (struct plugin_context *) handle;
+
+  show (type, argv, envp);
+
+  /* check entered username/password against what we require */
+  if (type == OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY)
+    {
+      /* get username/password from envp string array */
+      const char *username = get_env ("username", envp);
+      const char *password = get_env ("password", envp);
+
+      if (username && !strcmp (username, context->username)
+	  && password && !strcmp (password, context->password))
+	return OPENVPN_PLUGIN_FUNC_SUCCESS;
+      else
+	return OPENVPN_PLUGIN_FUNC_ERROR;
+    }
+  else
+    return OPENVPN_PLUGIN_FUNC_SUCCESS;
+}
+
+OPENVPN_EXPORT void
+openvpn_plugin_close_v1 (openvpn_plugin_handle_t handle)
+{
+  struct plugin_context *context = (struct plugin_context *) handle;
+  free (context);
+}
diff -urN openvpn-2.1_rc7/plugin/examples/simple.c openvpn-2.1_rc9/plugin/examples/simple.c
--- openvpn-2.1_rc7/plugin/examples/simple.c	2008-01-23 22:08:37.000000000 +0100
+++ openvpn-2.1_rc9/plugin/examples/simple.c	2008-07-14 20:49:16.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/plugin.c openvpn-2.1_rc9/plugin.c
--- openvpn-2.1_rc7/plugin.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/plugin.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #ifdef ENABLE_PLUGIN
@@ -49,7 +43,10 @@
 {
   int i;
   for (i = 0; array[i]; ++i)
-    msg (msglevel, "%s[%d] = '%s'", name, i, array[i]);
+    {
+      if (env_safe_to_print (array[i]))
+	msg (msglevel, "%s[%d] = '%s'", name, i, array[i]);
+    }
 }
 
 static void
@@ -89,6 +86,8 @@
       return "PLUGIN_LEARN_ADDRESS";
     case OPENVPN_PLUGIN_TLS_FINAL:
       return "PLUGIN_TLS_FINAL";
+    case OPENVPN_PLUGIN_ENABLE_PF:
+      return "OPENVPN_PLUGIN_ENABLE_PF";
     default:
       return "PLUGIN_???";
     }
@@ -186,6 +185,8 @@
 plugin_init_item (struct plugin *p, const struct plugin_option *o)
 {
   struct gc_arena gc = gc_new ();
+  bool rel = false;
+
   p->so_pathname = o->so_pathname;
   p->plugin_type_mask = plugin_supported_types ();
 
@@ -193,7 +194,7 @@
 
   p->handle = NULL;
 #if defined(PLUGIN_LIBDIR)
-  if (!strrchr(p->so_pathname, '/'))
+  if (!absolute_pathname (p->so_pathname))
     {
       char full[PATH_MAX];
 
@@ -202,6 +203,7 @@
 #if defined(ENABLE_PLUGIN_SEARCH)
       if (!p->handle)
 	{
+	  rel = true;
 	  p->handle = dlopen (p->so_pathname, RTLD_NOW);
 	}
 #endif
@@ -209,6 +211,7 @@
   else
 #endif
     {
+      rel = !absolute_pathname (p->so_pathname);
       p->handle = dlopen (p->so_pathname, RTLD_NOW);
     }
   if (!p->handle)
@@ -218,6 +221,7 @@
 
 #elif defined(USE_LOAD_LIBRARY)
 
+  rel = !absolute_pathname (p->so_pathname);
   p->module = LoadLibrary (p->so_pathname);
   if (!p->module)
     msg (M_ERR, "PLUGIN_INIT: could not load plugin DLL: %s", p->so_pathname);
@@ -261,6 +265,9 @@
   else
     p->requested_initialization_point = OPENVPN_PLUGIN_INIT_PRE_DAEMON;
 
+  if (rel)
+    msg (M_WARN, "WARNING: plugin '%s' specified by a relative pathname -- using an absolute pathname would be more secure", p->so_pathname);
+
   p->initialized = true;
 
   gc_free (&gc);
@@ -320,7 +327,7 @@
 plugin_call_item (const struct plugin *p,
 		  void *per_client_context,
 		  const int type,
-		  const char *args,
+		  const struct argv *av,
 		  struct openvpn_plugin_string_list **retlist,
 		  const char **envp)
 {
@@ -333,18 +340,18 @@
   if (p->plugin_handle && (p->plugin_type_mask & OPENVPN_PLUGIN_MASK (type)))
     {
       struct gc_arena gc = gc_new ();
-      const char **argv = make_arg_array (p->so_pathname, args, &gc);
+      struct argv a = argv_insert_head (av, p->so_pathname);
 
       dmsg (D_PLUGIN_DEBUG, "PLUGIN_CALL: PRE type=%s", plugin_type_name (type));
-      plugin_show_args_env (D_PLUGIN_DEBUG, argv, envp);
+      plugin_show_args_env (D_PLUGIN_DEBUG, (const char **)a.argv, envp);
 
       /*
        * Call the plugin work function
        */
       if (p->func2)
-	status = (*p->func2)(p->plugin_handle, type, argv, envp, per_client_context, retlist);
+	status = (*p->func2)(p->plugin_handle, type, (const char **)a.argv, envp, per_client_context, retlist);
       else if (p->func1)
-	status = (*p->func1)(p->plugin_handle, type, argv, envp);
+	status = (*p->func1)(p->plugin_handle, type, (const char **)a.argv, envp);
       else
 	ASSERT (0);
 
@@ -353,12 +360,13 @@
 	   plugin_type_name (type),
 	   status);
 
-      if (status != OPENVPN_PLUGIN_FUNC_SUCCESS)
+      if (status == OPENVPN_PLUGIN_FUNC_ERROR)
 	msg (M_WARN, "PLUGIN_CALL: plugin function %s failed with status %d: %s",
 	     plugin_type_name (type),
 	     status,
 	     p->so_pathname);
 
+      argv_reset (&a);
       gc_free (&gc);
     }
   return status;
@@ -407,7 +415,6 @@
   const int n = pc->n;
   int i;
 
-  CLEAR (*cli);
   for (i = 0; i < n; ++i)
     {
       const struct plugin *p = &pc->plugins[i];
@@ -476,7 +483,7 @@
   int i;
   const char **envp;
 
-  envp = make_env_array (es, &gc);
+  envp = make_env_array (es, false, &gc);
 
   if (pr)
     plugin_return_init (pr);
@@ -534,7 +541,7 @@
 int
 plugin_call (const struct plugin_list *pl,
 	     const int type,
-	     const char *args,
+	     const struct argv *av,
 	     struct plugin_return *pr,
 	     struct env_set *es)
 {
@@ -547,22 +554,35 @@
       int i;
       const char **envp;
       const int n = plugin_n (pl);
-      int count = 0;
+      bool success = false;
+      bool error = false;
+      bool deferred = false;
       
       mutex_lock_static (L_PLUGIN);
 
       setenv_del (es, "script_type");
-      envp = make_env_array (es, &gc);
+      envp = make_env_array (es, false, &gc);
 
       for (i = 0; i < n; ++i)
 	{
-	  if (!plugin_call_item (&pl->common->plugins[i],
-				 pl->per_client.per_client_context[i],
-				 type,
-				 args,
-				 pr ? &pr->list[i] : NULL,
-				 envp))
-	    ++count;
+	  const int status = plugin_call_item (&pl->common->plugins[i],
+					       pl->per_client.per_client_context[i],
+					       type,
+					       av,
+					       pr ? &pr->list[i] : NULL,
+					       envp);
+	  switch (status)
+	    {
+	    case OPENVPN_PLUGIN_FUNC_SUCCESS:
+	      success = true;
+	      break;
+	    case OPENVPN_PLUGIN_FUNC_DEFERRED:
+	      deferred = true;
+	      break;
+	    default:
+	      error = true;
+	      break;
+	    }
 	}
 
       if (pr)
@@ -572,12 +592,15 @@
 
       gc_free (&gc);
 
-      return count == n ? 0 : 1; /* if any one plugin in the chain failed, return failure (1) */
-    }
-  else
-    {
-      return 0;
+      if (type == OPENVPN_PLUGIN_ENABLE_PF && success)
+	return OPENVPN_PLUGIN_FUNC_SUCCESS;
+      else if (error)
+	return OPENVPN_PLUGIN_FUNC_ERROR;
+      else if (deferred)
+	return OPENVPN_PLUGIN_FUNC_DEFERRED;
     }
+
+  return OPENVPN_PLUGIN_FUNC_SUCCESS;
 }
 
 void
diff -urN openvpn-2.1_rc7/plugin.h openvpn-2.1_rc9/plugin.h
--- openvpn-2.1_rc7/plugin.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/plugin.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -116,7 +116,7 @@
 
 int plugin_call (const struct plugin_list *pl,
 		 const int type,
-		 const char *args,
+		 const struct argv *av,
 		 struct plugin_return *pr,
 		 struct env_set *es);
 
@@ -168,7 +168,7 @@
 static inline int
 plugin_call (const struct plugin_list *pl,
 	     const int type,
-	     const char *args,
+	     const struct argv *av,
 	     struct plugin_return *pr,
 	     struct env_set *es)
 {
diff -urN openvpn-2.1_rc7/pool.c openvpn-2.1_rc9/pool.c
--- openvpn-2.1_rc7/pool.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/pool.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "pool.h"
diff -urN openvpn-2.1_rc7/pool.h openvpn-2.1_rc9/pool.h
--- openvpn-2.1_rc7/pool.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/pool.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/proto.c openvpn-2.1_rc9/proto.c
--- openvpn-2.1_rc7/proto.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/proto.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "proto.h"
diff -urN openvpn-2.1_rc7/proto.h openvpn-2.1_rc9/proto.h
--- openvpn-2.1_rc7/proto.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/proto.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -28,6 +28,8 @@
 #include "common.h"
 #include "buffer.h"
 
+#pragma pack(1)
+
 /*
  * Tunnel types
  */
@@ -62,6 +64,24 @@
   uint16_t proto;                     /* packet type ID field */
 };
 
+struct openvpn_arp {
+# define ARP_MAC_ADDR_TYPE 0x0001
+  uint16_t mac_addr_type;       // 0x0001
+
+  uint16_t proto_addr_type;     // 0x0800
+  uint8_t  mac_addr_size;       // 0x06
+  uint8_t  proto_addr_size;     // 0x04
+
+# define ARP_REQUEST 0x0001
+# define ARP_REPLY   0x0002
+  uint16_t arp_command;         // 0x0001 for ARP request, 0x0002 for ARP reply
+
+  uint8_t   mac_src[OPENVPN_ETH_ALEN];
+  in_addr_t ip_src;
+  uint8_t   mac_dest[OPENVPN_ETH_ALEN];
+  in_addr_t ip_dest;
+};
+
 struct openvpn_iphdr {
 # define OPENVPN_IPH_GET_VER(v) (((v) >> 4) & 0x0F)
 # define OPENVPN_IPH_GET_LEN(v) (((v) & 0x0F) << 2)
@@ -129,6 +149,8 @@
 #define	OPENVPN_TCPOPT_MAXSEG  2
 #define OPENVPN_TCPOLEN_MAXSEG 4
 
+#pragma pack()
+
 /*
  * The following macro is used to update an
  * internet checksum.  "acc" is a 32-bit
diff -urN openvpn-2.1_rc7/proxy.c openvpn-2.1_rc9/proxy.c
--- openvpn-2.1_rc7/proxy.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/proxy.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "common.h"
@@ -235,9 +229,8 @@
 }
 
 struct http_proxy_info *
-new_http_proxy (const struct http_proxy_options *o,
-		struct auto_proxy_info *auto_proxy_info,
-		struct gc_arena *gc)
+http_proxy_new (const struct http_proxy_options *o,
+		struct auto_proxy_info *auto_proxy_info)
 {
   struct http_proxy_info *p;
   struct http_proxy_options opt;
@@ -281,7 +274,7 @@
 
   ASSERT (legal_ipv4_port (o->port));
 
-  ALLOC_OBJ_CLEAR_GC (p, struct http_proxy_info, gc);
+  ALLOC_OBJ_CLEAR (p, struct http_proxy_info);
   p->options = *o;
 
   /* parse authentication method */
@@ -294,19 +287,21 @@
 	p->auth_method = HTTP_AUTH_BASIC;
       else if (!strcmp (o->auth_method_string, "ntlm"))
 	p->auth_method = HTTP_AUTH_NTLM;
+      else if (!strcmp (o->auth_method_string, "ntlm2"))
+	p->auth_method = HTTP_AUTH_NTLM2;
       else
-	msg (M_FATAL, "ERROR: unknown HTTP authentication method: '%s' -- only the 'none', 'basic', or 'ntlm' methods are currently supported",
+	msg (M_FATAL, "ERROR: unknown HTTP authentication method: '%s' -- only the 'none', 'basic', 'ntlm', or 'ntlm2' methods are currently supported",
 	     o->auth_method_string);
     }
 
-  /* only basic and NTLM authentication supported so far */
-  if (p->auth_method == HTTP_AUTH_BASIC || p->auth_method == HTTP_AUTH_NTLM)
+  /* only basic and NTLM/NTLMv2 authentication supported so far */
+  if (p->auth_method == HTTP_AUTH_BASIC || p->auth_method == HTTP_AUTH_NTLM || p->auth_method == HTTP_AUTH_NTLM2)
     {
       get_user_pass_http (p, true);
     }
 
 #if !NTLM
-  if (p->auth_method == HTTP_AUTH_NTLM)
+  if (p->auth_method == HTTP_AUTH_NTLM || p->auth_method == HTTP_AUTH_NTLM2)
     msg (M_FATAL, "Sorry, this version of " PACKAGE_NAME " was built without NTLM Proxy support.");
 #endif
 
@@ -314,6 +309,12 @@
   return p;
 }
 
+void
+http_proxy_close (struct http_proxy_info *hp)
+{
+  free (hp);
+}
+
 bool
 establish_http_proxy_passthru (struct http_proxy_info *p,
 			       socket_descriptor_t sd, /* already open to proxy */
@@ -374,6 +375,12 @@
 
 #if NTLM
     case HTTP_AUTH_NTLM:
+    case HTTP_AUTH_NTLM2:
+      /* keep-alive connection */
+      openvpn_snprintf (buf, sizeof(buf), "Proxy-Connection: Keep-Alive");
+      if (!send_line_crlf (sd, buf))
+	goto error;
+
       openvpn_snprintf (buf, sizeof(buf), "Proxy-Authorization: NTLM %s",
 			ntlm_phase_1 (p, &gc));
       msg (D_PROXY, "Attempting NTLM Proxy-Authorization phase 1");
@@ -411,7 +418,7 @@
       msg (D_PROXY, "Proxy requires authentication");
 
       /* check for NTLM */
-      if (p->auth_method == HTTP_AUTH_NTLM)
+      if (p->auth_method == HTTP_AUTH_NTLM || p->auth_method == HTTP_AUTH_NTLM2)
         {
 #if NTLM
           /* look for the phase 2 response */
@@ -456,6 +463,12 @@
           if (!send_line_crlf (sd, buf))
             goto error;
 
+          /* keep-alive connection */
+          openvpn_snprintf (buf, sizeof(buf), "Proxy-Connection: Keep-Alive");
+          if (!send_line_crlf (sd, buf))
+            goto error;
+
+          
           /* send HOST etc, */
           openvpn_sleep (1);
           openvpn_snprintf (buf, sizeof(buf), "Host: %s", host);
@@ -463,9 +476,17 @@
           if (!send_line_crlf (sd, buf))
             goto error;
 
-          openvpn_snprintf (buf, sizeof(buf), "Proxy-Authorization: NTLM %s",
-			    ntlm_phase_3 (p, buf2, &gc));
           msg (D_PROXY, "Attempting NTLM Proxy-Authorization phase 3");
+	  {
+	    const char *np3 = ntlm_phase_3 (p, buf2, &gc);
+	    if (!np3)
+	      {
+		msg (D_PROXY, "NTLM Proxy-Authorization phase 3 failed: received corrupted data from proxy server");
+		goto error;
+	      }
+	    openvpn_snprintf (buf, sizeof(buf), "Proxy-Authorization: NTLM %s", np3);
+	  }
+
           msg (D_PROXY, "Send to HTTP proxy: '%s'", buf);
           openvpn_sleep (1);
           if (!send_line_crlf (sd, buf))
diff -urN openvpn-2.1_rc7/proxy.h openvpn-2.1_rc9/proxy.h
--- openvpn-2.1_rc7/proxy.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/proxy.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -59,6 +59,7 @@
 #define HTTP_AUTH_BASIC 1
 #define HTTP_AUTH_NTLM  2
 #define HTTP_AUTH_N     3
+#define HTTP_AUTH_NTLM2 4
 
 struct http_proxy_options {
   const char *server;
@@ -79,9 +80,10 @@
   struct user_pass up;
 };
 
-struct http_proxy_info *new_http_proxy (const struct http_proxy_options *o,
-					struct auto_proxy_info *auto_proxy_info,
-					struct gc_arena *gc);
+struct http_proxy_info *http_proxy_new (const struct http_proxy_options *o,
+					struct auto_proxy_info *auto_proxy_info);
+
+void http_proxy_close (struct http_proxy_info *hp);
 
 bool establish_http_proxy_passthru (struct http_proxy_info *p,
 				    socket_descriptor_t sd, /* already open to proxy */
diff -urN openvpn-2.1_rc7/ps.c openvpn-2.1_rc9/ps.c
--- openvpn-2.1_rc7/ps.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/ps.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if PORT_SHARE
@@ -35,6 +29,7 @@
 #include "event.h"
 #include "socket.h"
 #include "fdmisc.h"
+#include "crypto.h"
 #include "ps.h"
 
 #include "memdbg.h"
@@ -797,6 +792,9 @@
       /* no blocking on control channel back to parent */
       set_nonblock (fd[1]);
 
+      /* initialize prng */
+      prng_init ();
+
       /* execute the event loop */
       port_share_proxy (hostaddr, port, fd[1]);
 
diff -urN openvpn-2.1_rc7/ps.h openvpn-2.1_rc9/ps.h
--- openvpn-2.1_rc7/ps.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/ps.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/push.c openvpn-2.1_rc9/push.c
--- openvpn-2.1_rc7/push.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/push.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "push.h"
@@ -76,10 +70,11 @@
 /*
  * Send auth failed message from server to client.
  */
-bool
+void
 send_auth_failed (struct context *c)
 {
-  return send_control_channel_string (c, "AUTH_FAILED", D_PUSH);
+  schedule_exit (c, c->options.scheduled_exit_interval);
+  send_control_channel_string (c, "AUTH_FAILED", D_PUSH);
 }
 #endif
 
@@ -206,10 +201,9 @@
 #if P2MP_SERVER
   if (buf_string_compare_advance (&buf, "PUSH_REQUEST"))
     {
-      if (!tls_authenticated (c->c2.tls_multi) || c->c2.context_auth == CAS_FAILED)
+      if (tls_authentication_status (c->c2.tls_multi, 0) == TLS_AUTHENTICATION_FAILED || c->c2.context_auth == CAS_FAILED)
 	{
 	  send_auth_failed (c);
-	  schedule_exit (c, c->options.scheduled_exit_interval);
 	  ret = PUSH_MSG_AUTH_FAILURE;
 	}
       else if (!c->c2.push_reply_deferred && c->c2.context_auth == CAS_SUCCEEDED)
diff -urN openvpn-2.1_rc7/push.h openvpn-2.1_rc9/push.h
--- openvpn-2.1_rc7/push.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/push.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -59,7 +59,7 @@
 
 void remove_iroutes_from_push_route_list (struct options *o);
 
-bool send_auth_failed (struct context *c);
+void send_auth_failed (struct context *c);
 
 #endif
 #endif
diff -urN openvpn-2.1_rc7/reliable.c openvpn-2.1_rc9/reliable.c
--- openvpn-2.1_rc7/reliable.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/reliable.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -27,16 +27,10 @@
  * so that SSL/TLS can be run over UDP.
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
+#include "syshead.h"
 
 #if defined(USE_CRYPTO) && defined(USE_SSL)
 
-#include "syshead.h"
-
 #include "buffer.h"
 #include "error.h"
 #include "common.h"
@@ -44,6 +38,39 @@
 
 #include "memdbg.h"
 
+/*
+ * verify that test - base < extent while allowing for base or test wraparound
+ */
+static inline bool
+reliable_pid_in_range (const packet_id_type test,
+		       const packet_id_type base,
+		       const unsigned int extent)
+{
+  if (test >= base)
+    {
+      if (test - base < extent)
+	return true;
+    }
+  else
+    {      
+      const packet_id_type be = base + extent;
+      if (test < be && be < base)
+	return true;
+    }
+
+  return false;
+}
+
+/*
+ * verify that p1 < p2  while allowing for p1 or p2 wraparound
+ */
+static inline bool
+reliable_pid_min (const packet_id_type p1,
+		  const packet_id_type p2)
+{
+  return !reliable_pid_in_range (p1, p2, 0x80000000);
+}
+
 /* check if a particular packet_id is present in ack */
 static inline bool
 reliable_ack_packet_id_present (struct reliable_ack *ack, packet_id_type pid)
@@ -336,7 +363,7 @@
 {
   struct gc_arena gc = gc_new ();
   int i;
-  if (id < rel->packet_id)
+  if (reliable_pid_min (id, rel->packet_id))
     goto bad;
   for (i = 0; i < rel->size; ++i)
     {
@@ -358,18 +385,17 @@
 reliable_wont_break_sequentiality (const struct reliable *rel, packet_id_type id)
 {
   struct gc_arena gc = gc_new ();
-  int ret;
 
-  if ((int)id < (int)rel->packet_id + rel->size)
-    {
-      ret = true;
-    }
-  else
+  const int ret = reliable_pid_in_range (id, rel->packet_id, rel->size);
+
+  if (!ret)
     {
       dmsg (D_REL_LOW, "ACK " packet_id_format " breaks sequentiality: %s",
 	   (packet_id_print_type)id, reliable_print_ids (rel, &gc));
-      ret = false;
     }
+
+  dmsg (D_REL_DEBUG, "ACK RWBS rel->size=%d rel->packet_id=%08x id=%08x ret=%d\n", rel->size, rel->packet_id, id, ret);
+
   gc_free (&gc);
   return ret;
 }
@@ -407,7 +433,7 @@
       const struct reliable_entry *e = &rel->array[i];
       if (e->active)
 	{
-	  if (!min_id_defined || e->packet_id < min_id)
+	  if (!min_id_defined || reliable_pid_min (e->packet_id, min_id))
 	    {
 	      min_id_defined = true;
 	      min_id = e->packet_id;
@@ -415,7 +441,7 @@
 	}
     }
 
-  if (!min_id_defined || (int)(rel->packet_id - min_id) < rel->size)
+  if (!min_id_defined || reliable_pid_in_range (rel->packet_id, min_id, rel->size))
     {
       ret = reliable_get_buf (rel);
     }
@@ -502,7 +528,7 @@
       struct reliable_entry *e = &rel->array[i];
       if (e->active && local_now >= e->next_try)
 	{
-	  if (!best || e->packet_id < best->packet_id)
+	  if (!best || reliable_pid_min (e->packet_id, best->packet_id))
 	    best = e;
 	}
     }
@@ -598,7 +624,7 @@
 	  e->packet_id = pid;
 
 	  /* check for replay */
-	  ASSERT (pid >= rel->packet_id);
+	  ASSERT (!reliable_pid_min (pid, rel->packet_id));
 
 	  e->opcode = opcode;
 	  e->next_try = 0;
diff -urN openvpn-2.1_rc7/reliable.h openvpn-2.1_rc9/reliable.h
--- openvpn-2.1_rc7/reliable.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/reliable.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/route.c openvpn-2.1_rc9/route.c
--- openvpn-2.1_rc7/route.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/route.c	2008-07-27 00:11:59.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -26,12 +26,6 @@
  * Support routines for adding/deleting network routes.
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "common.h"
@@ -40,6 +34,7 @@
 #include "misc.h"
 #include "socket.h"
 #include "manage.h"
+#include "win32.h"
 
 #include "memdbg.h"
 
@@ -144,43 +139,65 @@
 		  in_addr_t *out,
 		  bool *status)
 {
-  *status = true;
+  if (status)
+    *status = true;
   if (!strcmp (string, "vpn_gateway"))
     {
-      if (spec->remote_endpoint_defined)
-	*out = spec->remote_endpoint;
-      else
+      if (spec)
 	{
-	  msg (M_INFO, PACKAGE_NAME " ROUTE: vpn_gateway undefined");
-	  *status = false;
+	  if (spec->remote_endpoint_defined)
+	    *out = spec->remote_endpoint;
+	  else
+	    {
+	      msg (M_INFO, PACKAGE_NAME " ROUTE: vpn_gateway undefined");
+	      if (status)
+		*status = false;
+	    }
 	}
       return true;
     }
   else if (!strcmp (string, "net_gateway"))
     {
-      if (spec->net_gateway_defined)
-	*out = spec->net_gateway;
-      else
+      if (spec)
 	{
-	  msg (M_INFO, PACKAGE_NAME " ROUTE: net_gateway undefined -- unable to get default gateway from system");
-	  *status = false;
+	  if (spec->net_gateway_defined)
+	    *out = spec->net_gateway;
+	  else
+	    {
+	      msg (M_INFO, PACKAGE_NAME " ROUTE: net_gateway undefined -- unable to get default gateway from system");
+	      if (status)
+		*status = false;
+	    }
 	}
       return true;
     }
   else if (!strcmp (string, "remote_host"))
     {
-      if (spec->remote_host_defined)
-	*out = spec->remote_host;
-      else
+      if (spec)
 	{
-	  msg (M_INFO, PACKAGE_NAME " ROUTE: remote_host undefined");
-	  *status = false;
+	  if (spec->remote_host_defined)
+	    *out = spec->remote_host;
+	  else
+	    {
+	      msg (M_INFO, PACKAGE_NAME " ROUTE: remote_host undefined");
+	      if (status)
+		*status = false;
+	    }
 	}
       return true;
     }
   return false;
 }
 
+bool
+is_special_addr (const char *addr_str)
+{
+  if (addr_str)
+    return get_special_addr (NULL, addr_str, NULL, NULL);
+  else
+    return false;
+}
+
 static bool
 init_route (struct route *r,
 	    const struct route_option *ro,
@@ -749,7 +766,7 @@
 add_route (struct route *r, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
 {
   struct gc_arena gc;
-  struct buffer buf;
+  struct argv argv;
   const char *network;
   const char *netmask;
   const char *gateway;
@@ -759,7 +776,7 @@
     return;
 
   gc_init (&gc);
-  buf = alloc_buf_gc (256, &gc);
+  argv_init (&argv);
 
   network = print_in_addr_t (r->network, 0, &gc);
   netmask = print_in_addr_t (r->netmask, 0, &gc);
@@ -777,35 +794,38 @@
 
 #if defined(TARGET_LINUX)
 #ifdef CONFIG_FEATURE_IPROUTE
-  buf_printf (&buf, "%s route add %s/%d via %s",
+  argv_printf (&argv, "%s route add %s/%d via %s",
   	      iproute_path,
 	      network,
 	      count_netmask_bits(netmask),
 	      gateway);
   if (r->metric_defined)
-    buf_printf (&buf, " metric %d", r->metric);
+    argv_printf_cat (&argv, "metric %d", r->metric);
 
 #else
-  buf_printf (&buf, ROUTE_PATH " add -net %s netmask %s gw %s",
+  argv_printf (&argv, "%s add -net %s netmask %s gw %s",
+		ROUTE_PATH,
 	      network,
 	      netmask,
 	      gateway);
   if (r->metric_defined)
-    buf_printf (&buf, " metric %d", r->metric);
+    argv_printf_cat (&argv, "metric %d", r->metric);
 #endif  /*CONFIG_FEATURE_IPROUTE*/
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  status = system_check (BSTR (&buf), es, 0, "ERROR: Linux route add command failed");
+  argv_msg (D_ROUTE, &argv);
+  status = openvpn_execve_check (&argv, es, 0, "ERROR: Linux route add command failed");
 
 #elif defined (WIN32)
 
-  buf_printf (&buf, ROUTE_PATH " ADD %s MASK %s %s",
-	      network,
-	      netmask,
-	      gateway);
+  argv_printf (&argv, "%s%s ADD %s MASK %s %s",
+	       get_win_sys_path(),
+	       WIN_ROUTE_PATH_SUFFIX,
+	       network,
+	       netmask,
+	       gateway);
   if (r->metric_defined)
-    buf_printf (&buf, " METRIC %d", r->metric);
+    argv_printf_cat (&argv, "METRIC %d", r->metric);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
+  argv_msg (D_ROUTE, &argv);
 
   if ((flags & ROUTE_METHOD_MASK) == ROUTE_METHOD_IPAPI)
     {
@@ -815,7 +835,7 @@
   else if ((flags & ROUTE_METHOD_MASK) == ROUTE_METHOD_EXE)
     {
       netcmd_semaphore_lock ();
-      status = system_check (BSTR (&buf), es, 0, "ERROR: Windows route add command failed");
+      status = openvpn_execve_check (&argv, es, 0, "ERROR: Windows route add command failed");
       netcmd_semaphore_release ();
     }
   else if ((flags & ROUTE_METHOD_MASK) == ROUTE_METHOD_ADAPTIVE)
@@ -826,7 +846,7 @@
 	{
 	  msg (D_ROUTE, "Route addition fallback to route.exe");
 	  netcmd_semaphore_lock ();
-	  status = system_check (BSTR (&buf), es, 0, "ERROR: Windows route add command failed [adaptive]");
+	  status = openvpn_execve_check (&argv, es, 0, "ERROR: Windows route add command failed [adaptive]");
 	  netcmd_semaphore_release ();
 	}
     }
@@ -839,71 +859,93 @@
 
   /* example: route add 192.0.2.32 -netmask 255.255.255.224 somegateway */
 
-  buf_printf (&buf, ROUTE_PATH " add");
+  argv_printf (&argv, "%s add",
+		ROUTE_PATH);
 
 #if 0
   if (r->metric_defined)
-    buf_printf (&buf, " -rtt %d", r->metric);
+    argv_printf_cat (&argv, "-rtt %d", r->metric);
 #endif
 
-  buf_printf (&buf, " %s -netmask %s %s",
+  argv_printf_cat (&argv, "%s -netmask %s %s",
 	      network,
 	      netmask,
 	      gateway);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  status = system_check (BSTR (&buf), es, 0, "ERROR: Solaris route add command failed");
+  argv_msg (D_ROUTE, &argv);
+  status = openvpn_execve_check (&argv, es, 0, "ERROR: Solaris route add command failed");
 
 #elif defined(TARGET_FREEBSD)
 
-  buf_printf (&buf, ROUTE_PATH " add");
+  argv_printf (&argv, "%s add",
+		ROUTE_PATH);
+
+#if 0
+  if (r->metric_defined)
+    argv_printf_cat (&argv, "-rtt %d", r->metric);
+#endif
+
+  argv_printf_cat (&argv, "-net %s %s %s",
+	      network,
+	      gateway,
+	      netmask);
+
+  argv_msg (D_ROUTE, &argv);
+  status = openvpn_execve_check (&argv, es, 0, "ERROR: FreeBSD route add command failed");
+
+#elif defined(TARGET_DRAGONFLY)
+
+  argv_printf (&argv, "%s add",
+		ROUTE_PATH);
 
 #if 0
   if (r->metric_defined)
-    buf_printf (&buf, " -rtt %d", r->metric);
+    argv_printf_cat (&argv, "-rtt %d", r->metric);
 #endif
 
-  buf_printf (&buf, " -net %s %s %s",
+  argv_printf_cat (&argv, "-net %s %s %s",
 	      network,
 	      gateway,
 	      netmask);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  status = system_check (BSTR (&buf), es, 0, "ERROR: FreeBSD route add command failed");
+  argv_msg (D_ROUTE, &argv);
+  status = openvpn_execve_check (&argv, es, 0, "ERROR: DragonFly route add command failed");
 
 #elif defined(TARGET_DARWIN)
 
-  buf_printf (&buf, ROUTE_PATH " add");
+  argv_printf (&argv, "%s add",
+		ROUTE_PATH);
 
 #if 0
   if (r->metric_defined)
-    buf_printf (&buf, " -rtt %d", r->metric);
+    argv_printf_cat (&argv, "-rtt %d", r->metric);
 #endif
 
-  buf_printf (&buf, " -net %s %s %s",
+  argv_printf_cat (&argv, "-net %s %s %s",
               network,
               gateway,
               netmask);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  status = system_check (BSTR (&buf), es, 0, "ERROR: OS X route add command failed");
+  argv_msg (D_ROUTE, &argv);
+  status = openvpn_execve_check (&argv, es, 0, "ERROR: OS X route add command failed");
 
 #elif defined(TARGET_OPENBSD) || defined(TARGET_NETBSD)
 
-  buf_printf (&buf, ROUTE_PATH " add");
+  argv_printf (&argv, "%s add",
+		ROUTE_PATH);
 
 #if 0
   if (r->metric_defined)
-    buf_printf (&buf, " -rtt %d", r->metric);
+    argv_printf_cat (&argv, "-rtt %d", r->metric);
 #endif
 
-  buf_printf (&buf, " -net %s %s -netmask %s",
+  argv_printf_cat (&argv, "-net %s %s -netmask %s",
 	      network,
 	      gateway,
 	      netmask);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  status = system_check (BSTR (&buf), es, 0, "ERROR: OpenBSD/NetBSD route add command failed");
+  argv_msg (D_ROUTE, &argv);
+  status = openvpn_execve_check (&argv, es, 0, "ERROR: OpenBSD/NetBSD route add command failed");
 
 #else
   msg (M_FATAL, "Sorry, but I don't know how to do 'route' commands on this operating system.  Try putting your routes in a --route-up script");
@@ -911,6 +953,7 @@
 
  done:
   r->defined = status;
+  argv_reset (&argv);
   gc_free (&gc);
 }
 
@@ -918,7 +961,7 @@
 delete_route (const struct route *r, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
 {
   struct gc_arena gc;
-  struct buffer buf;
+  struct argv argv;
   const char *network;
   const char *netmask;
   const char *gateway;
@@ -927,37 +970,40 @@
     return;
 
   gc_init (&gc);
+  argv_init (&argv);
 
-  buf = alloc_buf_gc (256, &gc);
   network = print_in_addr_t (r->network, 0, &gc);
   netmask = print_in_addr_t (r->netmask, 0, &gc);
   gateway = print_in_addr_t (r->gateway, 0, &gc);
 
 #if defined(TARGET_LINUX)
 #ifdef CONFIG_FEATURE_IPROUTE
-  buf_printf (&buf, "%s route del %s/%d",
+  argv_printf (&argv, "%s route del %s/%d",
   	      iproute_path,
 	      network,
 	      count_netmask_bits(netmask));
 #else
 
-  buf_printf (&buf, ROUTE_PATH " del -net %s netmask %s",
+  argv_printf (&argv, "%s del -net %s netmask %s",
+		ROUTE_PATH,
 	      network,
 	      netmask);
 #endif /*CONFIG_FEATURE_IPROUTE*/
   if (r->metric_defined)
-    buf_printf (&buf, " metric %d", r->metric);
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  system_check (BSTR (&buf), es, 0, "ERROR: Linux route delete command failed");
+    argv_printf_cat (&argv, "metric %d", r->metric);
+  argv_msg (D_ROUTE, &argv);
+  openvpn_execve_check (&argv, es, 0, "ERROR: Linux route delete command failed");
 
 #elif defined (WIN32)
   
-  buf_printf (&buf, ROUTE_PATH " DELETE %s MASK %s %s",
-	      network,
-              netmask,
-              gateway);
+  argv_printf (&argv, "%s%s DELETE %s MASK %s %s",
+	       get_win_sys_path(),
+	       WIN_ROUTE_PATH_SUFFIX,
+	       network,
+	       netmask,
+	       gateway);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
+  argv_msg (D_ROUTE, &argv);
 
   if ((flags & ROUTE_METHOD_MASK) == ROUTE_METHOD_IPAPI)
     {
@@ -967,7 +1013,7 @@
   else if ((flags & ROUTE_METHOD_MASK) == ROUTE_METHOD_EXE)
     {
       netcmd_semaphore_lock ();
-      system_check (BSTR (&buf), es, 0, "ERROR: Windows route delete command failed");
+      openvpn_execve_check (&argv, es, 0, "ERROR: Windows route delete command failed");
       netcmd_semaphore_release ();
     }
   else if ((flags & ROUTE_METHOD_MASK) == ROUTE_METHOD_ADAPTIVE)
@@ -978,7 +1024,7 @@
 	{
 	  msg (D_ROUTE, "Route deletion fallback to route.exe");
 	  netcmd_semaphore_lock ();
-	  system_check (BSTR (&buf), es, 0, "ERROR: Windows route delete command failed [adaptive]");
+	  openvpn_execve_check (&argv, es, 0, "ERROR: Windows route delete command failed [adaptive]");
 	  netcmd_semaphore_release ();
 	}
     }
@@ -989,48 +1035,64 @@
 
 #elif defined (TARGET_SOLARIS)
 
-  buf_printf (&buf, ROUTE_PATH " delete %s -netmask %s %s",
+  argv_printf (&argv, "%s delete %s -netmask %s %s",
+		ROUTE_PATH,
 	      network,
 	      netmask,
 	      gateway);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  system_check (BSTR (&buf), es, 0, "ERROR: Solaris route delete command failed");
+  argv_msg (D_ROUTE, &argv);
+  openvpn_execve_check (&argv, es, 0, "ERROR: Solaris route delete command failed");
 
 #elif defined(TARGET_FREEBSD)
 
-  buf_printf (&buf, ROUTE_PATH " delete -net %s %s %s",
+  argv_printf (&argv, "%s delete -net %s %s %s",
+		ROUTE_PATH,
 	      network,
 	      gateway,
 	      netmask);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  system_check (BSTR (&buf), es, 0, "ERROR: FreeBSD route delete command failed");
+  argv_msg (D_ROUTE, &argv);
+  openvpn_execve_check (&argv, es, 0, "ERROR: FreeBSD route delete command failed");
+
+#elif defined(TARGET_DRAGONFLY)
+
+  argv_printf (&argv, "%s delete -net %s %s %s",
+		ROUTE_PATH,
+	      network,
+	      gateway,
+	      netmask);
+
+  argv_msg (D_ROUTE, &argv);
+  openvpn_execve_check (&argv, es, 0, "ERROR: DragonFly route delete command failed");
 
 #elif defined(TARGET_DARWIN)
 
-  buf_printf (&buf, ROUTE_PATH " delete -net %s %s %s",
+  argv_printf (&argv, "%s delete -net %s %s %s",
+		ROUTE_PATH,
               network,
               gateway,
               netmask);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  system_check (BSTR (&buf), es, 0, "ERROR: OS X route delete command failed");
+  argv_msg (D_ROUTE, &argv);
+  openvpn_execve_check (&argv, es, 0, "ERROR: OS X route delete command failed");
 
 #elif defined(TARGET_OPENBSD) || defined(TARGET_NETBSD)
 
-  buf_printf (&buf, ROUTE_PATH " delete -net %s %s -netmask %s",
+  argv_printf (&argv, "%s delete -net %s %s -netmask %s",
+		ROUTE_PATH,
 	      network,
 	      gateway,
 	      netmask);
 
-  msg (D_ROUTE, "%s", BSTR (&buf));
-  system_check (BSTR (&buf), es, 0, "ERROR: OpenBSD/NetBSD route delete command failed");
+  argv_msg (D_ROUTE, &argv);
+  openvpn_execve_check (&argv, es, 0, "ERROR: OpenBSD/NetBSD route delete command failed");
 
 #else
   msg (M_FATAL, "Sorry, but I don't know how to do 'route' commands on this operating system.  Try putting your routes in a --route-up script");
 #endif
 
+  argv_reset (&argv);
   gc_free (&gc);
 }
 
@@ -1462,7 +1524,7 @@
   return ret;
 }
 
-#elif defined(TARGET_FREEBSD)
+#elif defined(TARGET_FREEBSD)||defined(TARGET_DRAGONFLY)
 
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -2001,7 +2063,7 @@
 get_bypass_addresses (struct route_bypass *rb, const unsigned int flags)
 {
   struct gc_arena gc = gc_new ();
-  bool ret_bool = false;
+  /*bool ret_bool = false;*/
 
   /* get full routing table */
   const MIB_IPFORWARDTABLE *routes = get_windows_routing_table (&gc);
diff -urN openvpn-2.1_rc7/route.h openvpn-2.1_rc9/route.h
--- openvpn-2.1_rc7/route.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/route.h	2008-07-27 00:04:01.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -150,6 +150,8 @@
 
 void setenv_routes (struct env_set *es, const struct route_list *rl);
 
+bool is_special_addr (const char *addr_str);
+
 #if AUTO_USERID
 bool get_default_gateway_mac_addr (unsigned char *macaddr);
 #endif
diff -urN openvpn-2.1_rc7/schedule.c openvpn-2.1_rc9/schedule.c
--- openvpn-2.1_rc7/schedule.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/schedule.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #if P2MP_SERVER
diff -urN openvpn-2.1_rc7/schedule.h openvpn-2.1_rc9/schedule.h
--- openvpn-2.1_rc7/schedule.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/schedule.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/service-win32/Makefile openvpn-2.1_rc9/service-win32/Makefile
--- openvpn-2.1_rc7/service-win32/Makefile	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/service-win32/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-# This makefile builds the OpenVPN win32 service
-# wrapper using the mingw environment.
-#
-# service.c and service.h should be generated by
-# applying service.patch to the Platform
-# SDK service sample.
-
-EXE = ${PRODUCT_UNIX_NAME}serv.exe
-
-HEADERS = service.h
-
-OBJS =	openvpnserv.o service.o
-
-INCLUDE_DIRS =
-
-CC = gcc -g -O2 -Wall -Wno-unused-function -Wno-unused-variable -mno-cygwin
-
-all : ${OBJS}
-	${CC} -o ${EXE} ${OBJS}
-
-clean :
-	rm -f ${OBJS} ${EXE}
-
-%.o : %.c ${HEADERS}
-	${CC} ${INCLUDE_DIRS} -c $< -o $@
diff -urN openvpn-2.1_rc7/service-win32/Makefile.am openvpn-2.1_rc9/service-win32/Makefile.am
--- openvpn-2.1_rc7/service-win32/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/service-win32/Makefile.am	2008-07-14 20:49:16.000000000 +0200
@@ -0,0 +1,41 @@
+#
+#  OpenVPN -- An application to securely tunnel IP networks
+#             over a single UDP port, with support for SSL/TLS-based
+#             session authentication and key exchange,
+#             packet encryption, packet authentication, and
+#             packet compression.
+#
+#  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License version 2
+#  as published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program (see the file COPYING included with this
+#  distribution); if not, write to the Free Software Foundation, Inc.,
+#  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+
+if WIN32
+
+sbin_PROGRAMS = openvpnserv
+
+openvpnserv_SOURCES = \
+	openvpnserv.c \
+	service.h service.c
+
+else
+
+dist_noinst_DATA = \
+	openvpnserv.c \
+	service.h service.c
+
+endif
diff -urN openvpn-2.1_rc7/service-win32/Makefile.in openvpn-2.1_rc9/service-win32/Makefile.in
--- openvpn-2.1_rc7/service-win32/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/service-win32/Makefile.in	2008-07-31 19:45:21.000000000 +0200
@@ -0,0 +1,464 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#
+#  OpenVPN -- An application to securely tunnel IP networks
+#             over a single UDP port, with support for SSL/TLS-based
+#             session authentication and key exchange,
+#             packet encryption, packet authentication, and
+#             packet compression.
+#
+#  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License version 2
+#  as published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program (see the file COPYING included with this
+#  distribution); if not, write to the Free Software Foundation, Inc.,
+#  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+@WIN32_TRUE@sbin_PROGRAMS = openvpnserv$(EXEEXT)
+subdir = service-win32
+DIST_COMMON = $(am__dist_noinst_DATA_DIST) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/version.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+am__installdirs = "$(DESTDIR)$(sbindir)"
+sbinPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(sbin_PROGRAMS)
+am__openvpnserv_SOURCES_DIST = openvpnserv.c service.h service.c
+@WIN32_TRUE@am_openvpnserv_OBJECTS = openvpnserv.$(OBJEXT) \
+@WIN32_TRUE@	service.$(OBJEXT)
+openvpnserv_OBJECTS = $(am_openvpnserv_OBJECTS)
+openvpnserv_LDADD = $(LDADD)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(openvpnserv_SOURCES)
+DIST_SOURCES = $(am__openvpnserv_SOURCES_DIST)
+am__dist_noinst_DATA_DIST = openvpnserv.c service.h service.c
+DATA = $(dist_noinst_DATA)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+GREP = @GREP@
+IFCONFIG = @IFCONFIG@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+IPROUTE = @IPROUTE@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MAN2HTML = @MAN2HTML@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PTHREAD_CC = @PTHREAD_CC@
+PTHREAD_CFLAGS = @PTHREAD_CFLAGS@
+PTHREAD_LIBS = @PTHREAD_LIBS@
+ROUTE = @ROUTE@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+TAP_ID = @TAP_ID@
+TAP_WIN32_MIN_MAJOR = @TAP_WIN32_MIN_MAJOR@
+TAP_WIN32_MIN_MINOR = @TAP_WIN32_MIN_MINOR@
+VERSION = @VERSION@
+WIN32_FALSE = @WIN32_FALSE@
+WIN32_TRUE = @WIN32_TRUE@
+ac_ct_CC = @ac_ct_CC@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+win32datadir = @win32datadir@
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+@WIN32_TRUE@openvpnserv_SOURCES = \
+@WIN32_TRUE@	openvpnserv.c \
+@WIN32_TRUE@	service.h service.c
+
+@WIN32_FALSE@dist_noinst_DATA = \
+@WIN32_FALSE@	openvpnserv.c \
+@WIN32_FALSE@	service.h service.c
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  service-win32/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  service-win32/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-sbinPROGRAMS: $(sbin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(sbindir)" || $(mkdir_p) "$(DESTDIR)$(sbindir)"
+	@list='$(sbin_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(sbinPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(sbindir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(sbinPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(sbindir)/$$f" || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-sbinPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(sbin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f '$(DESTDIR)$(sbindir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(sbindir)/$$f"; \
+	done
+
+clean-sbinPROGRAMS:
+	-test -z "$(sbin_PROGRAMS)" || rm -f $(sbin_PROGRAMS)
+openvpnserv$(EXEEXT): $(openvpnserv_OBJECTS) $(openvpnserv_DEPENDENCIES) 
+	@rm -f openvpnserv$(EXEEXT)
+	$(LINK) $(openvpnserv_LDFLAGS) $(openvpnserv_OBJECTS) $(openvpnserv_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openvpnserv.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/service.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS) $(DATA)
+installdirs:
+	for dir in "$(DESTDIR)$(sbindir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+clean: clean-am
+
+clean-am: clean-generic clean-sbinPROGRAMS mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-sbinPROGRAMS
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-sbinPROGRAMS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-sbinPROGRAMS ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-sbinPROGRAMS install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am uninstall-sbinPROGRAMS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN openvpn-2.1_rc7/service-win32/mkpatch openvpn-2.1_rc9/service-win32/mkpatch
--- openvpn-2.1_rc7/service-win32/mkpatch	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/service-win32/mkpatch	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-# build service.[ch] patch against original
-# SDK sample
-diff -ub service.c.orig service.c | u2d >service.patch
-diff -ub service.h.orig service.h | u2d >>service.patch
diff -urN openvpn-2.1_rc7/service-win32/openvpnserv.c openvpn-2.1_rc9/service-win32/openvpnserv.c
--- openvpn-2.1_rc7/service-win32/openvpnserv.c	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/service-win32/openvpnserv.c	2008-07-14 20:49:16.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -33,6 +33,11 @@
  * This code is designed to be built with the mingw compiler.
  */
 
+#ifdef _MSC_VER
+#include "config-win32.h"
+#else
+#include "config.h"
+#endif
 #include <windows.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -65,13 +70,13 @@
  * Control Manager which will cause an asynchronous call
  * of ServiceStop below.
  */
-#define EXIT_EVENT_NAME PRODUCT_UNIX_NAME "_exit_1"
+#define EXIT_EVENT_NAME PACKAGE "_exit_1"
 
 /*
  * Which registry key in HKLM should
  * we get config info from?
  */
-#define REG_KEY "SOFTWARE\\" PRODUCT_NAME
+#define REG_KEY "SOFTWARE\\" PACKAGE_NAME
 
 static HANDLE exit_event = NULL;
 
@@ -398,7 +403,7 @@
 	  mysnprintf (log_path, "%s\\%s", log_dir, log_file);
 
 	  /* construct command line */
-	  mysnprintf (command_line, PRODUCT_UNIX_NAME " --service %s 1 --config \"%s\"",
+	  mysnprintf (command_line, PACKAGE " --service %s 1 --config \"%s\"",
 		      EXIT_EVENT_NAME,
 		      find_obj.cFileName);
 
@@ -406,7 +411,7 @@
 	     be inherited. */
 	  if (!init_security_attributes_allow_all (&sa))
 	    {
-	      MSG (M_SYSERR, "InitializeSecurityDescriptor start_" PRODUCT_UNIX_NAME " failed");
+	      MSG (M_SYSERR, "InitializeSecurityDescriptor start_" PACKAGE " failed");
 	      goto finish;
 	    }
 
diff -urN openvpn-2.1_rc7/service-win32/service.c openvpn-2.1_rc9/service-win32/service.c
--- openvpn-2.1_rc7/service-win32/service.c	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/service-win32/service.c	2008-06-13 09:54:58.000000000 +0200
@@ -0,0 +1,693 @@
+/*---------------------------------------------------------------------------
+THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
+ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
+PARTICULAR PURPOSE.
+
+Copyright (C) 1993 - 2000.  Microsoft Corporation.  All rights reserved.
+
+MODULE:   service.c
+
+PURPOSE:  Implements functions required by all Windows NT services
+
+FUNCTIONS:
+  main(int argc, char **argv);
+  service_ctrl(DWORD dwCtrlCode);
+  service_main(DWORD dwArgc, LPTSTR *lpszArgv);
+  CmdInstallService();
+  CmdRemoveService();
+  CmdStartService();
+  CmdDebugService(int argc, char **argv);
+  ControlHandler ( DWORD dwCtrlType );
+  GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
+
+---------------------------------------------------------------------------*/
+
+#include <windows.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <process.h>
+#include <tchar.h>
+
+#include "service.h"
+
+// internal variables
+SERVICE_STATUS          ssStatus;       // current status of the service
+SERVICE_STATUS_HANDLE   sshStatusHandle;
+DWORD                   dwErr = 0;
+BOOL                    bDebug = FALSE;
+TCHAR                   szErr[256];
+
+// internal function prototypes
+VOID WINAPI service_ctrl(DWORD dwCtrlCode);
+VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
+int CmdInstallService();
+int CmdRemoveService();
+int CmdStartService();
+VOID CmdDebugService(int argc, char **argv);
+BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
+LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
+
+//
+//  FUNCTION: main
+//
+//  PURPOSE: entrypoint for service
+//
+//  PARAMETERS:
+//    argc - number of command line arguments
+//    argv - array of command line arguments
+//
+//  RETURN VALUE:
+//    none
+//
+//  COMMENTS:
+//    main() either performs the command line task, or
+//    call StartServiceCtrlDispatcher to register the
+//    main service thread.  When the this call returns,
+//    the service has stopped, so exit.
+//
+int __cdecl main(int argc, char **argv)
+{
+   SERVICE_TABLE_ENTRY dispatchTable[] =
+   {
+      { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main},
+      { NULL, NULL}
+   };
+
+   if ( (argc > 1) &&
+        ((*argv[1] == '-') || (*argv[1] == '/')) )
+   {
+      if ( _stricmp( "install", argv[1]+1 ) == 0 )
+      {
+         return CmdInstallService();
+      }
+      else if ( _stricmp( "remove", argv[1]+1 ) == 0 )
+      {
+         return CmdRemoveService();
+      }
+	  else if ( _stricmp( "start", argv[1]+1 ) == 0)
+	  {
+		  return CmdStartService();
+      }
+      else if ( _stricmp( "debug", argv[1]+1 ) == 0 )
+      {
+         bDebug = TRUE;
+         CmdDebugService(argc, argv);
+      }
+      else
+      {
+         goto dispatch;
+      }
+      return 0;
+   }
+
+   // if it doesn't match any of the above parameters
+   // the service control manager may be starting the service
+   // so we must call StartServiceCtrlDispatcher
+   dispatch:
+   // this is just to be friendly
+   printf( "%s -install          to install the service\n", SZAPPNAME );
+   printf( "%s -start			 to start the service\n", SZAPPNAME );
+   printf( "%s -remove           to remove the service\n", SZAPPNAME );
+   printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
+   printf( "\nStartServiceCtrlDispatcher being called.\n" );
+   printf( "This may take several seconds.  Please wait.\n" );
+
+   if (!StartServiceCtrlDispatcher(dispatchTable))
+      AddToMessageLog(MSG_FLAGS_ERROR, TEXT("StartServiceCtrlDispatcher failed."));
+
+   return 0;
+}
+
+
+
+//
+//  FUNCTION: service_main
+//
+//  PURPOSE: To perform actual initialization of the service
+//
+//  PARAMETERS:
+//    dwArgc   - number of command line arguments
+//    lpszArgv - array of command line arguments
+//
+//  RETURN VALUE:
+//    none
+//
+//  COMMENTS:
+//    This routine performs the service initialization and then calls
+//    the user defined ServiceStart() routine to perform majority
+//    of the work.
+//
+void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
+{
+
+   // register our service control handler:
+   //
+   sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);
+
+   if (!sshStatusHandle)
+      goto cleanup;
+
+   // SERVICE_STATUS members that don't change in example
+   //
+   ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
+   ssStatus.dwServiceSpecificExitCode = 0;
+
+
+   // report the status to the service control manager.
+   //
+   if (!ReportStatusToSCMgr(
+                           SERVICE_START_PENDING, // service state
+                           NO_ERROR,              // exit code
+                           3000))                 // wait hint
+      goto cleanup;
+
+
+   ServiceStart( dwArgc, lpszArgv );
+
+   cleanup:
+
+   // try to report the stopped status to the service control manager.
+   //
+   if (sshStatusHandle)
+      (VOID)ReportStatusToSCMgr(
+                               SERVICE_STOPPED,
+                               dwErr,
+                               0);
+
+   return;
+}
+
+
+
+//
+//  FUNCTION: service_ctrl
+//
+//  PURPOSE: This function is called by the SCM whenever
+//           ControlService() is called on this service.
+//
+//  PARAMETERS:
+//    dwCtrlCode - type of control requested
+//
+//  RETURN VALUE:
+//    none
+//
+//  COMMENTS:
+//
+VOID WINAPI service_ctrl(DWORD dwCtrlCode)
+{
+   // Handle the requested control code.
+   //
+   switch (dwCtrlCode)
+   {
+   // Stop the service.
+   //
+   // SERVICE_STOP_PENDING should be reported before
+   // setting the Stop Event - hServerStopEvent - in
+   // ServiceStop().  This avoids a race condition
+   // which may result in a 1053 - The Service did not respond...
+   // error.
+   case SERVICE_CONTROL_STOP:
+      ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);
+      ServiceStop();
+      return;
+
+      // Update the service status.
+      //
+   case SERVICE_CONTROL_INTERROGATE:
+      break;
+
+      // invalid control code
+      //
+   default:
+      break;
+
+   }
+
+   ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
+}
+
+
+
+//
+//  FUNCTION: ReportStatusToSCMgr()
+//
+//  PURPOSE: Sets the current status of the service and
+//           reports it to the Service Control Manager
+//
+//  PARAMETERS:
+//    dwCurrentState - the state of the service
+//    dwWin32ExitCode - error code to report
+//    dwWaitHint - worst case estimate to next checkpoint
+//
+//  RETURN VALUE:
+//    TRUE  - success
+//    FALSE - failure
+//
+//  COMMENTS:
+//
+BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
+                         DWORD dwWin32ExitCode,
+                         DWORD dwWaitHint)
+{
+   static DWORD dwCheckPoint = 1;
+   BOOL fResult = TRUE;
+
+
+   if ( !bDebug ) // when debugging we don't report to the SCM
+   {
+      if (dwCurrentState == SERVICE_START_PENDING)
+         ssStatus.dwControlsAccepted = 0;
+      else
+         ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
+
+      ssStatus.dwCurrentState = dwCurrentState;
+      ssStatus.dwWin32ExitCode = dwWin32ExitCode;
+      ssStatus.dwWaitHint = dwWaitHint;
+
+      if ( ( dwCurrentState == SERVICE_RUNNING ) ||
+           ( dwCurrentState == SERVICE_STOPPED ) )
+         ssStatus.dwCheckPoint = 0;
+      else
+         ssStatus.dwCheckPoint = dwCheckPoint++;
+
+
+      // Report the status of the service to the service control manager.
+      //
+      if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus)))
+      {
+         AddToMessageLog(MSG_FLAGS_ERROR, TEXT("SetServiceStatus"));
+      }
+   }
+   return fResult;
+}
+
+
+
+//
+//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
+//
+//  PURPOSE: Allows any thread to log an error message
+//
+//  PARAMETERS:
+//    lpszMsg - text for message
+//
+//  RETURN VALUE:
+//    none
+//
+//  COMMENTS:
+//
+void AddToMessageLog(DWORD flags, LPTSTR lpszMsg)
+{
+   TCHAR szMsg [(sizeof(SZSERVICENAME) / sizeof(TCHAR)) + 100 ];
+   HANDLE  hEventSource;
+   LPCSTR  lpszStrings[2];
+
+   if ( !bDebug )
+   {
+     if (flags & MSG_FLAGS_SYS_CODE)
+      dwErr = GetLastError();
+     else
+       dwErr = 0;
+
+      // Use event logging to log the error.
+      //
+      hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));
+
+      _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), (int)dwErr);
+      lpszStrings[0] = szMsg;
+      lpszStrings[1] = lpszMsg;
+
+      if (hEventSource != NULL)
+      {
+         ReportEvent(hEventSource, // handle of event source
+		     // event type
+                     (flags & MSG_FLAGS_ERROR)
+		       ? EVENTLOG_ERROR_TYPE : EVENTLOG_INFORMATION_TYPE,
+                     0,                    // event category
+                     0,                    // event ID
+                     NULL,                 // current user's SID
+                     2,                    // strings in lpszStrings
+                     0,                    // no bytes of raw data
+                     lpszStrings,          // array of error strings
+                     NULL);                // no raw data
+
+         (VOID) DeregisterEventSource(hEventSource);
+      }
+   }
+}
+
+void ResetError (void)
+{
+  dwErr = 0;
+}
+
+///////////////////////////////////////////////////////////////////
+//
+//  The following code handles service installation and removal
+//
+
+
+//
+//  FUNCTION: CmdInstallService()
+//
+//  PURPOSE: Installs the service
+//
+//  PARAMETERS:
+//    none
+//
+//  RETURN VALUE:
+//    0 if success
+//
+//  COMMENTS:
+//
+int CmdInstallService()
+{
+   SC_HANDLE   schService;
+   SC_HANDLE   schSCManager;
+
+   TCHAR szPath[512];
+
+   int ret = 0;
+
+   if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
+   {
+      _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
+      return 1;
+   }
+
+   schSCManager = OpenSCManager(
+                               NULL,                   // machine (NULL == local)
+                               NULL,                   // database (NULL == default)
+                               SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE  // access required
+                               );
+   if ( schSCManager )
+   {
+      schService = CreateService(
+                                schSCManager,               // SCManager database
+                                TEXT(SZSERVICENAME),        // name of service
+                                TEXT(SZSERVICEDISPLAYNAME), // name to display
+                                SERVICE_QUERY_STATUS,         // desired access
+                                SERVICE_WIN32_OWN_PROCESS,  // service type
+				SERVICE_DEMAND_START,        // start type -- alternative: SERVICE_AUTO_START
+                                SERVICE_ERROR_NORMAL,       // error control type
+                                szPath,                     // service's binary
+                                NULL,                       // no load ordering group
+                                NULL,                       // no tag identifier
+                                TEXT(SZDEPENDENCIES),       // dependencies
+                                NULL,                       // LocalSystem account
+                                NULL);                      // no password
+
+      if ( schService )
+      {
+         _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
+         CloseServiceHandle(schService);
+      }
+      else
+      {
+         _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
+	 ret = 1;
+      }
+
+      CloseServiceHandle(schSCManager);
+   }
+   else
+     {
+      _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
+       ret = 1;
+     }
+   return ret;
+}
+
+//
+//  FUNCTION: CmdStartService()
+//
+//  PURPOSE: Start the service
+//
+//  PARAMETERS:
+//    none
+//
+//  RETURN VALUE:
+//    0 if success
+//
+//  COMMENTS:
+
+int CmdStartService()
+{
+  int ret = 0;
+
+  SC_HANDLE schSCManager;
+  SC_HANDLE schService;
+
+
+    // Open a handle to the SC Manager database. 
+    schSCManager = OpenSCManager( 
+       NULL,                    // local machine 
+       NULL,                    // ServicesActive database 
+       SC_MANAGER_ALL_ACCESS);  // full access rights 
+   
+    if (NULL == schSCManager) {
+       _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
+       ret = 1;
+    }
+
+    schService = OpenService( 
+        schSCManager,          // SCM database 
+        SZSERVICENAME,         // service name
+        SERVICE_ALL_ACCESS); 
+
+    if (schService == NULL) {
+      _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
+       ret = 1;
+    }
+ 
+    if (!StartService(
+            schService,  // handle to service 
+            0,           // number of arguments 
+            NULL) )      // no arguments 
+    {
+      _tprintf(TEXT("StartService failed - %s\n"), GetLastErrorText(szErr,256));
+       ret = 1;
+    }
+    else
+	{
+		_tprintf(TEXT("Service Started\n"));
+       ret = 0;
+	}
+    CloseServiceHandle(schService); 
+    CloseServiceHandle(schSCManager);
+    return ret;
+}
+
+//
+//  FUNCTION: CmdRemoveService()
+//
+//  PURPOSE: Stops and removes the service
+//
+//  PARAMETERS:
+//    none
+//
+//  RETURN VALUE:
+//    0 if success
+//
+//  COMMENTS:
+//
+int CmdRemoveService()
+{
+   SC_HANDLE   schService;
+   SC_HANDLE   schSCManager;
+
+   int ret = 0;
+
+   schSCManager = OpenSCManager(
+                               NULL,                   // machine (NULL == local)
+                               NULL,                   // database (NULL == default)
+                               SC_MANAGER_CONNECT   // access required
+                               );
+   if ( schSCManager )
+   {
+      schService = OpenService(schSCManager, TEXT(SZSERVICENAME), DELETE | SERVICE_STOP | SERVICE_QUERY_STATUS);
+
+      if (schService)
+      {
+         // try to stop the service
+         if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
+         {
+            _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
+            Sleep( 1000 );
+
+            while ( QueryServiceStatus( schService, &ssStatus ) )
+            {
+               if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
+               {
+                  _tprintf(TEXT("."));
+                  Sleep( 1000 );
+               }
+               else
+                  break;
+            }
+
+            if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
+               _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );
+            else
+	      {
+               _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );
+		ret = 1;
+	      }
+
+         }
+
+         // now remove the service
+         if ( DeleteService(schService) )
+            _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
+         else
+	   {
+            _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));
+	     ret = 1;
+	   }
+
+
+         CloseServiceHandle(schService);
+      }
+      else
+	{
+         _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
+	  ret = 1;
+	}
+
+      CloseServiceHandle(schSCManager);
+   }
+   else
+     {
+      _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
+       ret = 1;
+     }
+   return ret;
+}
+
+
+
+
+///////////////////////////////////////////////////////////////////
+//
+//  The following code is for running the service as a console app
+//
+
+
+//
+//  FUNCTION: CmdDebugService(int argc, char ** argv)
+//
+//  PURPOSE: Runs the service as a console application
+//
+//  PARAMETERS:
+//    argc - number of command line arguments
+//    argv - array of command line arguments
+//
+//  RETURN VALUE:
+//    none
+//
+//  COMMENTS:
+//
+void CmdDebugService(int argc, char ** argv)
+{
+   DWORD dwArgc;
+   LPTSTR *lpszArgv;
+
+#ifdef UNICODE
+   lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
+   if (NULL == lpszArgv)
+   {
+       // CommandLineToArvW failed!!
+       _tprintf(TEXT("CmdDebugService CommandLineToArgvW returned NULL\n"));
+       return;
+   }
+#else
+   dwArgc   = (DWORD) argc;
+   lpszArgv = argv;
+#endif
+
+   _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
+
+   SetConsoleCtrlHandler( ControlHandler, TRUE );
+
+   ServiceStart( dwArgc, lpszArgv );
+
+#ifdef UNICODE
+// Must free memory allocated for arguments
+
+   GlobalFree(lpszArgv);
+#endif // UNICODE
+
+}
+
+
+//
+//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
+//
+//  PURPOSE: Handled console control events
+//
+//  PARAMETERS:
+//    dwCtrlType - type of control event
+//
+//  RETURN VALUE:
+//    True - handled
+//    False - unhandled
+//
+//  COMMENTS:
+//
+BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
+{
+   switch ( dwCtrlType )
+   {
+   case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
+   case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
+      _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
+      ServiceStop();
+      return TRUE;
+      break;
+
+   }
+   return FALSE;
+}
+
+//
+//  FUNCTION: GetLastErrorText
+//
+//  PURPOSE: copies error message text to string
+//
+//  PARAMETERS:
+//    lpszBuf - destination buffer
+//    dwSize - size of buffer
+//
+//  RETURN VALUE:
+//    destination buffer
+//
+//  COMMENTS:
+//
+LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
+{
+   DWORD dwRet;
+   LPTSTR lpszTemp = NULL;
+
+   dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
+                          NULL,
+                          GetLastError(),
+                          LANG_NEUTRAL,
+                          (LPTSTR)&lpszTemp,
+                          0,
+                          NULL );
+
+   // supplied buffer is not long enough
+   if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
+      lpszBuf[0] = TEXT('\0');
+   else
+   {
+      lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
+      _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, (int)GetLastError() );
+   }
+
+   if ( lpszTemp )
+      LocalFree((HLOCAL) lpszTemp );
+
+   return lpszBuf;
+}
diff -urN openvpn-2.1_rc7/service-win32/service.h openvpn-2.1_rc9/service-win32/service.h
--- openvpn-2.1_rc7/service-win32/service.h	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1_rc9/service-win32/service.h	2008-06-13 09:54:58.000000000 +0200
@@ -0,0 +1,141 @@
+/*---------------------------------------------------------------------------
+THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
+ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
+PARTICULAR PURPOSE.
+
+Copyright (C) 1993 - 2000.  Microsoft Corporation.  All rights reserved.
+
+ MODULE: service.h
+
+ Comments:  The use of this header file and the accompanying service.c
+ file simplifies the process of writting a service.  You as a developer
+ simply need to follow the TODO's outlined in this header file, and
+ implement the ServiceStart() and ServiceStop() functions.
+
+ There is no need to modify the code in service.c.  Just add service.c
+ to your project and link with the following libraries...
+
+ libcmt.lib kernel32.lib advapi.lib shell32.lib
+
+ This code also supports unicode.  Be sure to compile both service.c and
+ and code #include "service.h" with the same Unicode setting.
+
+ Upon completion, your code will have the following command line interface
+
+ <service exe> -?                to display this list
+ <service exe> -install          to install the service
+ <service exe> -remove           to remove the service
+ <service exe> -debug <params>   to run as a console app for debugging
+
+ Note: This code also implements Ctrl+C and Ctrl+Break handlers
+       when using the debug option.  These console events cause
+       your ServiceStop routine to be called
+
+       Also, this code only handles the OWN_SERVICE service type
+       running in the LOCAL_SYSTEM security context.
+
+       To control your service ( start, stop, etc ) you may use the
+       Services control panel applet or the NET.EXE program.
+
+       To aid in writing/debugging service, the
+       SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
+       can be used to control, configure, or obtain service status.
+       SC displays complete status for any service/driver
+       in the service database, and allows any of the configuration
+       parameters to be easily changed at the command line.
+       For more information on SC.EXE, type SC at the command line.
+
+
+------------------------------------------------------------------------------*/
+
+#ifndef _SERVICE_H
+#define _SERVICE_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "config.h"
+
+//////////////////////////////////////////////////////////////////////////////
+//// todo: change to desired strings
+////
+// name of the executable
+#define SZAPPNAME            PACKAGE "serv"
+// internal name of the service
+#define SZSERVICENAME        PACKAGE_NAME "Service"
+// displayed name of the service
+#define SZSERVICEDISPLAYNAME PACKAGE_NAME " Service"
+// list of service dependencies - "dep1\0dep2\0\0"
+#define SZDEPENDENCIES       TAP_ID "\0Dhcp\0\0"
+//////////////////////////////////////////////////////////////////////////////
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//// todo: ServiceStart()must be defined by in your code.
+////       The service should use ReportStatusToSCMgr to indicate
+////       progress.  This routine must also be used by StartService()
+////       to report to the SCM when the service is running.
+////
+////       If a ServiceStop procedure is going to take longer than
+////       3 seconds to execute, it should spawn a thread to
+////       execute the stop code, and return.  Otherwise, the
+////       ServiceControlManager will believe that the service has
+////       stopped responding
+////
+   VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
+   VOID ServiceStop();
+//////////////////////////////////////////////////////////////////////////////
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//// The following are procedures which
+//// may be useful to call within the above procedures,
+//// but require no implementation by the user.
+//// They are implemented in service.c
+
+//
+//  FUNCTION: ReportStatusToSCMgr()
+//
+//  PURPOSE: Sets the current status of the service and
+//           reports it to the Service Control Manager
+//
+//  PARAMETERS:
+//    dwCurrentState - the state of the service
+//    dwWin32ExitCode - error code to report
+//    dwWaitHint - worst case estimate to next checkpoint
+//
+//  RETURN VALUE:
+//    TRUE  - success
+//    FALSE - failure
+//
+   BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);
+
+
+//
+//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
+//
+//  PURPOSE: Allows any thread to log an error message
+//
+//  PARAMETERS:
+//    lpszMsg - text for message
+//
+//  RETURN VALUE:
+//    none
+//
+#  define MSG_FLAGS_ERROR     (1<<0)
+#  define MSG_FLAGS_SYS_CODE  (1<<1)
+   void AddToMessageLog(DWORD flags, LPTSTR lpszMsg);
+   void ResetError (void);
+//////////////////////////////////////////////////////////////////////////////
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -urN openvpn-2.1_rc7/service-win32/service.patch openvpn-2.1_rc9/service-win32/service.patch
--- openvpn-2.1_rc7/service-win32/service.patch	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/service-win32/service.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,359 +0,0 @@
---- service.c.orig	Tue Apr 24 14:49:30 2007
-+++ service.c	Tue Apr 24 12:20:08 2007
-@@ -16,6 +16,7 @@
-   service_main(DWORD dwArgc, LPTSTR *lpszArgv);
-   CmdInstallService();
-   CmdRemoveService();
-+  CmdStartService();
-   CmdDebugService(int argc, char **argv);
-   ControlHandler ( DWORD dwCtrlType );
-   GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
-@@ -40,8 +41,9 @@
- // internal function prototypes
- VOID WINAPI service_ctrl(DWORD dwCtrlCode);
- VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
--VOID CmdInstallService();
--VOID CmdRemoveService();
-+int CmdInstallService();
-+int CmdRemoveService();
-+int CmdStartService();
- VOID CmdDebugService(int argc, char **argv);
- BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
- LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
-@@ -64,7 +66,7 @@
- //    main service thread.  When the this call returns,
- //    the service has stopped, so exit.
- //
--void __cdecl main(int argc, char **argv)
-+int __cdecl main(int argc, char **argv)
- {
-    SERVICE_TABLE_ENTRY dispatchTable[] =
-    {
-@@ -77,11 +79,15 @@
-    {
-       if ( _stricmp( "install", argv[1]+1 ) == 0 )
-       {
--         CmdInstallService();
-+         return CmdInstallService();
-       }
-       else if ( _stricmp( "remove", argv[1]+1 ) == 0 )
-       {
--         CmdRemoveService();
-+         return CmdRemoveService();
-+      }
-+	  else if ( _stricmp( "start", argv[1]+1 ) == 0)
-+	  {
-+		  return CmdStartService();
-       }
-       else if ( _stricmp( "debug", argv[1]+1 ) == 0 )
-       {
-@@ -92,7 +98,7 @@
-       {
-          goto dispatch;
-       }
--      exit(0);
-+      return 0;
-    }
- 
-    // if it doesn't match any of the above parameters
-@@ -101,13 +107,16 @@
-    dispatch:
-    // this is just to be friendly
-    printf( "%s -install          to install the service\n", SZAPPNAME );
-+   printf( "%s -start			 to start the service\n", SZAPPNAME );
-    printf( "%s -remove           to remove the service\n", SZAPPNAME );
-    printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
-    printf( "\nStartServiceCtrlDispatcher being called.\n" );
-    printf( "This may take several seconds.  Please wait.\n" );
- 
-    if (!StartServiceCtrlDispatcher(dispatchTable))
--      AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed."));
-+      AddToMessageLog(MSG_FLAGS_ERROR, TEXT("StartServiceCtrlDispatcher failed."));
-+
-+   return 0;
- }
- 
- 
-@@ -267,7 +276,7 @@
-       //
-       if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus)))
-       {
--         AddToMessageLog(TEXT("SetServiceStatus"));
-+         AddToMessageLog(MSG_FLAGS_ERROR, TEXT("SetServiceStatus"));
-       }
-    }
-    return fResult;
-@@ -288,28 +297,33 @@
- //
- //  COMMENTS:
- //
--VOID AddToMessageLog(LPTSTR lpszMsg)
-+void AddToMessageLog(DWORD flags, LPTSTR lpszMsg)
- {
-    TCHAR szMsg [(sizeof(SZSERVICENAME) / sizeof(TCHAR)) + 100 ];
-    HANDLE  hEventSource;
--   LPTSTR  lpszStrings[2];
-+   LPCSTR  lpszStrings[2];
- 
-    if ( !bDebug )
-    {
-+     if (flags & MSG_FLAGS_SYS_CODE)
-       dwErr = GetLastError();
-+     else
-+       dwErr = 0;
- 
-       // Use event logging to log the error.
-       //
-       hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));
- 
--      _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);
-+      _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), (int)dwErr);
-       lpszStrings[0] = szMsg;
-       lpszStrings[1] = lpszMsg;
- 
-       if (hEventSource != NULL)
-       {
-          ReportEvent(hEventSource, // handle of event source
--                     EVENTLOG_ERROR_TYPE,  // event type
-+		     // event type
-+                     (flags & MSG_FLAGS_ERROR)
-+		       ? EVENTLOG_ERROR_TYPE : EVENTLOG_INFORMATION_TYPE,
-                      0,                    // event category
-                      0,                    // event ID
-                      NULL,                 // current user's SID
-@@ -323,8 +337,10 @@
-    }
- }
- 
--
--
-+void ResetError (void)
-+{
-+  dwErr = 0;
-+}
- 
- ///////////////////////////////////////////////////////////////////
- //
-@@ -341,21 +357,23 @@
- //    none
- //
- //  RETURN VALUE:
--//    none
-+//    0 if success
- //
- //  COMMENTS:
- //
--void CmdInstallService()
-+int CmdInstallService()
- {
-    SC_HANDLE   schService;
-    SC_HANDLE   schSCManager;
- 
-    TCHAR szPath[512];
- 
-+   int ret = 0;
-+
-    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
-    {
-       _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
--      return;
-+      return 1;
-    }
- 
-    schSCManager = OpenSCManager(
-@@ -371,7 +389,7 @@
-                                 TEXT(SZSERVICEDISPLAYNAME), // name to display
-                                 SERVICE_QUERY_STATUS,         // desired access
-                                 SERVICE_WIN32_OWN_PROCESS,  // service type
--                                SERVICE_DEMAND_START,       // start type
-+				SERVICE_DEMAND_START,        // start type -- alternative: SERVICE_AUTO_START
-                                 SERVICE_ERROR_NORMAL,       // error control type
-                                 szPath,                     // service's binary
-                                 NULL,                       // no load ordering group
-@@ -388,16 +406,79 @@
-       else
-       {
-          _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
-+	 ret = 1;
-       }
- 
-       CloseServiceHandle(schSCManager);
-    }
-    else
-+     {
-       _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
-+       ret = 1;
-+     }
-+   return ret;
- }
- 
-+//
-+//  FUNCTION: CmdStartService()
-+//
-+//  PURPOSE: Start the service
-+//
-+//  PARAMETERS:
-+//    none
-+//
-+//  RETURN VALUE:
-+//    0 if success
-+//
-+//  COMMENTS:
-+
-+int CmdStartService()
-+{
-+  int ret = 0;
-+
-+  SC_HANDLE schSCManager;
-+  SC_HANDLE schService;
- 
- 
-+    // Open a handle to the SC Manager database. 
-+    schSCManager = OpenSCManager( 
-+       NULL,                    // local machine 
-+       NULL,                    // ServicesActive database 
-+       SC_MANAGER_ALL_ACCESS);  // full access rights 
-+   
-+    if (NULL == schSCManager) {
-+       _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
-+       ret = 1;
-+    }
-+
-+    schService = OpenService( 
-+        schSCManager,          // SCM database 
-+        SZSERVICENAME,         // service name
-+        SERVICE_ALL_ACCESS); 
-+
-+    if (schService == NULL) {
-+      _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
-+       ret = 1;
-+    }
-+ 
-+    if (!StartService(
-+            schService,  // handle to service 
-+            0,           // number of arguments 
-+            NULL) )      // no arguments 
-+    {
-+      _tprintf(TEXT("StartService failed - %s\n"), GetLastErrorText(szErr,256));
-+       ret = 1;
-+    }
-+    else
-+	{
-+		_tprintf(TEXT("Service Started\n"));
-+       ret = 0;
-+	}
-+    CloseServiceHandle(schService); 
-+    CloseServiceHandle(schSCManager);
-+    return ret;
-+}
-+
- //
- //  FUNCTION: CmdRemoveService()
- //
-@@ -407,15 +488,17 @@
- //    none
- //
- //  RETURN VALUE:
--//    none
-+//    0 if success
- //
- //  COMMENTS:
- //
--void CmdRemoveService()
-+int CmdRemoveService()
- {
-    SC_HANDLE   schService;
-    SC_HANDLE   schSCManager;
- 
-+   int ret = 0;
-+
-    schSCManager = OpenSCManager(
-                                NULL,                   // machine (NULL == local)
-                                NULL,                   // database (NULL == default)
-@@ -447,7 +530,10 @@
-             if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
-                _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );
-             else
-+	      {
-                _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );
-+		ret = 1;
-+	      }
- 
-          }
- 
-@@ -455,18 +541,28 @@
-          if ( DeleteService(schService) )
-             _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
-          else
-+	   {
-             _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));
-+	     ret = 1;
-+	   }
- 
- 
-          CloseServiceHandle(schService);
-       }
-       else
-+	{
-          _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
-+	  ret = 1;
-+	}
- 
-       CloseServiceHandle(schSCManager);
-    }
-    else
-+     {
-       _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
-+       ret = 1;
-+     }
-+   return ret;
- }
- 
- 
-@@ -587,7 +683,7 @@
-    else
-    {
-       lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
--      _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
-+      _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, (int)GetLastError() );
-    }
- 
-    if ( lpszTemp )
---- service.h.orig	Tue Apr 24 14:49:30 2007
-+++ service.h	Tue Apr 24 11:58:48 2007
-@@ -57,18 +57,19 @@
- extern "C" {
- #endif
- 
-+#include "../autodefs/defs.h"
- 
- //////////////////////////////////////////////////////////////////////////////
- //// todo: change to desired strings
- ////
- // name of the executable
--#define SZAPPNAME            "Simple"
-+#define SZAPPNAME            PRODUCT_UNIX_NAME "serv"
- // internal name of the service
--#define SZSERVICENAME        "SimpleService"
-+#define SZSERVICENAME        PRODUCT_NAME "Service"
- // displayed name of the service
--#define SZSERVICEDISPLAYNAME "Simple Service"
-+#define SZSERVICEDISPLAYNAME PRODUCT_NAME " Service"
- // list of service dependencies - "dep1\0dep2\0\0"
--#define SZDEPENDENCIES       ""
-+#define SZDEPENDENCIES       PRODUCT_TAP_ID "\0Dhcp\0\0"
- //////////////////////////////////////////////////////////////////////////////
- 
- 
-@@ -126,7 +127,10 @@
- //  RETURN VALUE:
- //    none
- //
--   void AddToMessageLog(LPTSTR lpszMsg);
-+#  define MSG_FLAGS_ERROR     (1<<0)
-+#  define MSG_FLAGS_SYS_CODE  (1<<1)
-+   void AddToMessageLog(DWORD flags, LPTSTR lpszMsg);
-+   void ResetError (void);
- //////////////////////////////////////////////////////////////////////////////
- 
- 
diff -urN openvpn-2.1_rc7/session_id.c openvpn-2.1_rc9/session_id.c
--- openvpn-2.1_rc7/session_id.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/session_id.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -31,16 +31,10 @@
  * it is called the key_id and is currently 2 bits long.
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
+#include "syshead.h"
 
 #if defined(USE_CRYPTO) && defined(USE_SSL)
 
-#include "syshead.h"
-
 #include "error.h"
 #include "common.h"
 #include "crypto.h"
diff -urN openvpn-2.1_rc7/session_id.h openvpn-2.1_rc9/session_id.h
--- openvpn-2.1_rc7/session_id.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/session_id.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/shaper.c openvpn-2.1_rc9/shaper.c
--- openvpn-2.1_rc7/shaper.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/shaper.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,11 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
 #include "syshead.h"
 #include "shaper.h"
 #include "memdbg.h"
diff -urN openvpn-2.1_rc7/shaper.h openvpn-2.1_rc9/shaper.h
--- openvpn-2.1_rc7/shaper.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/shaper.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/sig.c openvpn-2.1_rc9/sig.c
--- openvpn-2.1_rc7/sig.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/sig.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "buffer.h"
diff -urN openvpn-2.1_rc7/sig.h openvpn-2.1_rc9/sig.h
--- openvpn-2.1_rc7/sig.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/sig.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/socket.c openvpn-2.1_rc9/socket.c
--- openvpn-2.1_rc7/socket.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/socket.c	2008-07-27 01:04:18.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "socket.h"
@@ -138,6 +132,9 @@
       while (true)
 	{
 	  /* try hostname lookup */
+#if defined(HAVE_RES_INIT)
+	  res_init ();
+#endif
 	  h = gethostbyname (hostname);
 
 	  if (signal_received)
@@ -255,6 +252,48 @@
     return OIA_HOSTNAME; /* probably a hostname */
 }
 
+bool
+ip_addr_dotted_quad_safe (const char *dotted_quad)
+{
+  /* verify non-NULL */
+  if (!dotted_quad)
+    return false;
+
+  /* verify length is within limits */
+  if (strlen (dotted_quad) > 15)
+    return false;
+
+  /* verify that all chars are either numeric or '.' and that no numeric
+     substring is greater than 3 chars */
+  {
+    int nnum = 0;
+    const char *p = dotted_quad;
+    int c;
+
+    while ((c = *p++))
+      {
+	if (c >= '0' && c <= '9')
+	  {
+	    ++nnum;
+	    if (nnum > 3)
+	      return false;
+	  }
+	else if (c == '.')
+	  {
+	    nnum = 0;
+	  }
+	else
+	  return false;
+      }
+  }
+
+  /* verify that string will convert to IP address */
+  {
+    struct in_addr a;
+    return openvpn_inet_aton (dotted_quad, &a) == OIA_IP;
+  }
+}
+
 static void
 update_remote (const char* host,
 	       struct openvpn_sockaddr *addr,
@@ -295,9 +334,12 @@
 socket_set_sndbuf (int sd, int size)
 {
 #if defined(HAVE_SETSOCKOPT) && defined(SOL_SOCKET) && defined(SO_SNDBUF)
-  if (setsockopt (sd, SOL_SOCKET, SO_SNDBUF, (void *) &size, sizeof (size)) != 0)
+  if (size > 0 && size < SOCKET_SND_RCV_BUF_MAX)
     {
-      msg (M_WARN, "NOTE: setsockopt SO_SNDBUF=%d failed", size);
+      if (setsockopt (sd, SOL_SOCKET, SO_SNDBUF, (void *) &size, sizeof (size)) != 0)
+	{
+	  msg (M_WARN, "NOTE: setsockopt SO_SNDBUF=%d failed", size);
+	}
     }
 #endif
 }
@@ -321,10 +363,13 @@
 socket_set_rcvbuf (int sd, int size)
 {
 #if defined(HAVE_SETSOCKOPT) && defined(SOL_SOCKET) && defined(SO_RCVBUF)
-  if (setsockopt (sd, SOL_SOCKET, SO_RCVBUF, (void *) &size, sizeof (size)) != 0)
+  if (size > 0 && size < SOCKET_SND_RCV_BUF_MAX)
     {
-      msg (M_WARN, "NOTE: setsockopt SO_RCVBUF=%d failed", size);
-      return false;
+      if (setsockopt (sd, SOL_SOCKET, SO_RCVBUF, (void *) &size, sizeof (size)) != 0)
+	{
+	  msg (M_WARN, "NOTE: setsockopt SO_RCVBUF=%d failed", size);
+	  return false;
+	}
     }
   return true;
 #endif
@@ -406,77 +451,6 @@
 }
 
 /*
- * Remote list code allows clients to specify a list of
- * potential remote server addresses.
- */
-
-static void
-remote_list_next (struct remote_list *l)
-{
-  if (l)
-    {
-      if (l->no_advance && l->current >= 0)
-	{
-	  l->no_advance = false;
-	}
-      else
-	{
-	  int i;
-	  if (++l->current >= l->len)
-	    l->current = 0;
-
-	  dmsg (D_REMOTE_LIST, "REMOTE_LIST len=%d current=%d",
-		l->len, l->current);
-	  for (i = 0; i < l->len; ++i)
-	    {
-	      dmsg (D_REMOTE_LIST, "[%d] %s:%d",
-		    i,
-		    l->array[i].hostname,
-		    l->array[i].port);
-	    }
-	}
-    }
-}
-
-void
-remote_list_randomize (struct remote_list *l)
-{
-  int i;
-  if (l)
-    {
-      for (i = 0; i < l->len; ++i)
-	{
-	  const int j = get_random () % l->len;
-	  if (i != j)
-	    {
-	      struct remote_entry tmp;
-	      tmp = l->array[i];
-	      l->array[i] = l->array[j];
-	      l->array[j] = tmp;
-	    }
-	}
-    }
-}
-
-static const char *
-remote_list_host (const struct remote_list *rl)
-{
-  if (rl)
-    return rl->array[rl->current].hostname;
-  else
-    return NULL;
-}
-
-static int
-remote_list_port (const struct remote_list *rl)
-{
-  if (rl)
-    return rl->array[rl->current].port;
-  else
-    return 0;
-}
-
-/*
  * SOCKET INITALIZATION CODE.
  * Create a TCP/UDP socket
  */
@@ -816,7 +790,7 @@
                 struct openvpn_sockaddr *local,
                 bool bind_local,
 		struct openvpn_sockaddr *remote,
-		struct remote_list *remote_list,
+		const bool connection_profiles_defined,
 		const char *remote_dynamic,
 		bool *remote_changed,
 		const int connect_retry_seconds,
@@ -868,7 +842,7 @@
       openvpn_close_socket (*sd);
       *sd = SOCKET_UNDEFINED;
 
-      if (connect_retry_max > 0 && ++retry >= connect_retry_max)
+      if ((connect_retry_max > 0 && ++retry >= connect_retry_max) || connection_profiles_defined)
 	{
 	  *signal_received = SIGUSR1;
 	  goto done;
@@ -880,14 +854,6 @@
       if (*signal_received)
 	goto done;
 
-      if (remote_list)
-	{
-	  remote_list_next (remote_list);
-	  remote_dynamic = remote_list_host (remote_list);
-	  remote->sa.sin_port = htons (remote_list_port (remote_list));
-	  *remote_changed = true;
-	}
-
       *sd = create_socket_tcp ();
       if (bind_local)
         socket_bind (*sd, local, "TCP Client");
@@ -999,7 +965,7 @@
 	      int retry = 0;
 	      bool status = false;
 
-	      if (remote_list_len (sock->remote_list) > 1 && sock->resolve_retry_seconds == RESOLV_RETRY_INFINITE)
+	      if (sock->connection_profiles_defined && sock->resolve_retry_seconds == RESOLV_RETRY_INFINITE)
 		{
 		  if (phase == 2)
 		    flags |= (GETADDR_TRY_ONCE | GETADDR_FATAL);
@@ -1102,9 +1068,11 @@
 /* bind socket if necessary */
 void
 link_socket_init_phase1 (struct link_socket *sock,
+			 const bool connection_profiles_defined,
 			 const char *local_host,
-			 struct remote_list *remote_list,
 			 int local_port,
+			 const char *remote_host,
+			 int remote_port,
 			 int proto,
 			 int mode,
 			 const struct link_socket *accept_from,
@@ -1132,18 +1100,14 @@
 			 int sndbuf,
 			 unsigned int sockflags)
 {
-  const char *remote_host;
-  int remote_port;
-
   ASSERT (sock);
 
-  sock->remote_list = remote_list;
-  remote_list_next (remote_list);
-  remote_host = remote_list_host (remote_list);
-  remote_port = remote_list_port (remote_list);
+  sock->connection_profiles_defined = connection_profiles_defined;
 
   sock->local_host = local_host;
   sock->local_port = local_port;
+  sock->remote_host = remote_host;
+  sock->remote_port = remote_port;
 
 #ifdef ENABLE_HTTP_PROXY
   sock->http_proxy = http_proxy;
@@ -1201,10 +1165,6 @@
       /* the OpenVPN server we will use the proxy to connect to */
       sock->proxy_dest_host = remote_host;
       sock->proxy_dest_port = remote_port;
-
-      /* this is needed so that connection retries will go to the proxy server,
-	 not the remote OpenVPN address */
-      sock->remote_list = NULL;
     }
 #endif
 #ifdef ENABLE_SOCKS
@@ -1221,10 +1181,6 @@
       /* the OpenVPN server we will use the proxy to connect to */
       sock->proxy_dest_host = remote_host;
       sock->proxy_dest_port = remote_port;
-
-      /* this is needed so that connection retries will go to the proxy server,
-	 not the remote OpenVPN address */
-      sock->remote_list = NULL;
     }
 #endif
   else
@@ -1360,7 +1316,7 @@
 			    &sock->info.lsa->local,
 			    sock->bind_local,
 			    &sock->info.lsa->actual.dest,
-			    sock->remote_list,
+			    sock->connection_profiles_defined,
 			    remote_dynamic,
 			    &remote_changed,
 			    sock->connect_retry_seconds,
@@ -1408,7 +1364,7 @@
                           &sock->info.lsa->local,
                           sock->bind_local,
 			  &sock->info.lsa->actual.dest,
-			  NULL,
+			  sock->connection_profiles_defined,
 			  remote_dynamic,
 			  &remote_changed,
 			  sock->connect_retry_seconds,
@@ -1566,6 +1522,22 @@
   setenv_link_socket_actual (es, "trusted", &info->lsa->actual, SA_IP_PORT);
 }
 
+static void
+ipchange_fmt (const bool include_cmd, struct argv *argv, const struct link_socket_info *info, struct gc_arena *gc)
+{
+  const char *ip = print_sockaddr_ex (&info->lsa->actual.dest, NULL, 0, gc);
+  const char *port = print_sockaddr_ex (&info->lsa->actual.dest, NULL, PS_DONT_SHOW_ADDR|PS_SHOW_PORT, gc);
+  if (include_cmd)
+    argv_printf (argv, "%s %s %s",
+		 info->ipchange_command,
+		 ip,
+		 port);
+  else
+    argv_printf (argv, "%s %s",
+		 ip,
+		 port);
+}
+
 void
 link_socket_connection_initiated (const struct buffer *buf,
 				  struct link_socket_info *info,
@@ -1594,20 +1566,21 @@
   /* Process --ipchange plugin */
   if (plugin_defined (info->plugins, OPENVPN_PLUGIN_IPCHANGE))
     {
-      const char *addr_ascii = print_sockaddr_ex (&info->lsa->actual.dest, " ", PS_SHOW_PORT, &gc);
-      if (plugin_call (info->plugins, OPENVPN_PLUGIN_IPCHANGE, addr_ascii, NULL, es))
+      struct argv argv = argv_new ();
+      ipchange_fmt (false, &argv, info, &gc);
+      if (plugin_call (info->plugins, OPENVPN_PLUGIN_IPCHANGE, &argv, NULL, es) != OPENVPN_PLUGIN_FUNC_SUCCESS)
 	msg (M_WARN, "WARNING: ipchange plugin call failed");
+      argv_reset (&argv);
     }
 
   /* Process --ipchange option */
   if (info->ipchange_command)
     {
-      struct buffer out = alloc_buf_gc (256, &gc);
+      struct argv argv = argv_new ();
       setenv_str (es, "script_type", "ipchange");
-      buf_printf (&out, "%s %s",
-		  info->ipchange_command,
-		  print_sockaddr_ex (&info->lsa->actual.dest, " ", PS_SHOW_PORT, &gc));
-      system_check (BSTR (&out), es, S_SCRIPT, "ip-change command failed");
+      ipchange_fmt (true, &argv, info, &gc);
+      openvpn_execve_check (&argv, es, S_SCRIPT, "ip-change command failed");
+      argv_reset (&argv);
     }
 
   gc_free (&gc);
@@ -1877,7 +1850,8 @@
       const int port = ntohs (addr->sa.sin_port);
 
       mutex_lock_static (L_INET_NTOA);
-      buf_printf (&out, "%s", (addr_defined (addr) ? inet_ntoa (addr->sa.sin_addr) : "[undef]"));
+      if (!(flags & PS_DONT_SHOW_ADDR))
+	buf_printf (&out, "%s", (addr_defined (addr) ? inet_ntoa (addr->sa.sin_addr) : "[undef]"));
       mutex_unlock_static (L_INET_NTOA);
 
       if (((flags & PS_SHOW_PORT) || (addr_defined (addr) && (flags & PS_SHOW_PORT_IF_DEFINED)))
@@ -2121,11 +2095,13 @@
 
 #if ENABLE_IP_PKTINFO
 
+#pragma pack(1) /* needed to keep structure size consistent for 32 vs. 64-bit architectures */
 struct openvpn_pktinfo
 {
   struct cmsghdr cmsghdr;
   struct in_pktinfo in_pktinfo;
 };
+#pragma pack()
 
 static socklen_t
 link_socket_read_udp_posix_recvmsg (struct link_socket *sock,
diff -urN openvpn-2.1_rc7/socket.h openvpn-2.1_rc9/socket.h
--- openvpn-2.1_rc7/socket.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/socket.h	2008-07-26 20:44:45.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -42,27 +42,16 @@
 #define OPENVPN_PORT 1194
 
 /*
+ * Maximum size passed passed to setsockopt SNDBUF/RCVBUF
+ */
+#define SOCKET_SND_RCV_BUF_MAX 1000000
+
+/*
  * Number of seconds that "resolv-retry infinite"
  * represents.
  */
 #define RESOLV_RETRY_INFINITE 1000000000
 
-#define REMOTE_LIST_SIZE 64
-
-struct remote_entry
-{
-  const char *hostname;
-  int port;
-};
-
-struct remote_list
-{
-  int len;
-  int current;
-  bool no_advance;
-  struct remote_entry array[REMOTE_LIST_SIZE];
-};
-
 /* 
  * packet_size_type is used to communicate packet size
  * over the wire when stream oriented protocols are
@@ -175,8 +164,9 @@
   /* used for long-term queueing of pre-accepted socket listen */
   bool listen_persistent_queued;
 
-  /* set on initial call to init phase 1 */
-  struct remote_list *remote_list;
+  /* Does config file contain any <connection> ... </connection> blocks? */
+  bool connection_profiles_defined;
+
   const char *remote_host;
   int remote_port;
   const char *local_host;
@@ -290,9 +280,11 @@
 
 void
 link_socket_init_phase1 (struct link_socket *sock,
+			 const bool connection_profiles_defined,
 			 const char *local_host,
-			 struct remote_list *remote_list,
 			 int local_port,
+			 const char *remote_host,
+			 int remote_port,
 			 int proto,
 			 int mode,
 			 const struct link_socket *accept_from,
@@ -333,6 +325,7 @@
 #define PS_SHOW_PORT_IF_DEFINED (1<<0)
 #define PS_SHOW_PORT            (1<<1)
 #define PS_SHOW_PKTINFO         (1<<2)
+#define PS_DONT_SHOW_ADDR       (1<<3)
 
 const char *print_sockaddr_ex (const struct openvpn_sockaddr *addr,
 			       const char* separator,
@@ -391,8 +384,6 @@
 
 void setenv_trusted (struct env_set *es, const struct link_socket_info *info);
 
-void remote_list_randomize (struct remote_list *l);
-
 bool link_socket_update_flags (struct link_socket *ls, unsigned int sockflags);
 void link_socket_update_buffer_sizes (struct link_socket *ls, int rcvbuf, int sndbuf);
 
@@ -405,6 +396,7 @@
 #define OIA_IP         1
 #define OIA_ERROR     -1
 int openvpn_inet_aton (const char *dotted_quad, struct in_addr *addr);
+bool ip_addr_dotted_quad_safe (const char *dotted_quad);
 
 socket_descriptor_t create_socket_tcp (void);
 
@@ -467,15 +459,6 @@
  * Misc inline functions
  */
 
-static inline int
-remote_list_len (const struct remote_list *rl)
-{
-  if (rl)
-    return rl->len;
-  else
-    return 0;
-}
-
 static inline bool
 legal_ipv4_port (int port)
 {
diff -urN openvpn-2.1_rc7/socks.c openvpn-2.1_rc9/socks.c
--- openvpn-2.1_rc7/socks.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/socks.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -29,16 +29,10 @@
  * see RFC 1928, only supports "no authentication"
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
+#include "syshead.h"
 
 #ifdef ENABLE_SOCKS
 
-#include "syshead.h"
-
 #include "common.h"
 #include "misc.h"
 #include "win32.h"
@@ -57,11 +51,10 @@
 }
 
 struct socks_proxy_info *
-new_socks_proxy (const char *server,
+socks_proxy_new (const char *server,
 		 int port,
 		 bool retry,
-		 struct auto_proxy_info *auto_proxy_info,
-		 struct gc_arena *gc)
+		 struct auto_proxy_info *auto_proxy_info)
 {
   struct socks_proxy_info *p;
 
@@ -77,7 +70,7 @@
 	}
     }
 
-  ALLOC_OBJ_CLEAR_GC (p, struct socks_proxy_info, gc);
+  ALLOC_OBJ_CLEAR (p, struct socks_proxy_info);
 
   ASSERT (server);
   ASSERT (legal_ipv4_port (port));
@@ -90,6 +83,12 @@
   return p;
 }
 
+void
+socks_proxy_close (struct socks_proxy_info *sp)
+{
+  free (sp);
+}
+
 static bool
 socks_handshake (socket_descriptor_t sd, volatile int *signal_received)
 {
diff -urN openvpn-2.1_rc7/socks.h openvpn-2.1_rc9/socks.h
--- openvpn-2.1_rc7/socks.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/socks.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -47,11 +47,12 @@
 
 void socks_adjust_frame_parameters (struct frame *frame, int proto);
 
-struct socks_proxy_info *new_socks_proxy (const char *server,
+struct socks_proxy_info *socks_proxy_new (const char *server,
 					  int port,
 					  bool retry,
-					  struct auto_proxy_info *auto_proxy_info,
-					  struct gc_arena *gc);
+					  struct auto_proxy_info *auto_proxy_info);
+
+void socks_proxy_close (struct socks_proxy_info *sp);
 
 void establish_socks_proxy_passthru (struct socks_proxy_info *p,
 				     socket_descriptor_t sd, /* already open to proxy */
diff -urN openvpn-2.1_rc7/ssl.c openvpn-2.1_rc9/ssl.c
--- openvpn-2.1_rc7/ssl.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/ssl.c	2008-07-27 02:39:02.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -30,16 +30,10 @@
  * over the same TCP/UDP port.
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
+#include "syshead.h"
 
 #if defined(USE_CRYPTO) && defined(USE_SSL)
 
-#include "syshead.h"
-
 #include "ssl.h"
 #include "error.h"
 #include "common.h"
@@ -53,6 +47,7 @@
 #include "status.h"
 #include "gremlin.h"
 #include "pkcs11.h"
+#include "list.h"
 
 #ifdef WIN32
 #include "cryptoapi.h"
@@ -349,45 +344,14 @@
  *
  * Example:
  *
- * /C=US/ST=CO/L=Denver/O=ORG/CN=Test-CA/Email=jim@yonan.net
- *
- * The common name is 'Test-CA'
- */
-static void
-extract_x509_field (const char *x509, const char *field_name, char *out, int size)
-{
-  char field_buf[256];
-  struct buffer x509_buf;
-
-  ASSERT (size > 0);
-  *out = '\0';
-  buf_set_read (&x509_buf, (uint8_t *)x509, strlen (x509));
-  while (buf_parse (&x509_buf, '/', field_buf, sizeof (field_buf)))
-    {
-      struct buffer component_buf;
-      char field_name_buf[64];
-      char field_value_buf[256];
-      buf_set_read (&component_buf, (const uint8_t *) field_buf, strlen (field_buf));
-      buf_parse (&component_buf, '=', field_name_buf, sizeof (field_name_buf));
-      buf_parse (&component_buf, '=', field_value_buf, sizeof (field_value_buf));
-      if (!strcmp (field_name_buf, field_name))
-	{
-	  strncpynt (out, field_value_buf, size);
-	  break;
-	}
-    }
-}
-
-/*
- * Extract a field from an X509 subject name.
- *
- * Example:
- *
  * /C=US/ST=CO/L=Denver/O=ORG/CN=First-CN/CN=Test-CA/Email=jim@yonan.net
  *
  * The common name is 'Test-CA'
+ *
+ * Return true on success, false on error (insufficient buffer size in 'out'
+ * to contain result is grounds for error).
  */
-static void
+static bool
 extract_x509_field_ssl (X509_NAME *x509, const char *field_name, char *out, int size)
 {
   int lastpos = -1;
@@ -402,25 +366,30 @@
   do {
     lastpos = tmp;
     tmp = X509_NAME_get_index_by_NID(x509, nid, lastpos);
-  } while (tmp > 0);
+  } while (tmp > -1);
 
   /* Nothing found */
   if (lastpos == -1)
-    return;
+    return false;
 
   x509ne = X509_NAME_get_entry(x509, lastpos);
   if (!x509ne)
-    return;
+    return false;
 
   asn1 = X509_NAME_ENTRY_get_data(x509ne);
   if (!asn1)
-    return;
+    return false;
   tmp = ASN1_STRING_to_UTF8(&buf, asn1);
   if (tmp <= 0)
-    return;
+    return false;
 
   strncpynt(out, (char *)buf, size);
-  OPENSSL_free(buf);
+
+  {
+    const bool ret = (strlen ((char *)buf) < size);
+    OPENSSL_free (buf);
+    return ret;
+  }
 }
 
 static void
@@ -436,10 +405,22 @@
     {
       free (session->common_name);
       session->common_name = NULL;
+#ifdef ENABLE_PF
+      session->common_name_hashval = 0;
+#endif
     }
   if (common_name)
     {
       session->common_name = string_alloc (common_name, NULL);
+#ifdef ENABLE_PF
+      {
+	const uint32_t len = (uint32_t) strlen (common_name);
+	if (len)
+	  session->common_name_hashval = hash_func ((const uint8_t*)common_name, len+1, 0);
+	else
+	  session->common_name_hashval = 0;
+      }
+#endif
     }
 }
 
@@ -556,13 +537,14 @@
 static int
 verify_callback (int preverify_ok, X509_STORE_CTX * ctx)
 {
-  char subject[256];
+  char *subject = NULL;
   char envname[64];
   char common_name[TLS_CN_LEN];
   SSL *ssl;
   struct tls_session *session;
   const struct tls_options *opt;
   const int max_depth = 8;
+  struct argv argv = argv_new ();
 
   /* get the tls_session pointer */
   ssl = X509_STORE_CTX_get_ex_data (ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
@@ -575,16 +557,29 @@
   session->verified = false;
 
   /* get the X509 name */
-  X509_NAME_oneline (X509_get_subject_name (ctx->current_cert), subject,
-		     sizeof (subject));
-  subject[sizeof (subject) - 1] = '\0';
+  subject = X509_NAME_oneline (X509_get_subject_name (ctx->current_cert), NULL, 0);
+  if (!subject)
+    {
+      msg (D_TLS_ERRORS, "VERIFY ERROR: depth=%d, could not extract X509 subject string from certificate", ctx->error_depth);
+      goto err;
+    }
 
   /* enforce character class restrictions in X509 name */
   string_mod (subject, X509_NAME_CHAR_CLASS, 0, '_');
+  string_replace_leading (subject, '-', '_');
 
   /* extract the common name */
-  extract_x509_field_ssl (X509_get_subject_name (ctx->current_cert), "CN", common_name, TLS_CN_LEN);
-  //extract_x509_field (subject, "CN", common_name, TLS_CN_LEN);
+  if (!extract_x509_field_ssl (X509_get_subject_name (ctx->current_cert), "CN", common_name, TLS_CN_LEN))
+    {
+      if (!ctx->error_depth)
+	{
+	  msg (D_TLS_ERRORS, "VERIFY ERROR: could not extract Common Name from X509 subject string ('%s') -- note that the Common Name length is limited to %d characters",
+	       subject,
+	       TLS_CN_LEN);
+	  goto err;
+	}
+    }
+
   string_mod (common_name, COMMON_NAME_CHAR_CLASS, 0, '_');
 
 #if 0 /* print some debugging info */
@@ -695,18 +690,15 @@
   /* call --tls-verify plug-in(s) */
   if (plugin_defined (opt->plugins, OPENVPN_PLUGIN_TLS_VERIFY))
     {
-      char command[256];
-      struct buffer out;
       int ret;
 
-      buf_set_write (&out, (uint8_t*)command, sizeof (command));
-      buf_printf (&out, "%d %s",
-		  ctx->error_depth,
-		  subject);
+      argv_printf (&argv, "%d %s",
+		   ctx->error_depth,
+		   subject);
 
-      ret = plugin_call (opt->plugins, OPENVPN_PLUGIN_TLS_VERIFY, command, NULL, opt->es);
+      ret = plugin_call (opt->plugins, OPENVPN_PLUGIN_TLS_VERIFY, &argv, NULL, opt->es);
 
-      if (!ret)
+      if (ret == OPENVPN_PLUGIN_FUNC_SUCCESS)
 	{
 	  msg (D_HANDSHAKE, "VERIFY PLUGIN OK: depth=%d, %s",
 	       ctx->error_depth, subject);
@@ -722,19 +714,16 @@
   /* run --tls-verify script */
   if (opt->verify_command)
     {
-      char command[256];
-      struct buffer out;
       int ret;
 
       setenv_str (opt->es, "script_type", "tls-verify");
 
-      buf_set_write (&out, (uint8_t*)command, sizeof (command));
-      buf_printf (&out, "%s %d %s",
-		  opt->verify_command,
-		  ctx->error_depth,
-		  subject);
-      dmsg (D_TLS_DEBUG, "TLS: executing verify command: %s", command);
-      ret = openvpn_system (command, opt->es, S_SCRIPT);
+      argv_printf (&argv, "%s %d %s",
+		   opt->verify_command,
+		   ctx->error_depth,
+		   subject);
+      argv_msg_prefix (D_TLS_DEBUG, &argv, "TLS: executing verify command");
+      ret = openvpn_execve (&argv, opt->es, S_SCRIPT);
 
       if (system_ok (ret))
 	{
@@ -744,7 +733,7 @@
       else
 	{
 	  if (!system_executed (ret))
-	    msg (M_ERR, "Verify command failed to execute: %s", command);
+	    argv_msg_prefix (M_ERR, &argv, "Verify command failed to execute");
 	  msg (D_HANDSHAKE, "VERIFY SCRIPT ERROR: depth=%d, %s",
 	       ctx->error_depth, subject);
 	  goto err;		/* Reject connection */
@@ -806,10 +795,14 @@
   msg (D_HANDSHAKE, "VERIFY OK: depth=%d, %s", ctx->error_depth, subject);
 
   session->verified = true;
+  free (subject);
+  argv_reset (&argv);
   return 1;			/* Accept connection */
 
  err:
   ERR_clear_error ();
+  free (subject);
+  argv_reset (&argv);
   return 0;                     /* Reject connection */
 }
 
@@ -821,7 +814,7 @@
 }
 
 const char *
-tls_common_name (struct tls_multi *multi, bool null)
+tls_common_name (const struct tls_multi *multi, const bool null)
 {
   const char *ret = NULL;
   if (multi)
@@ -842,35 +835,204 @@
     multi->locked_cn = string_alloc (cn, NULL);
 }
 
+#ifdef ENABLE_DEF_AUTH
+/* key_state_test_auth_control_file return values,
+   NOTE: acf_merge indexing depends on these values */
+#define ACF_UNDEFINED 0
+#define ACF_SUCCEEDED 1
+#define ACF_DISABLED  2
+#define ACF_FAILED    3
+#endif
+
+#ifdef MANAGEMENT_DEF_AUTH
+static inline unsigned int
+man_def_auth_test (const struct key_state *ks)
+{
+  if (management_enable_def_auth (management))
+    return ks->mda_status;
+  else
+    return ACF_DISABLED;
+}
+#endif
+
+#ifdef PLUGIN_DEF_AUTH
+
 /*
- * Return true if at least one valid key state exists
- * which has passed authentication.  If we are using
- * username/password authentication, and the authentication
- * failed, we may have a live S_ACTIVE/S_NORMAL key state
- * even though the 'authenticated' var might be false.
- *
- * This is so that we can return an AUTH_FAILED error
- * message to the client over the TLS channel.
- *
- * If 'authenticated' is false, tunnel traffic forwarding
- * is disabled but TLS channel data can still be sent
- * or received.
+ * auth_control_file functions
+ */
+
+static void
+key_state_rm_auth_control_file (struct key_state *ks)
+{
+  if (ks && ks->auth_control_file)
+    {
+      delete_file (ks->auth_control_file);
+      free (ks->auth_control_file);
+      ks->auth_control_file = NULL;
+    }
+}
+
+static void
+key_state_gen_auth_control_file (struct key_state *ks, const struct tls_options *opt)
+{
+  struct gc_arena gc = gc_new ();
+  const char *acf;
+
+  key_state_rm_auth_control_file (ks);
+  acf = create_temp_filename (opt->tmp_dir, "acf", &gc);
+  ks->auth_control_file = string_alloc (acf, NULL);
+  setenv_str (opt->es, "auth_control_file", ks->auth_control_file);
+
+  gc_free (&gc);					  
+}
+
+static unsigned int
+key_state_test_auth_control_file (struct key_state *ks)
+{
+  if (ks && ks->auth_control_file)
+    {
+      unsigned int ret = ks->auth_control_status;
+      if (ret == ACF_UNDEFINED)
+	{
+	  FILE *fp = fopen (ks->auth_control_file, "r");
+	  if (fp)
+	    {
+	      const int c = fgetc (fp);
+	      if (c == '1')
+		ret = ACF_SUCCEEDED;
+	      else if (c == '0')
+		ret = ACF_FAILED;
+	      fclose (fp);
+	      ks->auth_control_status = ret;
+	    }
+	}
+      return ret;
+    }
+  return ACF_DISABLED;
+}
+
+#endif
+
+/*
+ * Return current session authentication state.  Return
+ * value is TLS_AUTHENTICATION_x.
  */
+
+int
+tls_authentication_status (struct tls_multi *multi, const int latency)
+{
+  bool deferred = false;
+  bool success = false;
+  bool active = false;
+
+#ifdef ENABLE_DEF_AUTH
+  static const unsigned char acf_merge[] =
+    {
+      ACF_UNDEFINED, /* s1=ACF_UNDEFINED s2=ACF_UNDEFINED */
+      ACF_UNDEFINED, /* s1=ACF_UNDEFINED s2=ACF_SUCCEEDED */
+      ACF_UNDEFINED, /* s1=ACF_UNDEFINED s2=ACF_DISABLED */
+      ACF_FAILED,    /* s1=ACF_UNDEFINED s2=ACF_FAILED */
+      ACF_UNDEFINED, /* s1=ACF_SUCCEEDED s2=ACF_UNDEFINED */
+      ACF_SUCCEEDED, /* s1=ACF_SUCCEEDED s2=ACF_SUCCEEDED */
+      ACF_SUCCEEDED, /* s1=ACF_SUCCEEDED s2=ACF_DISABLED */
+      ACF_FAILED,    /* s1=ACF_SUCCEEDED s2=ACF_FAILED */
+      ACF_UNDEFINED, /* s1=ACF_DISABLED  s2=ACF_UNDEFINED */
+      ACF_SUCCEEDED, /* s1=ACF_DISABLED  s2=ACF_SUCCEEDED */
+      ACF_DISABLED,  /* s1=ACF_DISABLED  s2=ACF_DISABLED */
+      ACF_FAILED,    /* s1=ACF_DISABLED  s2=ACF_FAILED */
+      ACF_FAILED,    /* s1=ACF_FAILED    s2=ACF_UNDEFINED */
+      ACF_FAILED,    /* s1=ACF_FAILED    s2=ACF_SUCCEEDED */
+      ACF_FAILED,    /* s1=ACF_FAILED    s2=ACF_DISABLED */
+      ACF_FAILED     /* s1=ACF_FAILED    s2=ACF_FAILED */
+    };
+#endif
+
+  if (multi)
+    {
+      int i;
+
+#ifdef ENABLE_DEF_AUTH
+      if (latency && multi->tas_last && multi->tas_last + latency >= now)
+	return TLS_AUTHENTICATION_UNDEFINED;
+      multi->tas_last = now;
+#endif
+
+      for (i = 0; i < KEY_SCAN_SIZE; ++i)
+	{
+	  struct key_state *ks = multi->key_scan[i];
+	  if (DECRYPT_KEY_ENABLED (multi, ks))
+	    {
+	      active = true;
+	      if (ks->authenticated)
+		{
+#ifdef ENABLE_DEF_AUTH
+		  unsigned int s1 = ACF_DISABLED;
+		  unsigned int s2 = ACF_DISABLED;
+#ifdef PLUGIN_DEF_AUTH
+		  s1 = key_state_test_auth_control_file (ks); 
+#endif
+#ifdef MANAGEMENT_DEF_AUTH
+		  s2 = man_def_auth_test (ks);
+#endif
+		  ASSERT (s1 < 4 && s2 < 4);
+		  switch (acf_merge[(s1<<2) + s2])
+		    {
+		    case ACF_SUCCEEDED:
+		    case ACF_DISABLED:
+		      success = true;
+		      ks->auth_deferred = false;
+		      break;
+		    case ACF_UNDEFINED:
+		      if (now < ks->auth_deferred_expire)
+			deferred = true;
+		      break;
+		    case ACF_FAILED:
+		      ks->authenticated = false;
+		      break;
+		    default:
+		      ASSERT (0);
+		    }
+#else
+		  success = true;
+#endif
+		}
+	    }
+	}
+    }
+
+#if 0
+  dmsg (D_TLS_ERRORS, "TAS: a=%d s=%d d=%d", active, success, deferred);
+#endif
+
+  if (success)
+    return TLS_AUTHENTICATION_SUCCEEDED;
+  else if (!active || deferred)
+    return TLS_AUTHENTICATION_DEFERRED;
+  else
+    return TLS_AUTHENTICATION_FAILED;
+}
+
+#ifdef MANAGEMENT_DEF_AUTH
 bool
-tls_authenticated (struct tls_multi *multi)
+tls_authenticate_key (struct tls_multi *multi, const unsigned int mda_key_id, const bool auth)
 {
+  bool ret = false;
   if (multi)
     {
       int i;
       for (i = 0; i < KEY_SCAN_SIZE; ++i)
 	{
-	  const struct key_state *ks = multi->key_scan[i];
-	  if (DECRYPT_KEY_ENABLED (multi, ks) && ks->authenticated)
-	    return true;
+	  struct key_state *ks = multi->key_scan[i];
+	  if (ks->mda_key_id == mda_key_id)
+	    {
+	      ks->mda_status = auth ? ACF_SUCCEEDED : ACF_FAILED;
+	      ret = true;
+	    }
 	}
     }
-  return false;
+  return ret;
 }
+#endif
 
 void
 tls_deauthenticate (struct tls_multi *multi)
@@ -1200,7 +1362,7 @@
       if (options->pkcs11_providers[0])
         {
          /* Load Certificate and Private Key */
-	 if (!SSL_CTX_use_pkcs11 (ctx, options->pkcs11_id))
+	 if (!SSL_CTX_use_pkcs11 (ctx, options->pkcs11_id_management, options->pkcs11_id))
 	   {
 	     msg (M_WARN, "Cannot load certificate \"%s\" using PKCS#11 interface", options->pkcs11_id);
 	     goto err;
@@ -1341,7 +1503,7 @@
 #if P2MP_SERVER
   if (options->client_cert_not_required)
     {
-      msg (M_WARN, "WARNING: This configuration may accept clients which do not present a certificate");
+      msg (M_WARN, "WARNING: POTENTIALLY DANGEROUS OPTION --client-cert-not-required may accept clients which do not present a certificate");
     }
   else
 #endif
@@ -1859,6 +2021,10 @@
   packet_id_init (&ks->packet_id,
 		  session->opt->replay_window,
 		  session->opt->replay_time);
+
+#ifdef MANAGEMENT_DEF_AUTH
+  ks->mda_key_id = session->opt->mda_context->mda_key_id_counter++;
+#endif
 }
 
 static void
@@ -1901,6 +2067,10 @@
 
   packet_id_free (&ks->packet_id);
 
+#ifdef PLUGIN_DEF_AUTH
+  key_state_rm_auth_control_file (ks);
+#endif
+
   if (clear)
     CLEAR (*ks);
 }
@@ -2728,7 +2898,7 @@
 verify_user_pass_script (struct tls_session *session, const struct user_pass *up)
 {
   struct gc_arena gc = gc_new ();
-  struct buffer cmd = alloc_buf_gc (256, &gc);
+  struct argv argv = argv_new ();
   const char *tmp_file = "";
   int retval;
   bool ret = false;
@@ -2743,7 +2913,7 @@
 	{
 	  struct status_output *so;
 
-	  tmp_file = create_temp_filename (session->opt->tmp_dir, &gc);
+	  tmp_file = create_temp_filename (session->opt->tmp_dir, "up", &gc);
 	  so = status_open (tmp_file, 0, -1, NULL, STATUS_OUTPUT_WRITE);
 	  status_printf (so, "%s", up->username);
 	  status_printf (so, "%s", up->password);
@@ -2767,16 +2937,16 @@
       setenv_untrusted (session);
 
       /* format command line */
-      buf_printf (&cmd, "%s %s", session->opt->auth_user_pass_verify_script, tmp_file);
+      argv_printf (&argv, "%s %s", session->opt->auth_user_pass_verify_script, tmp_file);
       
       /* call command */
-      retval = openvpn_system (BSTR (&cmd), session->opt->es, S_SCRIPT);
+      retval = openvpn_execve (&argv, session->opt->es, S_SCRIPT);
 
       /* test return status of command */
       if (system_ok (retval))
 	ret = true;
       else if (!system_executed (retval))
-	msg (D_TLS_ERRORS, "TLS Auth Error: user-pass-verify script failed to execute: %s", BSTR (&cmd));
+	argv_msg_prefix (D_TLS_ERRORS, &argv, "TLS Auth Error: user-pass-verify script failed to execute");
 	  
       if (!session->opt->auth_user_pass_verify_script_via_file)
 	setenv_del (session->opt->es, "password");
@@ -2790,15 +2960,15 @@
   if (strlen (tmp_file) > 0)
     delete_file (tmp_file);
 
+  argv_reset (&argv);
   gc_free (&gc);
   return ret;
 }
 
-static bool
+static int
 verify_user_pass_plugin (struct tls_session *session, const struct user_pass *up, const char *raw_username)
 {
-  int retval;
-  bool ret = false;
+  int retval = OPENVPN_PLUGIN_FUNC_ERROR;
 
   /* Is username defined? */
   if (strlen (up->username))
@@ -2813,24 +2983,76 @@
       /* setenv client real IP address */
       setenv_untrusted (session);
 
+#ifdef PLUGIN_DEF_AUTH
+      /* generate filename for deferred auth control file */
+      key_state_gen_auth_control_file (ks, session->opt);
+#endif
+
       /* call command */
       retval = plugin_call (session->opt->plugins, OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY, NULL, NULL, session->opt->es);
 
-      if (!retval)
-	ret = true;
+#ifdef PLUGIN_DEF_AUTH
+      /* purge auth control filename (and file itself) for non-deferred returns */
+      if (retval != OPENVPN_PLUGIN_FUNC_DEFERRED)
+	key_state_rm_auth_control_file (ks);
+#endif
 
       setenv_del (session->opt->es, "password");
       setenv_str (session->opt->es, "username", up->username);
     }
   else
     {
-      msg (D_TLS_ERRORS, "TLS Auth Error: peer provided a blank username");
+      msg (D_TLS_ERRORS, "TLS Auth Error (verify_user_pass_plugin): peer provided a blank username");
     }
 
-  return ret;
+  return retval;
 }
 
 /*
+ * MANAGEMENT_DEF_AUTH internal ssl.c status codes
+ */
+#define KMDA_ERROR   0
+#define KMDA_SUCCESS 1
+#define KMDA_UNDEF   2
+#define KMDA_DEF     3
+
+#ifdef MANAGEMENT_DEF_AUTH
+static int
+verify_user_pass_management (struct tls_session *session, const struct user_pass *up, const char *raw_username)
+{
+  int retval = KMDA_ERROR;
+
+  /* Is username defined? */
+  if (strlen (up->username))
+    {
+      /* set username/password in private env space */
+      setenv_str (session->opt->es, "username", raw_username);
+      setenv_str (session->opt->es, "password", up->password);
+
+      /* setenv incoming cert common name for script */
+      setenv_str (session->opt->es, "common_name", session->common_name);
+
+      /* setenv client real IP address */
+      setenv_untrusted (session);
+
+      if (management)
+	management_notify_client_needing_auth (management, ks->mda_key_id, session->opt->mda_context, session->opt->es);
+
+      setenv_del (session->opt->es, "password");
+      setenv_str (session->opt->es, "username", up->username);
+
+      retval = KMDA_SUCCESS;
+    }
+  else
+    {
+      msg (D_TLS_ERRORS, "TLS Auth Error (verify_user_pass_management): peer provided a blank username");
+    }
+
+  return retval;
+}
+#endif
+
+/*
  * Handle the reading and writing of key data to and from
  * the TLS control channel (cleartext).
  */
@@ -3006,6 +3228,13 @@
   char *options;
   struct user_pass *up;
 
+  bool man_def_auth = KMDA_UNDEF;
+
+#ifdef MANAGEMENT_DEF_AUTH
+  if (management_enable_def_auth (management))
+    man_def_auth = KMDA_DEF;
+#endif
+
   ASSERT (session->opt->key_method == 2);
 
   /* allocate temporary objects */
@@ -3041,9 +3270,10 @@
   /* should we check username/password? */
   ks->authenticated = false;
   if (session->opt->auth_user_pass_verify_script
-      || plugin_defined (session->opt->plugins, OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY))
+      || plugin_defined (session->opt->plugins, OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY)
+      || man_def_auth == KMDA_DEF)
     {
-      bool s1 = true;
+      int s1 = OPENVPN_PLUGIN_FUNC_SUCCESS;
       bool s2 = true;
       char *raw_username;
 
@@ -3067,18 +3297,43 @@
       string_mod (up->password, CC_PRINT, CC_CRLF, '_');
 
       /* call plugin(s) and/or script */
+#ifdef MANAGEMENT_DEF_AUTH
+      if (man_def_auth == KMDA_DEF)
+	man_def_auth = verify_user_pass_management (session, up, raw_username);
+#endif
       if (plugin_defined (session->opt->plugins, OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY))
 	s1 = verify_user_pass_plugin (session, up, raw_username);
       if (session->opt->auth_user_pass_verify_script)
 	s2 = verify_user_pass_script (session, up);
-      
+
+      /* check sizing of username if it will become our common name */
+      if (session->opt->username_as_common_name && strlen (up->username) >= TLS_CN_LEN)
+	{
+	  msg (D_TLS_ERRORS, "TLS Auth Error: --username-as-common name specified and username is longer than the maximum permitted Common Name length of %d characters", TLS_CN_LEN);
+	  s1 = OPENVPN_PLUGIN_FUNC_ERROR;
+	}
+
       /* auth succeeded? */
-      if (s1 && s2)
+      if ((s1 == OPENVPN_PLUGIN_FUNC_SUCCESS
+#ifdef PLUGIN_DEF_AUTH
+	   || s1 == OPENVPN_PLUGIN_FUNC_DEFERRED
+#endif
+	   ) && s2 && man_def_auth != KMDA_ERROR)
 	{
 	  ks->authenticated = true;
+#ifdef PLUGIN_DEF_AUTH
+	  if (s1 == OPENVPN_PLUGIN_FUNC_DEFERRED)
+	    ks->auth_deferred = true;
+#endif
+#ifdef MANAGEMENT_DEF_AUTH
+	  if (man_def_auth != KMDA_UNDEF)
+	    ks->auth_deferred = true;
+#endif
+	    
 	  if (session->opt->username_as_common_name)
 	    set_common_name (session, up->username);
-	  msg (D_HANDSHAKE, "TLS: Username/Password authentication succeeded for username '%s' %s",
+	  msg (D_HANDSHAKE, "TLS: Username/Password authentication %s for username '%s' %s",
+	       s1 == OPENVPN_PLUGIN_FUNC_SUCCESS ? "succeeded" : "deferred",
 	       up->username,
 	       session->opt->username_as_common_name ? "[CN SET]" : "");
 	}
@@ -3151,7 +3406,7 @@
    */
   if (ks->authenticated && plugin_defined (session->opt->plugins, OPENVPN_PLUGIN_TLS_FINAL))
     {
-      if (plugin_call (session->opt->plugins, OPENVPN_PLUGIN_TLS_FINAL, NULL, NULL, session->opt->es))
+      if (plugin_call (session->opt->plugins, OPENVPN_PLUGIN_TLS_FINAL, NULL, NULL, session->opt->es) != OPENVPN_PLUGIN_FUNC_SUCCESS)
 	ks->authenticated = false;
     }
 
@@ -3264,7 +3519,7 @@
 	      buf = reliable_get_buf_output_sequenced (ks->send_reliable);
 	      if (buf)
 		{
-		  ks->must_negotiate = now + session->opt->handshake_window;
+		  ks->auth_deferred_expire = ks->must_negotiate = now + session->opt->handshake_window;
 
 		  /* null buffer */
 		  reliable_mark_active_outgoing (ks->send_reliable, buf, ks->initial_opcode);
@@ -3589,7 +3844,7 @@
  * the active or untrusted sessions.
  */
 
-bool
+int
 tls_multi_process (struct tls_multi *multi,
 		   struct buffer *to_link,
 		   struct link_socket_actual **to_link_addr,
@@ -3598,8 +3853,9 @@
 {
   struct gc_arena gc = gc_new ();
   int i;
-  bool active = false;
+  int active = TLSMP_INACTIVE;
   bool error = false;
+  int tas;
 
   perf_push (PERF_TLS_MULTI_PROCESS);
 
@@ -3637,7 +3893,7 @@
 
 	  if (tls_process (multi, session, to_link, &tla,
 			   to_link_socket_info, wakeup))
-	    active = true;
+	    active = TLSMP_ACTIVE;
 
 	  /*
 	   * If tls_process produced an outgoing packet,
@@ -3676,6 +3932,8 @@
 
   update_time ();
 
+  tas = tls_authentication_status (multi, TLS_MULTI_AUTH_STATUS_INTERVAL);
+
   /*
    * If lame duck session expires, kill it.
    */
@@ -3696,7 +3954,7 @@
   if (DECRYPT_KEY_ENABLED (multi, &multi->session[TM_UNTRUSTED].key[KS_PRIMARY])) {
     move_session (multi, TM_ACTIVE, TM_UNTRUSTED, true);
     msg (D_TLS_DEBUG_LOW, "TLS: tls_multi_process: untrusted session promoted to %strusted",
-	 tls_authenticated (multi) ? "" : "semi-");
+	 tas == TLS_AUTHENTICATION_SUCCEEDED ? "" : "semi-");
   }
 
   /*
@@ -3734,7 +3992,8 @@
 
   perf_pop ();
   gc_free (&gc);
-  return active;
+
+  return (tas == TLS_AUTHENTICATION_FAILED) ? TLSMP_KILL : active;
 }
 
 /*
@@ -3811,6 +4070,9 @@
 	      if (DECRYPT_KEY_ENABLED (multi, ks)
 		  && key_id == ks->key_id
 		  && ks->authenticated
+#ifdef ENABLE_DEF_AUTH
+		  && !ks->auth_deferred
+#endif
 		  && link_socket_actual_match (from, &ks->remote_addr))
 		{
 		  /* return appropriate data channel decrypt key in opt */
@@ -3831,13 +4093,18 @@
 #if 0 /* keys out of sync? */
 	      else
 		{
-		  dmsg (D_TLS_DEBUG, "TLS_PRE_DECRYPT: [%d] dken=%d rkid=%d lkid=%d auth=%d match=%d",
-		       i,
-		       DECRYPT_KEY_ENABLED (multi, ks),
-		       key_id,
-		       ks->key_id,
-		       ks->authenticated,
-		       link_socket_actual_match (from, &ks->remote_addr));
+		  dmsg (D_TLS_ERRORS, "TLS_PRE_DECRYPT: [%d] dken=%d rkid=%d lkid=%d auth=%d def=%d match=%d",
+			i,
+			DECRYPT_KEY_ENABLED (multi, ks),
+			key_id,
+			ks->key_id,
+			ks->authenticated,
+#ifdef ENABLE_DEF_AUTH
+			ks->auth_deferred,
+#else
+			-1,
+#endif
+			link_socket_actual_match (from, &ks->remote_addr));
 		}
 #endif
 	    }
@@ -3845,7 +4112,7 @@
 	  msg (D_TLS_ERRORS,
 	       "TLS Error: local/remote TLS keys are out of sync: %s [%d]",
 	       print_link_socket_actual (from, &gc), key_id);
-	  goto error;
+	  goto error_lite;
 	}
       else			  /* control channel packet */
 	{
@@ -4198,8 +4465,9 @@
   return ret;
 
  error:
-  ERR_clear_error ();
   ++multi->n_soft_errors;
+ error_lite:
+  ERR_clear_error ();
   goto done;
 }
 
@@ -4327,7 +4595,12 @@
       for (i = 0; i < KEY_SCAN_SIZE; ++i)
 	{
 	  struct key_state *ks = multi->key_scan[i];
-	  if (ks->state >= S_ACTIVE && ks->authenticated)
+	  if (ks->state >= S_ACTIVE
+	      && ks->authenticated
+#ifdef ENABLE_DEF_AUTH
+	      && !ks->auth_deferred
+#endif
+	      && (!ks->key_id || now >= ks->auth_deferred_expire))
 	    {
 	      opt->key_ctx_bi = &ks->key;
 	      opt->packet_id = multi->opt.replay ? &ks->packet_id : NULL;
@@ -4531,25 +4804,6 @@
   return BSTR (&out);
 }
 
-#ifdef EXTRACT_X509_FIELD_TEST
-
-void
-extract_x509_field_test (void)
-{
-  char line[8];
-  char field[4];
-  static const char field_name[] = "CN";
-
-  while (fgets (line, sizeof (line), stdin))
-    {
-      chomp (line);
-      extract_x509_field (line, field_name, field, sizeof (field));
-      printf ("CN: '%s'\n", field);
-    }
-}
-
-#endif
-
 #else
 static void dummy(void) {}
 #endif /* USE_CRYPTO && USE_SSL*/
diff -urN openvpn-2.1_rc7/ssl.h openvpn-2.1_rc9/ssl.h
--- openvpn-2.1_rc7/ssl.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/ssl.h	2008-07-27 02:39:03.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -271,6 +271,9 @@
    communication pipe to the main thread to be ready to accept writes. */
 #define TLS_MULTI_THREAD_SEND_TIMEOUT 5
 
+/* Interval that tls_multi_process should call tls_authentication_status */
+#define TLS_MULTI_AUTH_STATUS_INTERVAL 10
+
 /*
  * Buffer sizes (also see mtu.h).
  */
@@ -367,6 +370,21 @@
    * If bad username/password, TLS connection will come up but 'authenticated' will be false.
    */
   bool authenticated;
+  time_t auth_deferred_expire;
+
+#ifdef ENABLE_DEF_AUTH
+  /* If auth_deferred is true, authentication is being deferred */
+  bool auth_deferred;
+#ifdef MANAGEMENT_DEF_AUTH
+  unsigned int mda_key_id;
+  unsigned int mda_status;
+#endif
+#ifdef PLUGIN_DEF_AUTH
+  unsigned int auth_control_status;
+  time_t acf_last_mod;
+  char *auth_control_file;
+#endif
+#endif
 };
 
 /*
@@ -447,6 +465,10 @@
   struct env_set *es;
   const struct plugin_list *plugins;
 
+#ifdef MANAGEMENT_DEF_AUTH
+  struct man_def_auth_context *mda_context;
+#endif
+
   /* --gremlin bits */
   int gremlin;
 };
@@ -490,6 +512,11 @@
   int verify_maxlevel;
 
   char *common_name;
+
+#ifdef ENABLE_PF
+  uint32_t common_name_hashval;
+#endif
+
   bool verified;                /* true if peer certificate was verified against CA */
 
   /* not-yet-authenticated incoming client */
@@ -561,6 +588,11 @@
    */
   char *locked_cn;
 
+#ifdef ENABLE_DEF_AUTH
+  /* Time of last call to tls_authentication_status */
+  time_t tas_last;
+#endif
+
   /*
    * Our session objects.
    */
@@ -599,11 +631,14 @@
 				const char *local,
 				const char *remote);
 
-bool tls_multi_process (struct tls_multi *multi,
-			struct buffer *to_link,
-			struct link_socket_actual **to_link_addr,
-			struct link_socket_info *to_link_socket_info,
-			interval_t *wakeup);
+#define TLSMP_INACTIVE 0
+#define TLSMP_ACTIVE   1
+#define TLSMP_KILL     2
+int tls_multi_process (struct tls_multi *multi,
+		       struct buffer *to_link,
+		       struct link_socket_actual **to_link_addr,
+		       struct link_socket_info *to_link_socket_info,
+		       interval_t *wakeup);
 
 void tls_multi_free (struct tls_multi *multi, bool clear);
 
@@ -643,17 +678,36 @@
 bool tls_rec_payload (struct tls_multi *multi,
 		      struct buffer *buf);
 
-const char *tls_common_name (struct tls_multi* multi, bool null);
+const char *tls_common_name (const struct tls_multi* multi, const bool null);
 void tls_set_common_name (struct tls_multi *multi, const char *common_name);
 void tls_lock_common_name (struct tls_multi *multi);
 
-bool tls_authenticated (struct tls_multi *multi);
+#define TLS_AUTHENTICATION_SUCCEEDED  0
+#define TLS_AUTHENTICATION_FAILED     1
+#define TLS_AUTHENTICATION_DEFERRED   2
+#define TLS_AUTHENTICATION_UNDEFINED  3
+int tls_authentication_status (struct tls_multi *multi, const int latency);
 void tls_deauthenticate (struct tls_multi *multi);
 
+#ifdef MANAGEMENT_DEF_AUTH
+bool tls_authenticate_key (struct tls_multi *multi, const unsigned int mda_key_id, const bool auth);
+#endif
+
 /*
  * inline functions
  */
 
+static inline bool
+tls_test_auth_deferred_interval (const struct tls_multi *multi)
+{
+  if (multi)
+    {
+      const struct key_state *ks = &multi->session[TM_ACTIVE].key[KS_PRIMARY];
+      return now < ks->auth_deferred_expire;
+    }
+  return false;
+}
+
 static inline int
 tls_test_payload_len (const struct tls_multi *multi)
 {
@@ -673,6 +727,26 @@
     multi->opt.single_session = true;
 }
 
+#ifdef ENABLE_PF
+
+static inline bool
+tls_common_name_hash (const struct tls_multi *multi, const char **cn, uint32_t *cn_hash)
+{
+  if (multi)
+    {
+      const struct tls_session *s = &multi->session[TM_ACTIVE];
+      if (s->common_name && s->common_name[0] != '\0')
+	{
+	  *cn = s->common_name;
+	  *cn_hash = s->common_name_hashval;
+	  return true;
+	}
+    }
+  return false;
+}
+
+#endif
+
 /*
  * protocol_dump() flags
  */
diff -urN openvpn-2.1_rc7/status.c openvpn-2.1_rc9/status.c
--- openvpn-2.1_rc7/status.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/status.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "status.h"
@@ -218,7 +212,7 @@
   return ret;
 }
 
-#define STATUS_PRINTF_MAXLEN 256
+#define STATUS_PRINTF_MAXLEN 512
 
 void
 status_printf (struct status_output *so, const char *format, ...)
@@ -227,28 +221,32 @@
     {
       char buf[STATUS_PRINTF_MAXLEN+2]; /* leave extra bytes for CR, LF */
       va_list arglist;
+      int stat;
 
       va_start (arglist, format);
-      vsnprintf (buf, STATUS_PRINTF_MAXLEN, format, arglist);
+      stat = vsnprintf (buf, STATUS_PRINTF_MAXLEN, format, arglist);
       va_end (arglist);
       buf[STATUS_PRINTF_MAXLEN - 1] = 0;
 
-      if (so->msglevel >= 0)
+      if (stat < 0 || stat >= STATUS_PRINTF_MAXLEN)
+	so->errors = true;
+
+      if (so->msglevel >= 0 && !so->errors)
 	msg (so->msglevel, "%s", buf);
 
-      if (so->fd >= 0)
+      if (so->fd >= 0 && !so->errors)
 	{
 	  int len;
 	  strcat (buf, "\n");
 	  len = strlen (buf);
 	  if (len > 0)
 	    {
-	      if (write (so->fd, buf, len) < 0)
+	      if (write (so->fd, buf, len) != len)
 		so->errors = true;
 	    }
 	}
 
-      if (so->vout)
+      if (so->vout && !so->errors)
 	{
 	  chomp (buf);
 	  (*so->vout->func) (so->vout->arg, so->vout->flags_default, buf);
diff -urN openvpn-2.1_rc7/status.h openvpn-2.1_rc9/status.h
--- openvpn-2.1_rc7/status.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/status.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/syshead.h openvpn-2.1_rc9/syshead.h
--- openvpn-2.1_rc7/syshead.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/syshead.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -25,6 +25,37 @@
 #ifndef SYSHEAD_H
 #define SYSHEAD_H
 
+/*
+ * Only include if not during configure
+ */
+#ifndef PACKAGE_NAME
+#ifdef _MSC_VER
+#include "config-win32.h"
+#else
+#include "config.h"
+#endif
+#endif
+
+/* branch prediction hints */
+#if defined(__GNUC__)
+# define likely(x)       __builtin_expect((x),1)
+# define unlikely(x)     __builtin_expect((x),0)
+#else
+# define likely(x)      (x)
+# define unlikely(x)    (x)
+#endif
+
+#if defined(_WIN32) && !defined(WIN32)
+#define WIN32
+#endif
+
+#ifdef WIN32
+#include <windows.h>
+#define sleep(x) Sleep((x)*1000)
+#define random rand
+#define srandom srand
+#endif
+
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
@@ -133,6 +164,10 @@
 #include <netinet/in.h>
 #endif
 
+#ifdef HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+
 #ifdef HAVE_SYS_POLL_H
 #include <sys/poll.h>
 #endif
@@ -272,9 +307,29 @@
 
 #endif /* TARGET_NETBSD */
 
+#ifdef TARGET_DRAGONFLY
+
+#ifdef HAVE_SYS_UIO_H
+#include <sys/uio.h>
+#endif
+
+#ifdef HAVE_NETINET_IN_SYSTM_H
+#include <netinet/in_systm.h>
+#endif
+
+#ifdef HAVE_NETINET_IP_H
+#include <netinet/ip.h>
+#endif
+
+#ifdef HAVE_NET_TUN_IF_TUN_H
+#include <net/tun/if_tun.h>
+#endif
+
+#endif /* TARGET_DRAGONFLY */
+
 #ifdef WIN32
 #include <iphlpapi.h>
-#include <WinInet.h>
+#include <wininet.h>
 #endif
 
 #ifdef HAVE_SYS_MMAN_H
@@ -393,6 +448,14 @@
 #define USE_64_BIT_COUNTERS
 
 /*
+ * Should we enable the use of execve() for calling subprocesses,
+ * instead of system()?
+ */
+#if defined(HAVE_EXECVE) && defined(HAVE_FORK)
+#define ENABLE_EXECVE
+#endif
+
+/*
  * Do we have point-to-multipoint capability?
  */
 
@@ -425,6 +488,41 @@
 #endif
 
 /*
+ * Enable deferred authentication?
+ */
+#define CONFIGURE_DEF_AUTH /* this should be set by autoconf and config.h */
+#if defined(CONFIGURE_DEF_AUTH) && P2MP_SERVER && defined(ENABLE_PLUGIN)
+#define PLUGIN_DEF_AUTH
+#endif
+#if defined(CONFIGURE_DEF_AUTH) && P2MP_SERVER && defined(ENABLE_MANAGEMENT)
+#define MANAGEMENT_DEF_AUTH
+#endif
+#if defined(PLUGIN_DEF_AUTH) || defined(MANAGEMENT_DEF_AUTH)
+#define ENABLE_DEF_AUTH
+#endif
+
+/*
+ * Enable packet filter?
+ */
+#define CONFIGURE_PF /* this should be set by autoconf and config.h */
+#if defined(CONFIGURE_PF) && P2MP_SERVER && defined(ENABLE_PLUGIN) && defined(HAVE_STAT)
+#define PLUGIN_PF
+#endif
+#if defined(CONFIGURE_PF) && P2MP_SERVER && defined(MANAGEMENT_DEF_AUTH)
+#define MANAGEMENT_PF
+#endif
+#if defined(PLUGIN_PF) || defined(MANAGEMENT_PF)
+#define ENABLE_PF
+#endif
+
+/*
+ * Don't compile the struct buffer_list code unless something needs it
+ */
+#if defined(ENABLE_MANAGEMENT) || defined(ENABLE_PF)
+#define ENABLE_BUFFER_LIST
+#endif
+
+/*
  * Do we have pthread capability?
  */
 #ifdef USE_PTHREAD
@@ -524,4 +622,11 @@
 #define AUTO_USERID 0
 #endif
 
+/*
+ * Support "connection" directive
+ */
+#if ENABLE_INLINE_FILES
+#define ENABLE_CONNECTION 1
+#endif
+
 #endif
diff -urN openvpn-2.1_rc7/tap-win32/common.h openvpn-2.1_rc9/tap-win32/common.h
--- openvpn-2.1_rc7/tap-win32/common.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/common.h	2008-07-14 20:37:56.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
@@ -32,7 +32,15 @@
 // common to both.
 //===============================================
 
-#include "../autodefs/defs.h"
+#if defined(HAVE_CONFIG_H)
+#include "config.h"
+#else
+#if defined(_MSC_VER) && !defined(TAP_DRIVER_MAJOR_VERSION)
+#include "config-win32.h"
+#else
+#include "../config.h"
+#endif
+#endif
 
 //=============
 // TAP IOCTLs
@@ -81,4 +89,4 @@
 // simultaneously.
 //=========================================================
 
-#define TAP_COMPONENT_ID PRODUCT_TAP_ID
+#define TAP_COMPONENT_ID TAP_ID
diff -urN openvpn-2.1_rc7/tap-win32/constants.h openvpn-2.1_rc9/tap-win32/constants.h
--- openvpn-2.1_rc7/tap-win32/constants.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/constants.h	2008-07-14 20:37:56.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/dhcp.c openvpn-2.1_rc9/tap-win32/dhcp.c
--- openvpn-2.1_rc7/tap-win32/dhcp.c	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/dhcp.c	2008-07-14 20:37:56.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/dhcp.h openvpn-2.1_rc9/tap-win32/dhcp.h
--- openvpn-2.1_rc7/tap-win32/dhcp.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/dhcp.h	2008-07-14 20:37:56.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/endian.h openvpn-2.1_rc9/tap-win32/endian.h
--- openvpn-2.1_rc7/tap-win32/endian.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/endian.h	2008-07-14 20:37:56.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/error.c openvpn-2.1_rc9/tap-win32/error.c
--- openvpn-2.1_rc7/tap-win32/error.c	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/error.c	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/error.h openvpn-2.1_rc9/tap-win32/error.h
--- openvpn-2.1_rc7/tap-win32/error.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/error.h	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/hexdump.c openvpn-2.1_rc9/tap-win32/hexdump.c
--- openvpn-2.1_rc7/tap-win32/hexdump.c	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/hexdump.c	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/hexdump.h openvpn-2.1_rc9/tap-win32/hexdump.h
--- openvpn-2.1_rc7/tap-win32/hexdump.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/hexdump.h	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/i386/OemWin2k.inf.in openvpn-2.1_rc9/tap-win32/i386/OemWin2k.inf.in
--- openvpn-2.1_rc7/tap-win32/i386/OemWin2k.inf.in	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/i386/OemWin2k.inf.in	2008-07-14 20:37:57.000000000 +0200
@@ -1,5 +1,5 @@
 ; ****************************************************************************
-; * Copyright (C) 2002-2006 OpenVPN Solutions LLC                            *
+; * Copyright (C) 2002-2008 Telethra, Inc.                            *
 ; *  This program is free software; you can redistribute it and/or modify    *
 ; *  it under the terms of the GNU General Public License version 2          *
 ; *  as published by the Free Software Foundation.                           *
diff -urN openvpn-2.1_rc7/tap-win32/instance.c openvpn-2.1_rc9/tap-win32/instance.c
--- openvpn-2.1_rc7/tap-win32/instance.c	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/instance.c	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/lock.h openvpn-2.1_rc9/tap-win32/lock.h
--- openvpn-2.1_rc7/tap-win32/lock.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/lock.h	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/macinfo.c openvpn-2.1_rc9/tap-win32/macinfo.c
--- openvpn-2.1_rc7/tap-win32/macinfo.c	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/macinfo.c	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/macinfo.h openvpn-2.1_rc9/tap-win32/macinfo.h
--- openvpn-2.1_rc7/tap-win32/macinfo.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/macinfo.h	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/mem.c openvpn-2.1_rc9/tap-win32/mem.c
--- openvpn-2.1_rc7/tap-win32/mem.c	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/mem.c	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/proto.h openvpn-2.1_rc9/tap-win32/proto.h
--- openvpn-2.1_rc7/tap-win32/proto.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/proto.h	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/prototypes.h openvpn-2.1_rc9/tap-win32/prototypes.h
--- openvpn-2.1_rc7/tap-win32/prototypes.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/prototypes.h	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/resource.rc openvpn-2.1_rc9/tap-win32/resource.rc
--- openvpn-2.1_rc7/tap-win32/resource.rc	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/resource.rc	2008-07-14 20:37:57.000000000 +0200
@@ -37,7 +37,7 @@
 #define VER_FILEDESCRIPTION_STR     "TAP-Win32 Virtual Network Driver"
 #define VER_ORIGINALFILENAME_STR    TAP_COMPONENT_ID ".sys"
 #define VER_LEGALCOPYRIGHT_YEARS    "2003-2006"
-#define VER_LEGALCOPYRIGHT_STR      "OpenVPN Solutions LLC and Damion K. Wilson"
+#define VER_LEGALCOPYRIGHT_STR      "Telethra, Inc."
 
 
 #define VER_PRODUCTNAME_STR         VER_FILEDESCRIPTION_STR
diff -urN openvpn-2.1_rc7/tap-win32/tapdrvr.c openvpn-2.1_rc9/tap-win32/tapdrvr.c
--- openvpn-2.1_rc7/tap-win32/tapdrvr.c	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/tapdrvr.c	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/tap-win32/types.h openvpn-2.1_rc9/tap-win32/types.h
--- openvpn-2.1_rc7/tap-win32/types.h	2008-01-23 22:08:40.000000000 +0100
+++ openvpn-2.1_rc9/tap-win32/types.h	2008-07-14 20:37:57.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2007 OpenVPN Solutions LLC,
+ *  This source code is Copyright (C) 2002-2008 Telethra, Inc.,
  *  and is released under the GPL version 2 (see below), however due
  *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
  *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
diff -urN openvpn-2.1_rc7/thread.c openvpn-2.1_rc9/thread.c
--- openvpn-2.1_rc7/thread.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/thread.c	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -22,12 +22,6 @@
  *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #ifdef USE_PTHREAD
diff -urN openvpn-2.1_rc7/thread.h openvpn-2.1_rc9/thread.h
--- openvpn-2.1_rc7/thread.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/thread.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/tun.c openvpn-2.1_rc9/tun.c
--- openvpn-2.1_rc7/tun.c	2008-01-26 05:39:13.000000000 +0100
+++ openvpn-2.1_rc9/tun.c	2008-07-26 23:50:04.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -30,12 +30,6 @@
  * from VTun by Maxim Krasnyansky <max_mk@yahoo.com>.
  */
 
-#ifdef WIN32
-#include "config-win32.h"
-#else
-#include "config.h"
-#endif
-
 #include "syshead.h"
 
 #include "tun.h"
@@ -45,6 +39,7 @@
 #include "socket.h"
 #include "manage.h"
 #include "route.h"
+#include "win32.h"
 
 #include "memdbg.h"
 
@@ -540,7 +535,9 @@
       const char *ifconfig_local = NULL;
       const char *ifconfig_remote_netmask = NULL;
       const char *ifconfig_broadcast = NULL;
-      char command_line[256];
+      struct argv argv;
+
+      argv_init (&argv);
 
       /*
        * We only handle TUN/TAP devices here, not --dev null devices.
@@ -576,31 +573,31 @@
 	/*
 	 * Set the MTU for the device
 	 */
-	openvpn_snprintf (command_line, sizeof (command_line),
+	argv_printf (&argv,
 			  "%s link set dev %s up mtu %d",
 			  iproute_path,
 			  actual,
 			  tun_mtu
 			  );
-	  msg (M_INFO, "%s", command_line);
-	  system_check (command_line, es, S_FATAL, "Linux ip link set failed");
+	  argv_msg (M_INFO, &argv);
+	  openvpn_execve_check (&argv, es, S_FATAL, "Linux ip link set failed");
 
 	if (tun) {
 
 		/*
 		 * Set the address for the device
 		 */
-		openvpn_snprintf (command_line, sizeof (command_line),
+		argv_printf (&argv,
 				  "%s addr add dev %s local %s peer %s",
 				  iproute_path,
 				  actual,
 				  ifconfig_local,
 				  ifconfig_remote_netmask
 				  );
-		  msg (M_INFO, "%s", command_line);
-		  system_check (command_line, es, S_FATAL, "Linux ip addr add failed");
+		  argv_msg (M_INFO, &argv);
+		  openvpn_execve_check (&argv, es, S_FATAL, "Linux ip addr add failed");
 	} else {
-		openvpn_snprintf (command_line, sizeof (command_line),
+		argv_printf (&argv,
 				  "%s addr add dev %s %s/%d broadcast %s",
 				  iproute_path,
 				  actual,
@@ -608,30 +605,32 @@
 				  count_netmask_bits(ifconfig_remote_netmask),
 				  ifconfig_broadcast
 				  );
-		  msg (M_INFO, "%s", command_line);
-		  system_check (command_line, es, S_FATAL, "Linux ip addr add failed");
+		  argv_msg (M_INFO, &argv);
+		  openvpn_execve_check (&argv, es, S_FATAL, "Linux ip addr add failed");
 	}
 	tt->did_ifconfig = true;
 #else
       if (tun)
-	openvpn_snprintf (command_line, sizeof (command_line),
-			  IFCONFIG_PATH " %s %s pointopoint %s mtu %d",
+	argv_printf (&argv,
+			  "%s %s %s pointopoint %s mtu %d",
+			  IFCONFIG_PATH,
 			  actual,
 			  ifconfig_local,
 			  ifconfig_remote_netmask,
 			  tun_mtu
 			  );
       else
-	openvpn_snprintf (command_line, sizeof (command_line),
-			  IFCONFIG_PATH " %s %s netmask %s mtu %d broadcast %s",
+	argv_printf (&argv,
+			  "%s %s %s netmask %s mtu %d broadcast %s",
+			  IFCONFIG_PATH,
 			  actual,
 			  ifconfig_local,
 			  ifconfig_remote_netmask,
 			  tun_mtu,
 			  ifconfig_broadcast
 			  );
-      msg (M_INFO, "%s", command_line);
-      system_check (command_line, es, S_FATAL, "Linux ifconfig failed");
+      argv_msg (M_INFO, &argv);
+      openvpn_execve_check (&argv, es, S_FATAL, "Linux ifconfig failed");
       tt->did_ifconfig = true;
 
 #endif /*CONFIG_FEATURE_IPROUTE*/
@@ -644,28 +643,30 @@
        */
       if (tun)
 	{
-	  openvpn_snprintf (command_line, sizeof (command_line),
-			    IFCONFIG_PATH " %s %s %s mtu %d up",
+	  argv_printf (&argv,
+			    "%s %s %s %s mtu %d up",
+			    IFCONFIG_PATH,
 			    actual,
 			    ifconfig_local,
 			    ifconfig_remote_netmask,
 			    tun_mtu
 			    );
 
-	  msg (M_INFO, "%s", command_line);
-	  if (!system_check (command_line, es, 0, "Solaris ifconfig phase-1 failed"))
+	  argv_msg (M_INFO, &argv);
+	  if (!openvpn_execve_check (&argv, es, 0, "Solaris ifconfig phase-1 failed"))
 	    solaris_error_close (tt, es, actual);
 
-	  openvpn_snprintf (command_line, sizeof (command_line),
-			    IFCONFIG_PATH " %s netmask 255.255.255.255",
+	  argv_printf (&argv,
+			    "%s %s netmask 255.255.255.255",
+			    IFCONFIG_PATH,
 			    actual
 			    );
 	}
       else
 	no_tap_ifconfig ();
 
-      msg (M_INFO, "%s", command_line);
-      if (!system_check (command_line, es, 0, "Solaris ifconfig phase-2 failed"))
+      argv_msg (M_INFO, &argv);
+      if (!openvpn_execve_check (&argv, es, 0, "Solaris ifconfig phase-2 failed"))
 	solaris_error_close (tt, es, actual);
 
       tt->did_ifconfig = true;
@@ -678,45 +679,50 @@
        * (if it exists), and re-ifconfig.  Let me know if you know a better way.
        */
 
-      openvpn_snprintf (command_line, sizeof (command_line),
-			IFCONFIG_PATH " %s destroy",
+      argv_printf (&argv,
+			"%s %s destroy",
+			IFCONFIG_PATH,
 			actual);
-      msg (M_INFO, "%s", command_line);
-      system_check (command_line, es, 0, NULL);
-      openvpn_snprintf (command_line, sizeof (command_line),
-			IFCONFIG_PATH " %s create",
+      argv_msg (M_INFO, &argv);
+      openvpn_execve_check (&argv, es, 0, NULL);
+      argv_printf (&argv,
+			"%s %s create",
+			IFCONFIG_PATH,
 			actual);
-      msg (M_INFO, "%s", command_line);
-      system_check (command_line, es, 0, NULL);
+      argv_msg (M_INFO, &argv);
+      openvpn_execve_check (&argv, es, 0, NULL);
       msg (M_INFO, "NOTE: Tried to delete pre-existing tun/tap instance -- No Problem if failure");
 
       /* example: ifconfig tun2 10.2.0.2 10.2.0.1 mtu 1450 netmask 255.255.255.255 up */
       if (tun)
-	openvpn_snprintf (command_line, sizeof (command_line),
-			  IFCONFIG_PATH " %s %s %s mtu %d netmask 255.255.255.255 up",
+	argv_printf (&argv,
+			  "%s %s %s %s mtu %d netmask 255.255.255.255 up",
+			  IFCONFIG_PATH,
 			  actual,
 			  ifconfig_local,
 			  ifconfig_remote_netmask,
 			  tun_mtu
 			  );
       else
-	openvpn_snprintf (command_line, sizeof (command_line),
-			  IFCONFIG_PATH " %s %s netmask %s mtu %d broadcast %s link0",
+	argv_printf (&argv,
+			  "%s %s %s netmask %s mtu %d broadcast %s link0",
+			  IFCONFIG_PATH,
 			  actual,
 			  ifconfig_local,
 			  ifconfig_remote_netmask,
 			  tun_mtu,
 			  ifconfig_broadcast
 			  );
-      msg (M_INFO, "%s", command_line);
-      system_check (command_line, es, S_FATAL, "OpenBSD ifconfig failed");
+      argv_msg (M_INFO, &argv);
+      openvpn_execve_check (&argv, es, S_FATAL, "OpenBSD ifconfig failed");
       tt->did_ifconfig = true;
 
 #elif defined(TARGET_NETBSD)
 
       if (tun)
-	openvpn_snprintf (command_line, sizeof (command_line),
-			  IFCONFIG_PATH " %s %s %s mtu %d netmask 255.255.255.255 up",
+	argv_printf (&argv,
+			  "%s %s %s %s mtu %d netmask 255.255.255.255 up",
+			  IFCONFIG_PATH,
 			  actual,
 			  ifconfig_local,
 			  ifconfig_remote_netmask,
@@ -728,16 +734,17 @@
        * so we don't need the "link0" extra parameter to specify we want to do 
        * tunneling at the ethernet level
        */
-		openvpn_snprintf (command_line, sizeof (command_line),
-			  IFCONFIG_PATH " %s %s netmask %s mtu %d broadcast %s",
+		argv_printf (&argv,
+			  "%s %s %s netmask %s mtu %d broadcast %s",
+			  IFCONFIG_PATH,
 			  actual,
 			  ifconfig_local,
 			  ifconfig_remote_netmask,
 			  tun_mtu,
 			  ifconfig_broadcast
 			  );
-      msg (M_INFO, "%s", command_line);
-      system_check (command_line, es, S_FATAL, "NetBSD ifconfig failed");
+      argv_msg (M_INFO, &argv);
+      openvpn_execve_check (&argv, es, S_FATAL, "NetBSD ifconfig failed");
       tt->did_ifconfig = true;
 
 #elif defined(TARGET_DARWIN)
@@ -746,18 +753,20 @@
        * Darwin (i.e. Mac OS X) seems to exhibit similar behaviour to OpenBSD...
        */
 
-      openvpn_snprintf (command_line, sizeof (command_line),
-			IFCONFIG_PATH " %s delete",
+      argv_printf (&argv,
+			"%s %s delete",
+			IFCONFIG_PATH,
 			actual);
-      msg (M_INFO, "%s", command_line);
-      system_check (command_line, es, 0, NULL);
+      argv_msg (M_INFO, &argv);
+      openvpn_execve_check (&argv, es, 0, NULL);
       msg (M_INFO, "NOTE: Tried to delete pre-existing tun/tap instance -- No Problem if failure");
 
 
       /* example: ifconfig tun2 10.2.0.2 10.2.0.1 mtu 1450 netmask 255.255.255.255 up */
       if (tun)
-	openvpn_snprintf (command_line, sizeof (command_line),
-			  IFCONFIG_PATH " %s %s %s mtu %d netmask 255.255.255.255 up",
+	argv_printf (&argv,
+			  "%s %s %s %s mtu %d netmask 255.255.255.255 up",
+			  IFCONFIG_PATH,
 			  actual,
 			  ifconfig_local,
 			  ifconfig_remote_netmask,
@@ -766,8 +775,9 @@
       else
         {
           if (tt->topology == TOP_SUBNET)
-    	    openvpn_snprintf (command_line, sizeof (command_line),
-			      IFCONFIG_PATH " %s %s %s netmask %s mtu %d up",
+    	    argv_printf (&argv,
+			      "%s %s %s %s netmask %s mtu %d up",
+			      IFCONFIG_PATH,
 			      actual,
 			      ifconfig_local,
 			      ifconfig_local,
@@ -775,16 +785,17 @@
 			      tun_mtu
 			      );
 	  else
-    	    openvpn_snprintf (command_line, sizeof (command_line),
-			      IFCONFIG_PATH " %s %s netmask %s mtu %d up",
+    	    argv_printf (&argv,
+			      "%s %s %s netmask %s mtu %d up",
+			      IFCONFIG_PATH,
 			      actual,
 			      ifconfig_local,
 			      ifconfig_remote_netmask,
 			      tun_mtu
 			      );
 	}
-      msg (M_INFO, "%s", command_line);
-      system_check (command_line, es, S_FATAL, "Mac OS X ifconfig failed");
+      argv_msg (M_INFO, &argv);
+      openvpn_execve_check (&argv, es, S_FATAL, "Mac OS X ifconfig failed");
       tt->did_ifconfig = true;
 
       /* Add a network route for the local tun interface */
@@ -799,12 +810,13 @@
 	  add_route (&r, tt, 0, es);
 	}
 
-#elif defined(TARGET_FREEBSD)
+#elif defined(TARGET_FREEBSD)||defined(TARGET_DRAGONFLY)
 
       /* example: ifconfig tun2 10.2.0.2 10.2.0.1 mtu 1450 netmask 255.255.255.255 up */
       if (tun)
-	openvpn_snprintf (command_line, sizeof (command_line),
-			  IFCONFIG_PATH " %s %s %s mtu %d netmask 255.255.255.255 up",
+	argv_printf (&argv,
+			  "%s %s %s %s mtu %d netmask 255.255.255.255 up",
+			  IFCONFIG_PATH,
 			  actual,
 			  ifconfig_local,
 			  ifconfig_remote_netmask,
@@ -812,8 +824,9 @@
 			  );
       else {
 	if (tt->topology == TOP_SUBNET)
-            openvpn_snprintf (command_line, sizeof (command_line),
-                              IFCONFIG_PATH " %s %s %s netmask %s mtu %d up",
+            argv_printf (&argv,
+                              "%s %s %s %s netmask %s mtu %d up",
+                              IFCONFIG_PATH,
                               actual,
                               ifconfig_local,
                               ifconfig_local,
@@ -821,8 +834,9 @@
                               tun_mtu
                               );
 	else
-  	    openvpn_snprintf (command_line, sizeof (command_line),
-			  IFCONFIG_PATH " %s %s netmask %s mtu %d up",
+  	    argv_printf (&argv,
+			  "%s %s %s netmask %s mtu %d up",
+			  IFCONFIG_PATH,
 			  actual,
 			  ifconfig_local,
 			  ifconfig_remote_netmask,
@@ -830,8 +844,8 @@
 			  );
       }
 	
-      msg (M_INFO, "%s", command_line);
-      system_check (command_line, es, S_FATAL, "FreeBSD ifconfig failed");
+      argv_msg (M_INFO, &argv);
+      openvpn_execve_check (&argv, es, S_FATAL, "FreeBSD ifconfig failed");
       tt->did_ifconfig = true;
 
 	/* Add a network route for the local tun interface */
@@ -888,6 +902,7 @@
 #else
       msg (M_FATAL, "Sorry, but I don't know how to do 'ifconfig' commands on this operating system.  You should ifconfig your TUN/TAP device manually or use an --up script.");
 #endif
+      argv_reset (&argv);
     }
   gc_free (&gc);
 }
@@ -1220,26 +1235,47 @@
 {
   if (tt)
     {
-#ifdef CONFIG_FEATURE_IPROUTE
 	if (tt->type != DEV_TYPE_NULL && tt->did_ifconfig)
 	  {
-	    char command_line[256];
+	    struct argv argv;
 	    struct gc_arena gc = gc_new ();
+	    argv_init (&argv);
 
-	    openvpn_snprintf (command_line, sizeof (command_line),
-			  "%s addr del dev %s local %s peer %s",
-			  iproute_path,
-			  tt->actual_name,
-			  print_in_addr_t (tt->local, 0, &gc),
-			  print_in_addr_t (tt->remote_netmask, 0, &gc)
-			  );
+#ifdef CONFIG_FEATURE_IPROUTE
+	    if (is_tun_p2p (tt))
+	      {
+		argv_printf (&argv,
+			"%s addr del dev %s local %s peer %s",
+			iproute_path,
+			tt->actual_name,
+			print_in_addr_t (tt->local, 0, &gc),
+			print_in_addr_t (tt->remote_netmask, 0, &gc)
+			);
+	      }
+	    else
+	      {
+		argv_printf (&argv,
+			"%s addr del dev %s %s/%d",
+			iproute_path,
+			tt->actual_name,
+			print_in_addr_t (tt->local, 0, &gc),
+			count_netmask_bits(print_in_addr_t (tt->remote_netmask, 0, &gc))
+			);
+	      }
+#else
+	    argv_printf (&argv,
+			"%s %s 0.0.0.0",
+			IFCONFIG_PATH,
+			tt->actual_name
+			);
+#endif
 
-	    msg (M_INFO, "%s", command_line);
-	    system_check (command_line, NULL, S_FATAL, "Linux ip addr del failed");
+	    argv_msg (M_INFO, &argv);
+	    openvpn_execve_check (&argv, NULL, 0, "Linux ip addr del failed");
 
+	    argv_reset (&argv);
 	    gc_free (&gc);
 	  }
-#endif
       close_tun_generic (tt);
       free (tt);
     }
@@ -1459,16 +1495,19 @@
 static void
 solaris_error_close (struct tuntap *tt, const struct env_set *es, const char *actual)
 {
-  char command_line[256];
+  struct argv argv;
+  argv_init (&argv);
 
-  openvpn_snprintf (command_line, sizeof (command_line),
-		    IFCONFIG_PATH " %s unplumb",
+  argv_printf (&argv,
+		    "%s %s unplumb",
+		    IFCONFIG_PATH,
 		    actual);
 
-  msg (M_INFO, "%s", command_line);
-  system_check (command_line, es, 0, "Solaris ifconfig unplumb failed");
+  argv_msg (M_INFO, &argv);
+  openvpn_execve_check (&argv, es, 0, "Solaris ifconfig unplumb failed");
   close_tun (tt);
   msg (M_FATAL, "Solaris ifconfig failed");
+  argv_reset (&argv);
 }
 
 int
@@ -1735,6 +1774,89 @@
     return read (tt->fd, buf, len);
 }
 
+#elif defined(TARGET_DRAGONFLY)
+
+static inline int
+dragonfly_modify_read_write_return (int len)
+{
+  if (len > 0)
+    return len > sizeof (u_int32_t) ? len - sizeof (u_int32_t) : 0;
+  else
+    return len;
+}
+
+void
+open_tun (const char *dev, const char *dev_type, const char *dev_node, bool ipv6, struct tuntap *tt)
+{
+  open_tun_generic (dev, dev_type, dev_node, ipv6, true, true, tt);
+
+  if (tt->fd >= 0)
+    {
+      int i = 0;
+
+      /* Disable extended modes */
+      ioctl (tt->fd, TUNSLMODE, &i);
+      i = 1;
+      ioctl (tt->fd, TUNSIFHEAD, &i);
+    }
+}
+
+void
+close_tun (struct tuntap *tt)
+{
+  if (tt)
+    {
+      close_tun_generic (tt);
+      free (tt);
+    }
+}
+
+int
+write_tun (struct tuntap* tt, uint8_t *buf, int len)
+{
+  if (tt->type == DEV_TYPE_TUN)
+    {
+      u_int32_t type;
+      struct iovec iv[2];
+      struct ip *iph;
+
+      iph = (struct ip *) buf;
+
+      if (tt->ipv6 && iph->ip_v == 6)
+        type = htonl (AF_INET6);
+      else 
+        type = htonl (AF_INET);
+
+      iv[0].iov_base = (char *)&type;
+      iv[0].iov_len = sizeof (type);
+      iv[1].iov_base = buf;
+      iv[1].iov_len = len;
+
+      return dragonfly_modify_read_write_return (writev (tt->fd, iv, 2));
+    }
+  else
+    return write (tt->fd, buf, len);
+}
+
+int
+read_tun (struct tuntap* tt, uint8_t *buf, int len)
+{
+  if (tt->type == DEV_TYPE_TUN)
+    {
+      u_int32_t type;
+      struct iovec iv[2];
+
+      iv[0].iov_base = (char *)&type;
+      iv[0].iov_len = sizeof (type);
+      iv[1].iov_base = buf;
+      iv[1].iov_len = len;
+
+      return dragonfly_modify_read_write_return (readv (tt->fd, iv, 2));
+    }
+  else
+    return read (tt->fd, buf, len);
+}
+
 #elif defined(WIN32)
 
 int
@@ -3180,7 +3302,7 @@
  */
 
 static void
-netsh_command (const char *cmd, int n)
+netsh_command (const struct argv *a, int n)
 {
   int i;
   for (i = 0; i < n; ++i)
@@ -3188,8 +3310,8 @@
       bool status;
       openvpn_sleep (1);
       netcmd_semaphore_lock ();
-      msg (M_INFO, "NETSH: %s", cmd);
-      status = system_check (cmd, NULL, 0, "ERROR: netsh command failed");
+      argv_msg_prefix (M_INFO, a, "NETSH");
+      status = openvpn_execve_check (a, NULL, 0, "ERROR: netsh command failed");
       netcmd_semaphore_release ();
       if (status)
 	return;
@@ -3281,7 +3403,7 @@
 			const bool test_first)
 {
   struct gc_arena gc = gc_new ();
-  struct buffer out = alloc_buf_gc (256, &gc);
+  struct argv argv = argv_new ();
   bool delete_first = false;
 
   /* first check if we should delete existing DNS/WINS settings from TAP interface */
@@ -3296,11 +3418,12 @@
   /* delete existing DNS/WINS settings from TAP interface */
   if (delete_first)
     {
-      buf_init (&out, 0);
-      buf_printf (&out, "netsh interface ip delete %s \"%s\" all",
-		  type,
-		  flex_name);
-      netsh_command (BSTR(&out), 2);
+      argv_printf (&argv, "%s%s interface ip delete %s %s all",
+		   get_win_sys_path(),
+		   NETSH_PATH_SUFFIX,
+		   type,
+		   flex_name);
+      netsh_command (&argv, 2);
     }
 
   /* add new DNS/WINS settings to TAP interface */
@@ -3312,15 +3435,16 @@
 	if (delete_first || !test_first || !ip_addr_member_of (addr_list[i], current))
 	  {
 	    const char *fmt = count ?
-	        "netsh interface ip add %s \"%s\" %s"
-	      : "netsh interface ip set %s \"%s\" static %s";
+	        "%s%s interface ip add %s %s %s"
+	      : "%s%s interface ip set %s %s static %s";
 
-	    buf_init (&out, 0);
-	    buf_printf (&out, fmt,
-			type,
-			flex_name,
-			print_in_addr_t (addr_list[i], 0, &gc));
-	    netsh_command (BSTR(&out), 2);
+	    argv_printf (&argv, fmt,
+			 get_win_sys_path(),
+			 NETSH_PATH_SUFFIX,
+			 type,
+			 flex_name,
+			 print_in_addr_t (addr_list[i], 0, &gc));
+	    netsh_command (&argv, 2);
 	  
 	    ++count;
 	  }
@@ -3334,6 +3458,7 @@
       }
   }
 
+  argv_reset (&argv);
   gc_free (&gc);
 }
 
@@ -3363,7 +3488,7 @@
 		const unsigned int flags)
 {
   struct gc_arena gc = gc_new ();
-  struct buffer out = alloc_buf_gc (256, &gc);
+  struct argv argv = argv_new ();
   const IP_ADAPTER_INFO *ai = NULL;
   const IP_PER_ADAPTER_INFO *pai = NULL;
 
@@ -3387,14 +3512,15 @@
       else
 	{
 	  /* example: netsh interface ip set address my-tap static 10.3.0.1 255.255.255.0 */
-	  buf_init (&out, 0);
-	  buf_printf (&out,
-		      "netsh interface ip set address \"%s\" static %s %s",
-		      flex_name,
-		      print_in_addr_t (ip, 0, &gc),
-		      print_in_addr_t (netmask, 0, &gc));
+	  argv_printf (&argv,
+		       "%s%s interface ip set address %s static %s %s",
+		       get_win_sys_path(),
+		       NETSH_PATH_SUFFIX,
+		       flex_name,
+		       print_in_addr_t (ip, 0, &gc),
+		       print_in_addr_t (netmask, 0, &gc));
 
-	  netsh_command (BSTR(&out), 4);
+	  netsh_command (&argv, 4);
 	}
     }
 
@@ -3422,6 +3548,7 @@
 			      BOOL_CAST (flags & NI_TEST_FIRST));
     }
   
+  argv_reset (&argv);
   gc_free (&gc);
 }
 
@@ -3429,17 +3556,19 @@
 netsh_enable_dhcp (const struct tuntap_options *to,
 		   const char *actual_name)
 {
-  struct gc_arena gc = gc_new ();
-  struct buffer out = alloc_buf_gc (256, &gc);
+  struct argv argv;
+  argv_init (&argv);
 
   /* example: netsh interface ip set address my-tap dhcp */
-  buf_printf (&out,
-	      "netsh interface ip set address \"%s\" dhcp",
-	      actual_name);
+  argv_printf (&argv,
+	      "%s%s interface ip set address %s dhcp",
+	       get_win_sys_path(),
+	       NETSH_PATH_SUFFIX,
+	       actual_name);
 
-  netsh_command (BSTR(&out), 4);
+  netsh_command (&argv, 4);
 
-  gc_free (&gc);
+  argv_reset (&argv);
 }
 
 /*
@@ -3514,17 +3643,21 @@
  */
 
 static void
-write_dhcp_u8 (struct buffer *buf, const int type, const int data)
+write_dhcp_u8 (struct buffer *buf, const int type, const int data, bool *error)
 {
   if (!buf_safe (buf, 3))
-    msg (M_FATAL, "write_dhcp_u8: buffer overflow building DHCP options");
+    {
+      *error = true;
+      msg (M_WARN, "write_dhcp_u8: buffer overflow building DHCP options");
+      return;
+    }
   buf_write_u8 (buf, type);
   buf_write_u8 (buf, 1);
   buf_write_u8 (buf, data);
 }
 
 static void
-write_dhcp_u32_array (struct buffer *buf, const int type, const uint32_t *data, const unsigned int len)
+write_dhcp_u32_array (struct buffer *buf, const int type, const uint32_t *data, const unsigned int len, bool *error)
 {
   if (len > 0)
     {
@@ -3532,9 +3665,17 @@
       const int size = len * sizeof (uint32_t);
 
       if (!buf_safe (buf, 2 + size))
-	msg (M_FATAL, "write_dhcp_u32_array: buffer overflow building DHCP options");
+	{
+	  *error = true;
+	  msg (M_WARN, "write_dhcp_u32_array: buffer overflow building DHCP options");
+	  return;
+	}
       if (size < 1 || size > 255)
-	msg (M_FATAL, "write_dhcp_u32_array: size (%d) must be > 0 and <= 255", size);
+	{
+	  *error = true;
+	  msg (M_WARN, "write_dhcp_u32_array: size (%d) must be > 0 and <= 255", size);
+	  return;
+	}
       buf_write_u8 (buf, type);
       buf_write_u8 (buf, size);
       for (i = 0; i < len; ++i)
@@ -3543,46 +3684,61 @@
 }
 
 static void
-write_dhcp_str (struct buffer *buf, const int type, const char *str)
+write_dhcp_str (struct buffer *buf, const int type, const char *str, bool *error)
 {
   const int len = strlen (str);
   if (!buf_safe (buf, 2 + len))
-    msg (M_FATAL, "write_dhcp_str: buffer overflow building DHCP options");
+    {
+      *error = true;
+      msg (M_WARN, "write_dhcp_str: buffer overflow building DHCP options");
+      return;
+    }
   if (len < 1 || len > 255)
-    msg (M_FATAL, "write_dhcp_str: string '%s' must be > 0 bytes and <= 255 bytes", str);
+    {
+      *error = true;
+      msg (M_WARN, "write_dhcp_str: string '%s' must be > 0 bytes and <= 255 bytes", str);
+      return;
+    }
   buf_write_u8 (buf, type);
   buf_write_u8 (buf, len);
   buf_write (buf, str, len);
 }
 
-static void
+static bool
 build_dhcp_options_string (struct buffer *buf, const struct tuntap_options *o)
 {
+  bool error = false;
   if (o->domain)
-    write_dhcp_str (buf, 15, o->domain);
+    write_dhcp_str (buf, 15, o->domain, &error);
 
   if (o->netbios_scope)
-    write_dhcp_str (buf, 47, o->netbios_scope);
+    write_dhcp_str (buf, 47, o->netbios_scope, &error);
 
   if (o->netbios_node_type)
-    write_dhcp_u8 (buf, 46, o->netbios_node_type);
+    write_dhcp_u8 (buf, 46, o->netbios_node_type, &error);
 
-  write_dhcp_u32_array (buf, 6, (uint32_t*)o->dns, o->dns_len);
-  write_dhcp_u32_array (buf, 44, (uint32_t*)o->wins, o->wins_len);
-  write_dhcp_u32_array (buf, 42, (uint32_t*)o->ntp, o->ntp_len);
-  write_dhcp_u32_array (buf, 45, (uint32_t*)o->nbdd, o->nbdd_len);
+  write_dhcp_u32_array (buf, 6, (uint32_t*)o->dns, o->dns_len, &error);
+  write_dhcp_u32_array (buf, 44, (uint32_t*)o->wins, o->wins_len, &error);
+  write_dhcp_u32_array (buf, 42, (uint32_t*)o->ntp, o->ntp_len, &error);
+  write_dhcp_u32_array (buf, 45, (uint32_t*)o->nbdd, o->nbdd_len, &error);
 
   /* the MS DHCP server option 'Disable Netbios-over-TCP/IP
      is implemented as vendor option 001, value 002.
      A value of 001 means 'leave NBT alone' which is the default */
   if (o->disable_nbt)
   {
-    buf_write_u8 (buf, 43);
+    if (!buf_safe (buf, 8))
+      {
+	msg (M_WARN, "build_dhcp_options_string: buffer overflow building DHCP options");
+	return false;
+      }
+    buf_write_u8 (buf,  43);
     buf_write_u8 (buf,  6);  /* total length field */
     buf_write_u8 (buf,  0x001);
     buf_write_u8 (buf,  4);  /* length of the vendor specified field */
     buf_write_u32 (buf, 0x002);
   }
+  return !error;
 }
 
 void
@@ -3877,12 +4033,16 @@
       if (tt->options.dhcp_options)
 	{
 	  struct buffer buf = alloc_buf (256);
-	  build_dhcp_options_string (&buf, &tt->options);
-	  msg (D_DHCP_OPT, "DHCP option string: %s", format_hex (BPTR (&buf), BLEN (&buf), 0, &gc));
-	  if (!DeviceIoControl (tt->hand, TAP_IOCTL_CONFIG_DHCP_SET_OPT,
-				BPTR (&buf), BLEN (&buf),
-				BPTR (&buf), BLEN (&buf), &len, NULL))
-	    msg (M_FATAL, "ERROR: The TAP-Win32 driver rejected a TAP_IOCTL_CONFIG_DHCP_SET_OPT DeviceIoControl call");
+	  if (build_dhcp_options_string (&buf, &tt->options))
+	    {
+	      msg (D_DHCP_OPT, "DHCP option string: %s", format_hex (BPTR (&buf), BLEN (&buf), 0, &gc));
+	      if (!DeviceIoControl (tt->hand, TAP_IOCTL_CONFIG_DHCP_SET_OPT,
+				    BPTR (&buf), BLEN (&buf),
+				    BPTR (&buf), BLEN (&buf), &len, NULL))
+		msg (M_FATAL, "ERROR: The TAP-Win32 driver rejected a TAP_IOCTL_CONFIG_DHCP_SET_OPT DeviceIoControl call");
+	    }
+	  else
+	    msg (M_WARN, "DHCP option string not set due to error");
 	  free_buf (&buf);
 	}
 #endif
diff -urN openvpn-2.1_rc7/tun.h openvpn-2.1_rc9/tun.h
--- openvpn-2.1_rc7/tun.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/tun.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1_rc7/version.m4 openvpn-2.1_rc9/version.m4
--- openvpn-2.1_rc7/version.m4	2008-01-30 00:54:07.000000000 +0100
+++ openvpn-2.1_rc9/version.m4	2008-07-31 19:42:22.000000000 +0200
@@ -1,2 +1,6 @@
 dnl define the OpenVPN version
-define(PRODUCT_VERSION,[2.1_rc7])
+define(PRODUCT_VERSION,[2.1_rc9])
+dnl define the TAP version
+define(PRODUCT_TAP_ID,[tap0901])
+define(PRODUCT_TAP_WIN32_MIN_MAJOR,[9])
+define(PRODUCT_TAP_WIN32_MIN_MINOR,[1])
diff -urN openvpn-2.1_rc7/win32.c openvpn-2.1_rc9/win32.c
--- openvpn-2.1_rc7/win32.c	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/win32.c	2008-07-26 10:28:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -26,17 +26,16 @@
  * Win32-specific OpenVPN code, targetted at the mingw
  * development environment.
  */
+#include "syshead.h"
 
 #ifdef WIN32
 
-#include "config-win32.h"
-
-#include "syshead.h"
 #include "buffer.h"
 #include "error.h"
 #include "mtu.h"
 #include "sig.h"
 #include "win32.h"
+#include "misc.h"
 
 #include "memdbg.h"
 
@@ -71,6 +70,11 @@
 
 struct semaphore netcmd_semaphore; /* GLOBAL */
 
+/*
+ * Windows system pathname such as c:\windows
+ */
+static char *win_sys_path = NULL; /* GLOBAL */
+
 void
 init_win32 (void)
 {
@@ -102,6 +106,7 @@
   window_title_restore (&window_title);
   win32_signal_close (&win32_signal);
   WSACleanup ();
+  free (win_sys_path);
 }
 
 void
@@ -755,4 +760,236 @@
     return NULL;
 }
 
+/*
+ * Return true if filename is safe to be used on Windows,
+ * by avoiding the following reserved names:
+ *
+ * CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9,
+ * LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, LPT9, and CLOCK$
+ *
+ * See: http://msdn.microsoft.com/en-us/library/aa365247.aspx
+ *  and http://msdn.microsoft.com/en-us/library/86k9f82k(VS.80).aspx
+ */
+
+static bool
+cmp_prefix (const char *str, const bool n, const char *pre)
+{
+  size_t i = 0;
+
+  if (!str)
+    return false;
+
+  while (true)
+    {
+      const int c1 = pre[i];
+      int c2 = str[i];
+      ++i;
+      if (c1 == '\0')
+	{
+	  if (n)
+	    {
+	      if (isdigit (c2))
+		c2 = str[i];
+	      else
+		return false;
+	    }
+	  return c2 == '\0' || c2 == '.';
+	}
+      else if (c2 == '\0')
+	return false;
+      if (c1 != tolower(c2))
+	return false;
+    }
+}
+
+bool
+win_safe_filename (const char *fn)
+{
+  if (cmp_prefix (fn, false, "con"))
+    return false;
+  if (cmp_prefix (fn, false, "prn"))
+    return false;
+  if (cmp_prefix (fn, false, "aux"))
+    return false;
+  if (cmp_prefix (fn, false, "nul"))
+    return false;
+  if (cmp_prefix (fn, true, "com"))
+    return false;
+  if (cmp_prefix (fn, true, "lpt"))
+    return false;
+  if (cmp_prefix (fn, false, "clock$"))
+    return false;
+  return true;
+}
+
+/*
+ * Service functions for openvpn_execve
+ */
+
+static char *
+env_block (const struct env_set *es)
+{
+  if (es)
+    {
+      struct env_item *e;
+      char *ret;
+      char *p;
+      size_t nchars = 1;
+      
+      for (e = es->list; e != NULL; e = e->next)
+	nchars += strlen (e->string) + 1;
+
+      ret = (char *) malloc (nchars);
+      check_malloc_return (ret);
+
+      p = ret;
+      for (e = es->list; e != NULL; e = e->next)
+	{
+	  if (env_allowed (e->string))
+	    {
+	      strcpy (p, e->string);
+	      p += strlen (e->string) + 1;
+	    }
+	}
+      *p = '\0';
+      return ret;
+    }
+  else
+    return NULL;
+}
+
+static char *
+cmd_line (const struct argv *a)
+{
+  size_t nchars = 1;
+  size_t maxlen = 0;
+  size_t i;
+  struct buffer buf;
+  char *work = NULL;
+
+  if (!a)
+    return NULL;
+
+  for (i = 0; i < a->argc; ++i)
+    {
+      const char *arg = a->argv[i];
+      const size_t len = strlen (arg);
+      nchars += len + 3;
+      if (len > maxlen)
+	maxlen = len;
+    }
+
+  work = (char *) malloc (maxlen + 1);
+  check_malloc_return (work);
+  buf = alloc_buf (nchars);
+
+  for (i = 0; i < a->argc; ++i)
+    {
+      const char *arg = a->argv[i];
+      strcpy (work, arg);
+      string_mod (work, CC_PRINT, CC_DOUBLE_QUOTE|CC_CRLF, '_');
+      if (i)
+	buf_printf (&buf, " ");
+      if (string_class (work, CC_ANY, CC_SPACE))
+	buf_printf (&buf, "%s", work);
+      else
+	buf_printf (&buf, "\"%s\"", work);
+    }
+
+  free (work);
+  return BSTR(&buf);
+}
+
+/*
+ * Attempt to simulate fork/execve on Windows
+ */
+int
+openvpn_execve (const struct argv *a, const struct env_set *es, const unsigned int flags)
+{
+  int ret = -1;
+  if (a && a->argv[0])
+    {
+      if (openvpn_execve_allowed (flags))
+	{
+	  STARTUPINFO start_info;
+	  PROCESS_INFORMATION proc_info;
+
+	  char *env = env_block (es);
+	  char *cl = cmd_line (a);
+	  char *cmd = a->argv[0];
+
+	  CLEAR (start_info);
+	  CLEAR (proc_info);
+
+	  /* fill in STARTUPINFO struct */
+	  GetStartupInfo(&start_info);
+	  start_info.cb = sizeof(start_info);
+	  start_info.dwFlags = STARTF_USESTDHANDLES|STARTF_USESHOWWINDOW;
+	  start_info.wShowWindow = SW_HIDE;
+	  start_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
+	  start_info.hStdOutput = start_info.hStdError = GetStdHandle(STD_OUTPUT_HANDLE);
+
+	  if (CreateProcess (cmd, cl, NULL, NULL, FALSE, 0, env, NULL, &start_info, &proc_info))
+	    {
+	      DWORD exit_status = 0;
+	      CloseHandle (proc_info.hThread);
+	      WaitForSingleObject (proc_info.hProcess, INFINITE);
+	      if (GetExitCodeProcess (proc_info.hProcess, &exit_status))
+		ret = (int)exit_status;
+	      else
+		msg (M_WARN|M_ERRNO, "openvpn_execve: GetExitCodeProcess %s failed", cmd);
+	      CloseHandle (proc_info.hProcess);
+	    }
+	  else
+	    {
+	      msg (M_WARN|M_ERRNO, "openvpn_execve: CreateProcess %s failed", cmd);
+	    }
+	  free (cl);
+	  free (env);
+	}
+      else
+	{
+	  msg (M_WARN, "openvpn_execve: external program may not be called due to setting of --script-security level");
+	}
+    }
+  else
+    {
+      msg (M_WARN, "openvpn_execve: called with empty argv");
+    }
+  return ret;
+}
+
+char *
+get_win_sys_path (void)
+{
+  ASSERT (win_sys_path);
+  return win_sys_path;
+}
+
+void
+set_win_sys_path (const char *newpath, struct env_set *es)
+{
+  free (win_sys_path);
+  win_sys_path = string_alloc (newpath, NULL);
+  setenv_str (es, SYS_PATH_ENV_VAR_NAME, win_sys_path); /* route.exe needs this */
+}
+
+void
+set_win_sys_path_via_env (struct env_set *es)
+{
+  char buf[256];
+  DWORD status = GetEnvironmentVariable (SYS_PATH_ENV_VAR_NAME, buf, sizeof(buf));
+  if (!status)
+    msg (M_ERR, "Cannot find environmental variable %s", SYS_PATH_ENV_VAR_NAME);
+  if (status > sizeof (buf) - 1)
+    msg (M_FATAL, "String overflow attempting to read environmental variable %s", SYS_PATH_ENV_VAR_NAME);
+  set_win_sys_path (buf, es);
+}
+
+void
+env_set_add_win32 (struct env_set *es)
+{
+  set_win_sys_path (DEFAULT_WIN_SYS_PATH, es);
+}
+
 #endif
diff -urN openvpn-2.1_rc7/win32.h openvpn-2.1_rc9/win32.h
--- openvpn-2.1_rc7/win32.h	2008-01-23 22:08:41.000000000 +0100
+++ openvpn-2.1_rc9/win32.h	2008-07-26 08:18:08.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2005 OpenVPN Solutions LLC <info@openvpn.net>
+ *  Copyright (C) 2002-2008 Telethra, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -28,6 +28,12 @@
 
 #include "mtu.h"
 
+/* location of executables */
+#define SYS_PATH_ENV_VAR_NAME "SystemRoot"  /* environmental variable name that normally contains the system path */
+#define DEFAULT_WIN_SYS_PATH  "C:\\WINDOWS" /* --win-sys default value */
+#define NETSH_PATH_SUFFIX     "\\system32\\netsh.exe"
+#define WIN_ROUTE_PATH_SUFFIX "\\system32\\route.exe"
+
 /*
  * Win32-specific OpenVPN code, targetted at the mingw
  * development environment.
@@ -247,5 +253,17 @@
 /* Set Win32 security attributes structure to allow all access */
 bool init_security_attributes_allow_all (struct security_attributes *obj);
 
+/* return true if filename is safe to be used on Windows */
+bool win_safe_filename (const char *fn);
+
+/* add constant environmental variables needed by Windows */
+struct env_set;
+void env_set_add_win32 (struct env_set *es);
+
+/* get and set the current windows system path */
+void set_win_sys_path (const char *newpath, struct env_set *es);
+void set_win_sys_path_via_env (struct env_set *es);
+char *get_win_sys_path (void);
+
 #endif
 #endif

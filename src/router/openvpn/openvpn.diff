diff -urN openvpn-2.1.1/COPYING openvpn-2.1.3/COPYING
--- openvpn-2.1.1/COPYING	2009-12-11 05:43:07.000000000 +0100
+++ openvpn-2.1.3/COPYING	2010-04-28 18:25:38.000000000 +0200
@@ -1,6 +1,6 @@
 OpenVPN (TM) -- An Open Source VPN daemon
 
-Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 
 This distribution contains multiple components, some
 of which fall under different licenses.  By using OpenVPN
@@ -52,7 +52,7 @@
   Damion K. Wilson.
 
   The source and object code of the TAP-Win32/TAP-Win64 driver
-  is Copyright (C) 2002-2009 OpenVPN Technologies, Inc., and is released under
+  is Copyright (C) 2002-2010 OpenVPN Technologies, Inc., and is released under
   the GPL version 2.
 
 Windows DDK Samples:
diff -urN openvpn-2.1.1/ChangeLog openvpn-2.1.3/ChangeLog
--- openvpn-2.1.1/ChangeLog	2009-12-12 00:42:25.000000000 +0100
+++ openvpn-2.1.3/ChangeLog	2010-08-15 23:51:10.000000000 +0200
@@ -1,5 +1,116 @@
 OpenVPN Change Log
-Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
+
+2010.08.09 -- Version 2.1.2
+
+* Windows security issue:
+  Fixed potential local privilege escalation vulnerability in
+  Windows service. The Windows service did not properly quote the
+  executable filename passed to CreateService.  A local attacker
+  with write access to the root directory C:\ could create an
+  executable that would be run with the same privilege level as
+  the OpenVPN Windows service.  However, since non-Administrative
+  users normally lack write permission on C:\, this vulnerability
+  is generally not exploitable except on older versions of Windows
+  (such as Win2K) where the default permissions on C:\ would allow
+  any user to create files there.
+  Credit:  Scott Laurie, MWR InfoSecurity
+
+* Added Python-based based alternative build system for Windows using
+  Visual Studio 2008 (in win directory).
+
+* When aborting in a non-graceful way, try to execute do_close_tun in
+  init.c prior to daemon exit to ensure that the tun/tap interface is
+  closed and any added routes are deleted.
+
+* Fixed an issue where AUTH_FAILED was not being properly delivered
+  to the client when a bad password is given for mid-session reauth,
+  causing the connection to fail without an error indication.
+
+* Don't advance to the next connection profile on AUTH_FAILED errors.
+
+* Fixed an issue in the Management Interface that could cause
+  a process hang with 100% CPU utilization in --management-client
+  mode if the management interface client disconnected at the
+  point where credentials are queried.
+
+* Fixed an issue where if reneg-sec was set to 0 on the client,
+  so that the server-side value would take precedence,
+  the auth_deferred_expire_window function would incorrectly
+  return a window period of 0 seconds.  In this case, the
+  correct window period should be the handshake window
+  period.
+
+* Modified ">PASSWORD:Verification Failed" management interface
+  notification to include a client reason string:
+
+    >PASSWORD:Verification Failed: 'AUTH_TYPE' ['REASON_STRING']
+
+* Enable exponential backoff in reliability layer
+  retransmits.
+
+* Set socket buffers (SO_SNDBUF and SO_RCVBUF) immediately after
+  socket is created rather than waiting until after connect/listen.
+
+* Management interface performance optimizations:
+
+  1. Added env-filter MI command to perform filtering on env vars
+     passed through as a part of --management-client-auth
+
+  2. man_write will now try to aggregate output into larger blocks
+     (up to 1024 bytes) for more efficient i/o
+
+* Fixed minor issue in Windows TAP driver DEBUG builds
+  where non-null-terminated unicode strings were being
+  printed incorrectly.
+
+* Fixed issue on Windows with MSVC compiler, where TCP_NODELAY support
+  was not being compiled in.
+
+* Proxy improvements:
+
+  Improved the ability of http-auth "auto" flag to dynamically detect
+  the auth method required by the proxy.
+
+  Added http-auth "auto-nct" flag to reject weak proxy auth methods.
+
+  Added HTTP proxy digest authentication method.
+
+  Removed extraneous openvpn_sleep calls from proxy.c.
+
+* Implemented http-proxy-override and http-proxy-fallback directives to make it
+  easier for OpenVPN client UIs to start a pre-existing client config file with
+  proxy options, or to adaptively fall back to a proxy connection if a direct
+  connection fails.
+
+* Implemented a key/value auth channel from client to server.
+
+* Fixed issue where bad creds provided by the management interface
+  for HTTP Proxy Basic Authentication would go into an infinite
+  retry-fail loop instead of requerying the management interface for
+  new creds.
+
+* Added support for MSVC debugging of openvpn.exe in settings.in:
+
+  # Build debugging version of openvpn.exe
+  !define PRODUCT_OPENVPN_DEBUG
+
+* Implemented multi-address DNS expansion on the network field of route
+  commands.
+
+  When only a single IP address is desired from a multi-address DNS
+  expansion, use the first address rather than a random selection.
+
+* Added --register-dns option for Windows.
+
+  Fixed some issues on Windows with --log, subprocess creation
+  for command execution, and stdout/stderr redirection.
+
+* Fixed an issue where application payload transmissions on the
+  TLS control channel (such as AUTH_FAILED) that occur during
+  or immediately after a TLS renegotiation might be dropped. 
+
+* Added warning about tls-remote option in man page.
 
 2009.12.11 -- Version 2.1.1
 
diff -urN openvpn-2.1.1/INSTALL openvpn-2.1.3/INSTALL
--- openvpn-2.1.1/INSTALL	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/INSTALL	2010-04-28 18:25:38.000000000 +0200
@@ -1,6 +1,6 @@
 Installation instructions for OpenVPN, a Secure Tunneling Daemon
 
-Copyright (C) 2002-2009 OpenVPN Technologies, Inc. This program is free software;
+Copyright (C) 2002-2010 OpenVPN Technologies, Inc. This program is free software;
 you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2
 as published by the Free Software Foundation.
@@ -12,9 +12,12 @@
   Unix:
     ./configure && make && make-install
 
-  Windows:
+  Windows MinGW, using MSYS bash shell:
     ./domake-win (see comments in the script for more info)
 
+  Windows Visual Studio:
+    python win\build_all.py
+
 *************************************************************************
 
 To download OpenVPN, go to:
diff -urN openvpn-2.1.1/Makefile.am openvpn-2.1.3/Makefile.am
--- openvpn-2.1.1/Makefile.am	2009-10-07 13:11:01.000000000 +0200
+++ openvpn-2.1.3/Makefile.am	2010-08-09 22:07:34.000000000 +0200
@@ -5,7 +5,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+#  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
@@ -36,7 +36,7 @@
 	$(srcdir)/install-sh $(srcdir)/ltmain.sh $(srcdir)/missing \
 	$(srcdir)/depcomp $(srcdir)/aclocal.m4 \
 	$(srcdir)/config.guess $(srcdir)/config.sub \
-	$(srcdir)/config-win32.h $(srcdir)/openvpn.spec
+	$(srcdir)/openvpn.spec
 CLEANFILES = openvpn.8.html
 
 EXTRA_DIST = \
@@ -48,7 +48,8 @@
 	tap-win32 \
 	contrib \
 	debug \
-	plugin
+	plugin \
+	win
 
 SUBDIRS = \
 	images \
@@ -58,8 +59,7 @@
 TESTS = t_lpback.sh t_cltsrv.sh
 sbin_PROGRAMS = openvpn
 
-dist_noinst_HEADERS = \
-	config-win32.h
+dist_noinst_HEADERS =
 
 dist_noinst_SCRIPTS = \
 	$(TESTS) \
@@ -89,6 +89,7 @@
 	fragment.c fragment.h \
 	gremlin.c gremlin.h \
 	helper.c helper.h \
+	httpdigest.c httpdigest.h \
 	lladdr.c lladdr.h \
 	init.c init.h \
 	integer.h \
diff -urN openvpn-2.1.1/Makefile.in openvpn-2.1.3/Makefile.in
--- openvpn-2.1.1/Makefile.in	2009-12-12 00:27:05.000000000 +0100
+++ openvpn-2.1.3/Makefile.in	2010-08-27 18:10:02.000000000 +0200
@@ -21,7 +21,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+#  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
@@ -67,10 +67,9 @@
 	$(am__dist_noinst_DATA_DIST) $(dist_man_MANS) \
 	$(dist_noinst_HEADERS) $(dist_noinst_SCRIPTS) \
 	$(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(srcdir)/config-win32.h.in $(srcdir)/config.h.in \
-	$(srcdir)/openvpn.spec.in $(top_srcdir)/configure AUTHORS \
-	COPYING ChangeLog INSTALL NEWS config.guess config.sub depcomp \
-	install-sh memcmp.c missing
+	$(srcdir)/config.h.in $(srcdir)/openvpn.spec.in \
+	$(top_srcdir)/configure AUTHORS COPYING ChangeLog INSTALL NEWS \
+	config.guess config.sub depcomp install-sh memcmp.c missing
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
 	$(top_srcdir)/version.m4 $(top_srcdir)/configure.ac
@@ -80,7 +79,7 @@
  configure.lineno config.status.lineno
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = config.h
-CONFIG_CLEAN_FILES = openvpn.spec config-win32.h
+CONFIG_CLEAN_FILES = openvpn.spec
 am__installdirs = "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(man8dir)" \
 	"$(DESTDIR)$(htmldir)"
 sbinPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
@@ -89,18 +88,18 @@
 	crypto.$(OBJEXT) dhcp.$(OBJEXT) error.$(OBJEXT) \
 	event.$(OBJEXT) fdmisc.$(OBJEXT) forward.$(OBJEXT) \
 	fragment.$(OBJEXT) gremlin.$(OBJEXT) helper.$(OBJEXT) \
-	lladdr.$(OBJEXT) init.$(OBJEXT) interval.$(OBJEXT) \
-	list.$(OBJEXT) lzo.$(OBJEXT) manage.$(OBJEXT) mbuf.$(OBJEXT) \
-	misc.$(OBJEXT) mroute.$(OBJEXT) mss.$(OBJEXT) mtcp.$(OBJEXT) \
-	mtu.$(OBJEXT) mudp.$(OBJEXT) multi.$(OBJEXT) ntlm.$(OBJEXT) \
-	occ.$(OBJEXT) pkcs11.$(OBJEXT) openvpn.$(OBJEXT) \
-	options.$(OBJEXT) otime.$(OBJEXT) packet_id.$(OBJEXT) \
-	perf.$(OBJEXT) pf.$(OBJEXT) ping.$(OBJEXT) plugin.$(OBJEXT) \
-	pool.$(OBJEXT) proto.$(OBJEXT) proxy.$(OBJEXT) \
-	ieproxy.$(OBJEXT) ps.$(OBJEXT) push.$(OBJEXT) \
-	reliable.$(OBJEXT) route.$(OBJEXT) schedule.$(OBJEXT) \
-	session_id.$(OBJEXT) shaper.$(OBJEXT) sig.$(OBJEXT) \
-	socket.$(OBJEXT) socks.$(OBJEXT) ssl.$(OBJEXT) \
+	httpdigest.$(OBJEXT) lladdr.$(OBJEXT) init.$(OBJEXT) \
+	interval.$(OBJEXT) list.$(OBJEXT) lzo.$(OBJEXT) \
+	manage.$(OBJEXT) mbuf.$(OBJEXT) misc.$(OBJEXT) \
+	mroute.$(OBJEXT) mss.$(OBJEXT) mtcp.$(OBJEXT) mtu.$(OBJEXT) \
+	mudp.$(OBJEXT) multi.$(OBJEXT) ntlm.$(OBJEXT) occ.$(OBJEXT) \
+	pkcs11.$(OBJEXT) openvpn.$(OBJEXT) options.$(OBJEXT) \
+	otime.$(OBJEXT) packet_id.$(OBJEXT) perf.$(OBJEXT) \
+	pf.$(OBJEXT) ping.$(OBJEXT) plugin.$(OBJEXT) pool.$(OBJEXT) \
+	proto.$(OBJEXT) proxy.$(OBJEXT) ieproxy.$(OBJEXT) ps.$(OBJEXT) \
+	push.$(OBJEXT) reliable.$(OBJEXT) route.$(OBJEXT) \
+	schedule.$(OBJEXT) session_id.$(OBJEXT) shaper.$(OBJEXT) \
+	sig.$(OBJEXT) socket.$(OBJEXT) socks.$(OBJEXT) ssl.$(OBJEXT) \
 	status.$(OBJEXT) thread.$(OBJEXT) tun.$(OBJEXT) \
 	win32.$(OBJEXT) cryptoapi.$(OBJEXT)
 openvpn_OBJECTS = $(am_openvpn_OBJECTS)
@@ -272,7 +271,7 @@
 	$(srcdir)/install-sh $(srcdir)/ltmain.sh $(srcdir)/missing \
 	$(srcdir)/depcomp $(srcdir)/aclocal.m4 \
 	$(srcdir)/config.guess $(srcdir)/config.sub \
-	$(srcdir)/config-win32.h $(srcdir)/openvpn.spec
+	$(srcdir)/openvpn.spec
 
 CLEANFILES = openvpn.8.html
 EXTRA_DIST = \
@@ -284,7 +283,8 @@
 	tap-win32 \
 	contrib \
 	debug \
-	plugin
+	plugin \
+	win
 
 SUBDIRS = \
 	images \
@@ -292,9 +292,7 @@
 	install-win32
 
 TESTS = t_lpback.sh t_cltsrv.sh
-dist_noinst_HEADERS = \
-	config-win32.h
-
+dist_noinst_HEADERS = 
 dist_noinst_SCRIPTS = \
 	$(TESTS) \
 	doclean \
@@ -319,6 +317,7 @@
 	fragment.c fragment.h \
 	gremlin.c gremlin.h \
 	helper.c helper.h \
+	httpdigest.c httpdigest.h \
 	lladdr.c lladdr.h \
 	init.c init.h \
 	integer.h \
@@ -429,8 +428,6 @@
 	-rm -f config.h stamp-h1
 openvpn.spec: $(top_builddir)/config.status $(srcdir)/openvpn.spec.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
-config-win32.h: $(top_builddir)/config.status $(srcdir)/config-win32.h.in
-	cd $(top_builddir) && $(SHELL) ./config.status $@
 install-sbinPROGRAMS: $(sbin_PROGRAMS)
 	@$(NORMAL_INSTALL)
 	test -z "$(sbindir)" || $(MKDIR_P) "$(DESTDIR)$(sbindir)"
@@ -477,6 +474,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fragment.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gremlin.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/helper.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/httpdigest.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ieproxy.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/init.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interval.Po@am__quote@
diff -urN openvpn-2.1.1/PORTS openvpn-2.1.3/PORTS
--- openvpn-2.1.1/PORTS	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/PORTS	2010-04-28 18:25:39.000000000 +0200
@@ -1,5 +1,5 @@
 OpenVPN
-Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 
   OpenVPN has been written to try to avoid features
   that are not standardized well across different
diff -urN openvpn-2.1.1/README openvpn-2.1.3/README
--- openvpn-2.1.1/README	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/README	2010-04-28 18:25:39.000000000 +0200
@@ -1,6 +1,6 @@
 OpenVPN -- A Secure tunneling daemon
 
-Copyright (C) 2002-2009 OpenVPN Technologies, Inc. This program is free software;
+Copyright (C) 2002-2010 OpenVPN Technologies, Inc. This program is free software;
 you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2
 as published by the Free Software Foundation.
diff -urN openvpn-2.1.1/basic.h openvpn-2.1.3/basic.h
--- openvpn-2.1.1/basic.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/basic.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/buffer.c openvpn-2.1.3/buffer.c
--- openvpn-2.1.1/buffer.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/buffer.c	2010-07-27 08:14:22.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -43,7 +43,7 @@
 }
 
 void
-buf_size_error (size_t size)
+buf_size_error (const size_t size)
 {
   msg (M_FATAL, "fatal buffer size error, size=%lu", (unsigned long)size);
 }
@@ -896,8 +896,11 @@
 void
 buffer_list_free (struct buffer_list *ol)
 {
-  buffer_list_reset (ol);
-  free (ol);
+  if (ol)
+    {
+      buffer_list_reset (ol);
+      free (ol);
+    }
 }
 
 bool
@@ -924,9 +927,21 @@
 void
 buffer_list_push (struct buffer_list *ol, const unsigned char *str)
 {
-  if (!ol->max_size || ol->size < ol->max_size)
+  if (str)
+    {
+      const size_t len = strlen ((const char *)str);
+      struct buffer_entry *e = buffer_list_push_data (ol, str, len+1);
+      if (e)
+	e->buf.len = len; /* Don't count trailing '\0' as part of length */
+    }
+}
+
+struct buffer_entry *
+buffer_list_push_data (struct buffer_list *ol, const uint8_t *data, size_t size)
+{
+  struct buffer_entry *e = NULL;
+  if (data && (!ol->max_size || ol->size < ol->max_size))
     {
-      struct buffer_entry *e;
       ALLOC_OBJ_CLEAR (e, struct buffer_entry);
 
       ++ol->size;
@@ -940,24 +955,66 @@
 	  ASSERT (!ol->head);
 	  ol->head = e;
 	}
-      e->buf = string_alloc_buf ((const char *) str, NULL);
+      e->buf = alloc_buf (size);
+      memcpy (e->buf.data, data, size);
+      e->buf.len = (int)size;
       ol->tail = e;
     }
+  return e;
 }
 
-const struct buffer *
+struct buffer *
 buffer_list_peek (struct buffer_list *ol)
 {
-  if (ol->head)
+  if (ol && ol->head)
     return &ol->head->buf;
   else
     return NULL;
 }
 
-static void
+void
+buffer_list_aggregate (struct buffer_list *bl, const size_t max)
+{
+  if (bl->head)
+    {
+      struct buffer_entry *more = bl->head;
+      size_t size = 0;
+      int count = 0;
+      for (count = 0; more && size <= max; ++count)
+	{
+	  size += BLEN(&more->buf);
+	  more = more->next;
+	}
+
+      if (count >= 2)
+	{
+	  int i;
+	  struct buffer_entry *e = bl->head, *f;
+
+	  ALLOC_OBJ_CLEAR (f, struct buffer_entry);
+	  f->buf.data = malloc (size);
+	  check_malloc_return (f->buf.data);
+	  f->buf.capacity = size;
+	  for (i = 0; e && i < count; ++i)
+	    {
+	      struct buffer_entry *next = e->next;
+	      buf_copy (&f->buf, &e->buf);
+	      free_buf (&e->buf);
+	      free (e);
+	      e = next;
+	    }
+	  bl->head = f;
+	  f->next = more;
+	  if (!more)
+	    bl->tail = f;
+	}
+    }
+}
+
+void
 buffer_list_pop (struct buffer_list *ol)
 {
-  if (ol->head)
+  if (ol && ol->head)
     {
       struct buffer_entry *e = ol->head->next;
       free_buf (&ol->head->buf);
diff -urN openvpn-2.1.1/buffer.h openvpn-2.1.3/buffer.h
--- openvpn-2.1.1/buffer.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/buffer.h	2010-07-27 07:51:03.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -724,6 +724,12 @@
 
 void x_gc_free (struct gc_arena *a);
 
+static inline bool
+gc_defined (struct gc_arena *a)
+{
+  return a->list != NULL;
+}
+
 static inline void
 gc_init (struct gc_arena *a)
 {
@@ -845,8 +851,12 @@
 void buffer_list_reset (struct buffer_list *ol);
 
 void buffer_list_push (struct buffer_list *ol, const unsigned char *str);
-const struct buffer *buffer_list_peek (struct buffer_list *ol);
+struct buffer_entry *buffer_list_push_data (struct buffer_list *ol, const uint8_t *data, size_t size);
+struct buffer *buffer_list_peek (struct buffer_list *ol);
 void buffer_list_advance (struct buffer_list *ol, int n);
+void buffer_list_pop (struct buffer_list *ol);
+
+void buffer_list_aggregate (struct buffer_list *bl, const size_t max);
 
 struct buffer_list *buffer_list_file (const char *fn, int max_line_len);
 
diff -urN openvpn-2.1.1/circ_list.h openvpn-2.1.3/circ_list.h
--- openvpn-2.1.1/circ_list.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/circ_list.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/common.h openvpn-2.1.3/common.h
--- openvpn-2.1.1/common.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/common.h	2010-05-31 09:05:55.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -76,8 +76,15 @@
 /*
  * This parameter controls the TLS channel buffer size and the
  * maximum size of a single TLS message (cleartext).
+ * This parameter must be >= PUSH_BUNDLE_SIZE
  */
-#define TLS_CHANNEL_BUF_SIZE 1024
+#define TLS_CHANNEL_BUF_SIZE 2048
+
+/*
+ * This parameter controls the maximum size of a bundle
+ * of pushed options.
+ */
+#define PUSH_BUNDLE_SIZE 1024
 
 /*
  * A sort of pseudo-filename for data provided inline within
diff -urN openvpn-2.1.1/config-win32.h openvpn-2.1.3/config-win32.h
--- openvpn-2.1.1/config-win32.h	2009-12-12 00:27:36.000000000 +0100
+++ openvpn-2.1.3/config-win32.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,325 +0,0 @@
-/*
- *  OpenVPN -- An application to securely tunnel IP networks
- *             over a single UDP port, with support for SSL/TLS-based
- *             session authentication and key exchange,
- *             packet encryption, packet authentication, and
- *             packet compression.
- *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*
- * Configuration header for Win32 using the mingw environment.
- * Manually edited based on linux version as generated by autoconf.
- *
- * config-win32.h is normally generated by copying
- * config-win32.h.in -> config-win32.h and replacing
- * [ampersand] VERSION [ampersand]
- * with the appropriate version #.  This is normally
- * done automatically by configure.ac
- */
-
-#include <windows.h>
-#include <winsock2.h>
-#include "autodefs/defs.h"
-
-#define sleep(x) Sleep((x)*1000)
-
-#define random rand
-#define srandom srand
-
-typedef unsigned long in_addr_t;
-
-#ifndef _SSIZE_T_
-#define _SSIZE_T_
- typedef unsigned int ssize_t;
-#endif
-
-/* Append a label to program startup title */
-/*#define DEBUG_LABEL "DEBUG1"*/
-
-/* Should we print debug info from driver? */
-#ifdef PRODUCT_TAP_DEBUG
-#define TAP_WIN32_DEBUG
-#endif
-
-/*
- * Minimum TAP-Win32 version number expected by userspace
- *
- * The TAP-Win32 version number is defined in tap-win32/SOURCES
- */
-#define TAP_ID tap0901
-#define TAP_WIN32_MIN_MAJOR 9
-#define TAP_WIN32_MIN_MINOR 1
-
-/* Enable client/server capability */
-#define ENABLE_CLIENT_SERVER 1
-
-/* Enable client capability only */
-/* #undef ENABLE_CLIENT_ONLY */
-
-/* Enable management server capability */
-#define ENABLE_MANAGEMENT 1
-
-/* Enable PKCS#11 support */
-#define USE_PKCS11 1
-
-/* Enable HTTP proxy support */
-#define ENABLE_HTTP_PROXY 1
-
-/* Enable Socks proxy support */
-#define ENABLE_SOCKS 1
-
-/* Enable internal fragmentation support */
-#define ENABLE_FRAGMENT 1
-
-/* Enable smaller executable size */
-/* #undef ENABLE_SMALL */
-
-/* Enable debugging support */
-#define ENABLE_DEBUG 1
-
-/* if defined, will allow usage of the --plugin directive */
-#define USE_LOAD_LIBRARY
-
-/* Dimension size to use for empty array declaration */
-#define EMPTY_ARRAY_SIZE 0
-
-/* Define to 1 if you have the `getsockname' function. */
-#define HAVE_GETSOCKNAME 1
-
-/* Define to 1 if you have the <openssl/engine.h> header file. */
-#define HAVE_OPENSSL_ENGINE_H 1
-
-/* Define to 1 if you have the `ENGINE_load_builtin_engines' function. */
-#define HAVE_ENGINE_LOAD_BUILTIN_ENGINES 1
-
-/* Define to 1 if you have the `ENGINE_register_all_complete' function. */
-#define HAVE_ENGINE_REGISTER_ALL_COMPLETE 1
-
-/* Define to 1 if you have the `ENGINE_cleanup' function. */
-#define HAVE_ENGINE_CLEANUP 1
-
-/* gettimeofday() is implemented in otime.c for Windows */
-#define HAVE_GETTIMEOFDAY 1
-
-/* Define to 1 if you have the 'chsize' function. */
-#define HAVE_CHSIZE 1
-
-/* Define to 1 if you have the `chdir' function. */
-#define HAVE_CHDIR 1
-
-/* Define to 1 if your compiler supports GNU GCC-style variadic macros */
-#ifndef _MSC_VER /* Defines MSFT compiler version. Defined as 1200 for MSVC++ 6.0. */
-#define HAVE_CPP_VARARG_MACRO_GCC 1
-#endif
-
-/* Define to 1 if you have the <ctype.h> header file. */
-#define HAVE_CTYPE_H 1
-
-/* Define to 1 if you have the <errno.h> header file. */
-#define HAVE_ERRNO_H 1
-
-/* Define to 1 if you have the `EVP_CIPHER_CTX_set_key_length' function. */
-#define HAVE_EVP_CIPHER_CTX_SET_KEY_LENGTH 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have the `getsockopt' function. */
-#define HAVE_GETSOCKOPT 1
-
-/* Define to 1 if you have the `inet_ntoa' function. */
-#define HAVE_INET_NTOA 1
-
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
-#define HAVE_MALLOC 1
-
-/* Define to 1 if you have the `memset' function. */
-#define HAVE_MEMSET 1
-
-/* Define to 1 if you have the `setsockopt' function. */
-#define HAVE_SETSOCKOPT 1
-
-/* Define to 1 if you have the `socket' function. */
-#define HAVE_SOCKET 1
-
-/* Define to 1 if you have the <stdarg.h> header file. */
-#define HAVE_STDARG_H 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#ifndef _MSC_VER
-#define HAVE_STDINT_H 1
-#endif
-
-/* Define to 1 if you have the <stdio.h> header file. */
-#define HAVE_STDIO_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the `strerror' function. */
-#define HAVE_STRERROR 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the `system' function. */
-#define HAVE_SYSTEM 1
-
-/* Define to 1 if you have the <sys/file.h> header file. */
-#ifndef _MSC_VER
-#define HAVE_SYS_FILE_H 1
-#endif
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#ifndef _MSC_VER
-#define HAVE_SYS_TIME_H 1
-#endif
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the `time' function. */
-#define HAVE_TIME 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#ifndef _MSC_VER
-#define HAVE_UNISTD_H 1
-#endif
-
-/* Define to 1 if you have the `vsnprintf' function. */
-#define HAVE_VSNPRINTF 1
-
-/* Special Windows version of getpass() defined in io.c */
-#define HAVE_GETPASS 1
-
-/* Name of package */
-#define PACKAGE openvpn
-
-/* Define to the address where bug reports for this package should be sent. */
-//#define PACKAGE_BUGREPORT "openvpn-users@lists.sourceforge.net"
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME OpenVPN
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME openvpn
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION 2.1.1
-
-/* Define to the full name and version of this package. */
-#ifdef DEBUG_LABEL
-#define PACKAGE_STRING PACKAGE_NAME " " PACKAGE_VERSION " " DEBUG_LABEL
-#else
-#define PACKAGE_STRING PACKAGE_NAME " " PACKAGE_VERSION
-#endif
-
-/* Define as the return type of signal handlers (`int' or `void'). */
-#define RETSIGTYPE void
-
-/* The size of a `unsigned int', as computed by sizeof. */
-#define SIZEOF_UNSIGNED_INT 4
-
-/* The size of a `unsigned long', as computed by sizeof. */
-#define SIZEOF_UNSIGNED_LONG 4
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* A string representing our target */
-#ifdef _MSC_VER
-#define TARGET_ALIAS "Win32-MSVC++"
-#else
-#define TARGET_ALIAS "Win32-MinGW"
-#endif
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#ifndef _MSC_VER
-#define TIME_WITH_SYS_TIME 1
-#endif
-
-/* Use OpenSSL crypto library */
-#define USE_CRYPTO 1
-
-/* Use LZO compression library */
-#define USE_LZO 1
-
-/* LZO version number */
-#define LZO_VERSION_NUM "2"
-
-/* Use lzo/ directory prefix for LZO header files (for LZO 2.0) */
-#define LZO_HEADER_DIR 1
-
-/* Use OpenSSL SSL library */
-#define USE_SSL 1
-
-/* Version number of package */
-#define VERSION PACKAGE_VERSION
-
-/* Define as `__inline' if that's what the C compiler calls it, or to nothing
-   if it is not supported. */
-#define inline __inline
-
-/* type to use in place of socklen_t if not defined */
-#define socklen_t unsigned int
-
-/* 32-bit unsigned type */
-#define uint32_t unsigned int
-
-/* 16-bit unsigned type */
-#define uint16_t unsigned short
-
-/* 8-bit unsigned type */
-#define uint8_t unsigned char
-
-/* Route command */
-#define ROUTE_PATH "route"
-
-/* Windows doesn't support PTHREAD yet */
-#ifdef USE_PTHREAD
-#error The Windows version of OpenVPN does not support PTHREAD yet
-#endif
-
-#ifdef _MSC_VER
-/* MSVC++ hacks */
-#include <io.h>
-#include <direct.h>
-#define vsnprintf _vsnprintf
-#define vsnwprintf _vsnwprintf
-#define snwprintf _snwprintf
-#define write _write
-#define open _open
-#define read _read
-#define close _close
-#define chdir _chdir
-#define S_IRUSR 0
-#define S_IWUSR 0
-typedef int intptr_t;
-/* Visual Studio 2005 supports vararg macros */
-#if _MSC_VER >= 1400
-#define HAVE_CPP_VARARG_MACRO_ISO 1
-#endif
-#endif
diff -urN openvpn-2.1.1/config-win32.h.in openvpn-2.1.3/config-win32.h.in
--- openvpn-2.1.1/config-win32.h.in	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/config-win32.h.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,325 +0,0 @@
-/*
- *  OpenVPN -- An application to securely tunnel IP networks
- *             over a single UDP port, with support for SSL/TLS-based
- *             session authentication and key exchange,
- *             packet encryption, packet authentication, and
- *             packet compression.
- *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/*
- * Configuration header for Win32 using the mingw environment.
- * Manually edited based on linux version as generated by autoconf.
- *
- * config-win32.h is normally generated by copying
- * config-win32.h.in -> config-win32.h and replacing
- * [ampersand] VERSION [ampersand]
- * with the appropriate version #.  This is normally
- * done automatically by configure.ac
- */
-
-#include <windows.h>
-#include <winsock2.h>
-#include "autodefs/defs.h"
-
-#define sleep(x) Sleep((x)*1000)
-
-#define random rand
-#define srandom srand
-
-typedef unsigned long in_addr_t;
-
-#ifndef _SSIZE_T_
-#define _SSIZE_T_
- typedef unsigned int ssize_t;
-#endif
-
-/* Append a label to program startup title */
-/*#define DEBUG_LABEL "DEBUG1"*/
-
-/* Should we print debug info from driver? */
-#ifdef PRODUCT_TAP_DEBUG
-#define TAP_WIN32_DEBUG
-#endif
-
-/*
- * Minimum TAP-Win32 version number expected by userspace
- *
- * The TAP-Win32 version number is defined in tap-win32/SOURCES
- */
-#define TAP_ID @TAP_ID@
-#define TAP_WIN32_MIN_MAJOR @TAP_WIN32_MIN_MAJOR@
-#define TAP_WIN32_MIN_MINOR @TAP_WIN32_MIN_MINOR@
-
-/* Enable client/server capability */
-#define ENABLE_CLIENT_SERVER 1
-
-/* Enable client capability only */
-/* #undef ENABLE_CLIENT_ONLY */
-
-/* Enable management server capability */
-#define ENABLE_MANAGEMENT 1
-
-/* Enable PKCS#11 support */
-#define USE_PKCS11 1
-
-/* Enable HTTP proxy support */
-#define ENABLE_HTTP_PROXY 1
-
-/* Enable Socks proxy support */
-#define ENABLE_SOCKS 1
-
-/* Enable internal fragmentation support */
-#define ENABLE_FRAGMENT 1
-
-/* Enable smaller executable size */
-/* #undef ENABLE_SMALL */
-
-/* Enable debugging support */
-#define ENABLE_DEBUG 1
-
-/* if defined, will allow usage of the --plugin directive */
-#define USE_LOAD_LIBRARY
-
-/* Dimension size to use for empty array declaration */
-#define EMPTY_ARRAY_SIZE 0
-
-/* Define to 1 if you have the `getsockname' function. */
-#define HAVE_GETSOCKNAME 1
-
-/* Define to 1 if you have the <openssl/engine.h> header file. */
-#define HAVE_OPENSSL_ENGINE_H 1
-
-/* Define to 1 if you have the `ENGINE_load_builtin_engines' function. */
-#define HAVE_ENGINE_LOAD_BUILTIN_ENGINES 1
-
-/* Define to 1 if you have the `ENGINE_register_all_complete' function. */
-#define HAVE_ENGINE_REGISTER_ALL_COMPLETE 1
-
-/* Define to 1 if you have the `ENGINE_cleanup' function. */
-#define HAVE_ENGINE_CLEANUP 1
-
-/* gettimeofday() is implemented in otime.c for Windows */
-#define HAVE_GETTIMEOFDAY 1
-
-/* Define to 1 if you have the 'chsize' function. */
-#define HAVE_CHSIZE 1
-
-/* Define to 1 if you have the `chdir' function. */
-#define HAVE_CHDIR 1
-
-/* Define to 1 if your compiler supports GNU GCC-style variadic macros */
-#ifndef _MSC_VER /* Defines MSFT compiler version. Defined as 1200 for MSVC++ 6.0. */
-#define HAVE_CPP_VARARG_MACRO_GCC 1
-#endif
-
-/* Define to 1 if you have the <ctype.h> header file. */
-#define HAVE_CTYPE_H 1
-
-/* Define to 1 if you have the <errno.h> header file. */
-#define HAVE_ERRNO_H 1
-
-/* Define to 1 if you have the `EVP_CIPHER_CTX_set_key_length' function. */
-#define HAVE_EVP_CIPHER_CTX_SET_KEY_LENGTH 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have the `getsockopt' function. */
-#define HAVE_GETSOCKOPT 1
-
-/* Define to 1 if you have the `inet_ntoa' function. */
-#define HAVE_INET_NTOA 1
-
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
-#define HAVE_MALLOC 1
-
-/* Define to 1 if you have the `memset' function. */
-#define HAVE_MEMSET 1
-
-/* Define to 1 if you have the `setsockopt' function. */
-#define HAVE_SETSOCKOPT 1
-
-/* Define to 1 if you have the `socket' function. */
-#define HAVE_SOCKET 1
-
-/* Define to 1 if you have the <stdarg.h> header file. */
-#define HAVE_STDARG_H 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#ifndef _MSC_VER
-#define HAVE_STDINT_H 1
-#endif
-
-/* Define to 1 if you have the <stdio.h> header file. */
-#define HAVE_STDIO_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the `strerror' function. */
-#define HAVE_STRERROR 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the `system' function. */
-#define HAVE_SYSTEM 1
-
-/* Define to 1 if you have the <sys/file.h> header file. */
-#ifndef _MSC_VER
-#define HAVE_SYS_FILE_H 1
-#endif
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#ifndef _MSC_VER
-#define HAVE_SYS_TIME_H 1
-#endif
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the `time' function. */
-#define HAVE_TIME 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#ifndef _MSC_VER
-#define HAVE_UNISTD_H 1
-#endif
-
-/* Define to 1 if you have the `vsnprintf' function. */
-#define HAVE_VSNPRINTF 1
-
-/* Special Windows version of getpass() defined in io.c */
-#define HAVE_GETPASS 1
-
-/* Name of package */
-#define PACKAGE @PACKAGE@
-
-/* Define to the address where bug reports for this package should be sent. */
-//#define PACKAGE_BUGREPORT "openvpn-users@lists.sourceforge.net"
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME @PACKAGE_NAME@
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME @PACKAGE_TARNAME@
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION @PACKAGE_VERSION@
-
-/* Define to the full name and version of this package. */
-#ifdef DEBUG_LABEL
-#define PACKAGE_STRING PACKAGE_NAME " " PACKAGE_VERSION " " DEBUG_LABEL
-#else
-#define PACKAGE_STRING PACKAGE_NAME " " PACKAGE_VERSION
-#endif
-
-/* Define as the return type of signal handlers (`int' or `void'). */
-#define RETSIGTYPE void
-
-/* The size of a `unsigned int', as computed by sizeof. */
-#define SIZEOF_UNSIGNED_INT 4
-
-/* The size of a `unsigned long', as computed by sizeof. */
-#define SIZEOF_UNSIGNED_LONG 4
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* A string representing our target */
-#ifdef _MSC_VER
-#define TARGET_ALIAS "Win32-MSVC++"
-#else
-#define TARGET_ALIAS "Win32-MinGW"
-#endif
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#ifndef _MSC_VER
-#define TIME_WITH_SYS_TIME 1
-#endif
-
-/* Use OpenSSL crypto library */
-#define USE_CRYPTO 1
-
-/* Use LZO compression library */
-#define USE_LZO 1
-
-/* LZO version number */
-#define LZO_VERSION_NUM "2"
-
-/* Use lzo/ directory prefix for LZO header files (for LZO 2.0) */
-#define LZO_HEADER_DIR 1
-
-/* Use OpenSSL SSL library */
-#define USE_SSL 1
-
-/* Version number of package */
-#define VERSION PACKAGE_VERSION
-
-/* Define as `__inline' if that's what the C compiler calls it, or to nothing
-   if it is not supported. */
-#define inline __inline
-
-/* type to use in place of socklen_t if not defined */
-#define socklen_t unsigned int
-
-/* 32-bit unsigned type */
-#define uint32_t unsigned int
-
-/* 16-bit unsigned type */
-#define uint16_t unsigned short
-
-/* 8-bit unsigned type */
-#define uint8_t unsigned char
-
-/* Route command */
-#define ROUTE_PATH "route"
-
-/* Windows doesn't support PTHREAD yet */
-#ifdef USE_PTHREAD
-#error The Windows version of OpenVPN does not support PTHREAD yet
-#endif
-
-#ifdef _MSC_VER
-/* MSVC++ hacks */
-#include <io.h>
-#include <direct.h>
-#define vsnprintf _vsnprintf
-#define vsnwprintf _vsnwprintf
-#define snwprintf _snwprintf
-#define write _write
-#define open _open
-#define read _read
-#define close _close
-#define chdir _chdir
-#define S_IRUSR 0
-#define S_IWUSR 0
-typedef int intptr_t;
-/* Visual Studio 2005 supports vararg macros */
-#if _MSC_VER >= 1400
-#define HAVE_CPP_VARARG_MACRO_ISO 1
-#endif
-#endif
diff -urN openvpn-2.1.1/configure openvpn-2.1.3/configure
--- openvpn-2.1.1/configure	2009-12-12 00:27:03.000000000 +0100
+++ openvpn-2.1.3/configure	2010-08-27 18:10:00.000000000 +0200
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.61 for OpenVPN 2.1.1.
+# Generated by GNU Autoconf 2.61 for OpenVPN 2.1.3.
 #
 # Report bugs to <openvpn-users@lists.sourceforge.net>.
 #
@@ -574,8 +574,8 @@
 # Identity of this package.
 PACKAGE_NAME='OpenVPN'
 PACKAGE_TARNAME='openvpn'
-PACKAGE_VERSION='2.1.1'
-PACKAGE_STRING='OpenVPN 2.1.1'
+PACKAGE_VERSION='2.1.3'
+PACKAGE_STRING='OpenVPN 2.1.3'
 PACKAGE_BUGREPORT='openvpn-users@lists.sourceforge.net'
 
 ac_unique_file="syshead.h"
@@ -1233,7 +1233,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures OpenVPN 2.1.1 to adapt to many kinds of systems.
+\`configure' configures OpenVPN 2.1.3 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1304,7 +1304,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of OpenVPN 2.1.1:";;
+     short | recursive ) echo "Configuration of OpenVPN 2.1.3:";;
    esac
   cat <<\_ACEOF
 
@@ -1429,7 +1429,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-OpenVPN configure 2.1.1
+OpenVPN configure 2.1.3
 generated by GNU Autoconf 2.61
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
@@ -1443,7 +1443,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by OpenVPN $as_me 2.1.1, which was
+It was created by OpenVPN $as_me 2.1.3, which was
 generated by GNU Autoconf 2.61.  Invocation command line was
 
   $ $0 $@
@@ -13104,7 +13104,7 @@
 fi
 # end workaround
 
-ac_config_files="$ac_config_files Makefile openvpn.spec config-win32.h images/Makefile service-win32/Makefile install-win32/Makefile install-win32/settings"
+ac_config_files="$ac_config_files Makefile openvpn.spec images/Makefile service-win32/Makefile install-win32/Makefile install-win32/settings"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -13523,7 +13523,7 @@
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by OpenVPN $as_me 2.1.1, which was
+This file was extended by OpenVPN $as_me 2.1.3, which was
 generated by GNU Autoconf 2.61.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -13576,7 +13576,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-OpenVPN config.status 2.1.1
+OpenVPN config.status 2.1.3
 configured by $0, generated by GNU Autoconf 2.61,
   with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
@@ -13694,7 +13694,6 @@
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
     "openvpn.spec") CONFIG_FILES="$CONFIG_FILES openvpn.spec" ;;
-    "config-win32.h") CONFIG_FILES="$CONFIG_FILES config-win32.h" ;;
     "images/Makefile") CONFIG_FILES="$CONFIG_FILES images/Makefile" ;;
     "service-win32/Makefile") CONFIG_FILES="$CONFIG_FILES service-win32/Makefile" ;;
     "install-win32/Makefile") CONFIG_FILES="$CONFIG_FILES install-win32/Makefile" ;;
diff -urN openvpn-2.1.1/configure.ac openvpn-2.1.3/configure.ac
--- openvpn-2.1.1/configure.ac	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/configure.ac	2010-04-28 18:25:38.000000000 +0200
@@ -4,7 +4,7 @@
 dnl             packet encryption, packet authentication, and
 dnl             packet compression.
 dnl
-dnl  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+dnl  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 dnl
 dnl  This program is free software; you can redistribute it and/or modify
 dnl  it under the terms of the GNU General Public License as published by
@@ -914,7 +914,6 @@
 AC_OUTPUT([
 	Makefile
 	openvpn.spec
-	config-win32.h
 	images/Makefile
 	service-win32/Makefile
 	install-win32/Makefile
diff -urN openvpn-2.1.1/contrib/pull-resolv-conf/client.down openvpn-2.1.3/contrib/pull-resolv-conf/client.down
--- openvpn-2.1.1/contrib/pull-resolv-conf/client.down	2009-10-01 20:02:17.000000000 +0200
+++ openvpn-2.1.3/contrib/pull-resolv-conf/client.down	2010-04-28 18:25:38.000000000 +0200
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-# Copyright (c) 2005-2009 OpenVPN Technologies, Inc.
+# Copyright (c) 2005-2010 OpenVPN Technologies, Inc.
 # Licensed under the GPL version 2
 
 # First version by Jesse Adelman
diff -urN openvpn-2.1.1/contrib/pull-resolv-conf/client.up openvpn-2.1.3/contrib/pull-resolv-conf/client.up
--- openvpn-2.1.1/contrib/pull-resolv-conf/client.up	2009-10-01 20:02:17.000000000 +0200
+++ openvpn-2.1.3/contrib/pull-resolv-conf/client.up	2010-04-28 18:25:38.000000000 +0200
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-# Copyright (c) 2005-2009 OpenVPN Technologies, Inc.
+# Copyright (c) 2005-2010 OpenVPN Technologies, Inc.
 # Licensed under the GPL version 2
 
 # First version by Jesse Adelman
diff -urN openvpn-2.1.1/crypto.c openvpn-2.1.3/crypto.c
--- openvpn-2.1.1/crypto.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/crypto.c	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -985,8 +985,8 @@
 #endif
 
 /* header and footer for static key file */
-static const char static_key_head[] = "-----BEGIN " PACKAGE_NAME " Static key V1-----";
-static const char static_key_foot[] = "-----END " PACKAGE_NAME " Static key V1-----";
+static const char static_key_head[] = "-----BEGIN OpenVPN Static key V1-----";
+static const char static_key_foot[] = "-----END OpenVPN Static key V1-----";
 
 static const char printable_char_fmt[] =
   "Non-Hex character ('%c') found at line %d in key file '%s' (%d/%d/%d bytes found/min/max)";
@@ -1065,8 +1065,8 @@
       const unsigned char c = *cp;
 
 #if 0
-      msg (M_INFO, "char='%c' s=%d ln=%d li=%d m=%d c=%d",
-	   c, state, line_num, line_index, match, count);
+      msg (M_INFO, "char='%c'[%d] s=%d ln=%d li=%d m=%d c=%d",
+	   c, (int)c, state, line_num, line_index, match, count);
 #endif
 
       if (c == '\n')
@@ -1150,7 +1150,7 @@
   if (flags & RKF_MUST_SUCCEED)
     {
       if (!key2->n)
-	msg (M_FATAL, "Insufficient key material or header text not found found in file '%s' (%d/%d/%d bytes found/min/max)",
+	msg (M_FATAL, "Insufficient key material or header text not found in file '%s' (%d/%d/%d bytes found/min/max)",
 	     error_filename, count, onekeylen, keylen);
 
       if (state != PARSE_FINISHED)
@@ -1297,7 +1297,7 @@
   buf_printf (&out, "%s\n", static_key_foot);
 
   /* write number of bits */
-  buf_printf (&nbits_head_text, "#\n# %d bit " PACKAGE_NAME " static key\n#\n", nbits);
+  buf_printf (&nbits_head_text, "#\n# %d bit OpenVPN static key\n#\n", nbits);
   buf_write_string_file (&nbits_head_text, filename, fd);
 
   /* write key file, now formatted in out, to file */
diff -urN openvpn-2.1.1/crypto.h openvpn-2.1.3/crypto.h
--- openvpn-2.1.1/crypto.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/crypto.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/dhcp.c openvpn-2.1.3/dhcp.c
--- openvpn-2.1.1/dhcp.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/dhcp.c	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/dhcp.h openvpn-2.1.3/dhcp.h
--- openvpn-2.1.1/dhcp.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/dhcp.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/doclean openvpn-2.1.3/doclean
--- openvpn-2.1.1/doclean	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/doclean	2010-04-17 04:19:41.000000000 +0200
@@ -37,7 +37,6 @@
     openvpn.spec \
     install-sh \
     openvpn.8.html \
-    config-win32.h \
     install-win32/*.exe \
     install-win32/makensis.log \
     install-win32/settings \
diff -urN openvpn-2.1.1/easy-rsa/2.0/pkitool openvpn-2.1.3/easy-rsa/2.0/pkitool
--- openvpn-2.1.1/easy-rsa/2.0/pkitool	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/easy-rsa/2.0/pkitool	2010-04-28 18:25:38.000000000 +0200
@@ -6,7 +6,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+#  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/errlevel.h openvpn-2.1.3/errlevel.h
--- openvpn-2.1.1/errlevel.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/errlevel.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/error.c openvpn-2.1.3/error.c
--- openvpn-2.1.1/error.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/error.c	2010-07-27 23:44:34.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -477,14 +477,16 @@
     {
       HANDLE log_handle;
       int log_fd;
-      struct security_attributes sa;
 
-      init_security_attributes_allow_all (&sa);
+      SECURITY_ATTRIBUTES saAttr; 
+      saAttr.nLength = sizeof(SECURITY_ATTRIBUTES); 
+      saAttr.bInheritHandle = TRUE; 
+      saAttr.lpSecurityDescriptor = NULL; 
 
       log_handle = CreateFile (file,
 			       GENERIC_WRITE,
 			       FILE_SHARE_READ,
-			       &sa.sa,
+			       &saAttr,
 			       append ? OPEN_ALWAYS : CREATE_ALWAYS,
 			       FILE_ATTRIBUTE_NORMAL,
 			       NULL);
@@ -505,10 +507,12 @@
       /* save original stderr for password prompts */
       orig_stderr = GetStdHandle (STD_ERROR_HANDLE);
 
+#if 0 /* seems not be necessary with stdout/stderr redirection below*/
       /* set up for redirection */
       if (!SetStdHandle (STD_OUTPUT_HANDLE, log_handle)
 	  || !SetStdHandle (STD_ERROR_HANDLE, log_handle))
 	msg (M_ERR, "Error: cannot redirect stdout/stderr to --log file: %s", file);
+#endif
 
       /* direct stdout/stderr to point to log_handle */
       log_fd = _open_osfhandle ((intptr_t)log_handle, _O_TEXT);
@@ -521,6 +525,10 @@
       if (msgfp == NULL)
 	msg (M_ERR, "Error: --log redirect failed due to _fdopen");
 
+      /* redirect C-library stdout/stderr to log file */
+      if (_dup2 (log_fd, 1) == -1 || _dup2 (log_fd, 2) == -1)
+	msg (M_WARN, "Error: --log redirect of stdout/stderr failed");
+
       std_redir = true;
     }
 #elif defined(HAVE_DUP2)
@@ -682,10 +690,13 @@
 void
 openvpn_exit (const int status)
 {
+  void tun_abort();
 #ifdef ENABLE_PLUGIN
   void plugin_abort (void);
 #endif
 
+  tun_abort();
+
 #ifdef WIN32
   uninit_win32 ();
 #endif
diff -urN openvpn-2.1.1/error.h openvpn-2.1.3/error.h
--- openvpn-2.1.1/error.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/error.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/event.c openvpn-2.1.3/event.c
--- openvpn-2.1.1/event.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/event.c	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/event.h openvpn-2.1.3/event.h
--- openvpn-2.1.1/event.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/event.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/fdmisc.c openvpn-2.1.3/fdmisc.c
--- openvpn-2.1.1/fdmisc.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/fdmisc.c	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/fdmisc.h openvpn-2.1.3/fdmisc.h
--- openvpn-2.1.1/fdmisc.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/fdmisc.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/forward-inline.h openvpn-2.1.3/forward-inline.h
--- openvpn-2.1.1/forward-inline.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/forward-inline.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/forward.c openvpn-2.1.3/forward.c
--- openvpn-2.1.1/forward.c	2009-11-20 14:09:14.000000000 +0100
+++ openvpn-2.1.3/forward.c	2010-07-27 08:11:14.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -687,14 +687,25 @@
 	if (c->options.inetd)
 	  {
 	    c->sig->signal_received = SIGTERM;
+	    c->sig->signal_text = "connection-reset-inetd";
 	    msg (D_STREAM_ERRORS, "Connection reset, inetd/xinetd exit [%d]", status);
 	  }
 	else
 	  {
-	    c->sig->signal_received = SIGUSR1; /* SOFT-SIGUSR1 -- TCP connection reset */
-	    msg (D_STREAM_ERRORS, "Connection reset, restarting [%d]", status);
+#ifdef ENABLE_OCC
+	    if (event_timeout_defined(&c->c2.explicit_exit_notification_interval))
+	      {
+		msg (D_STREAM_ERRORS, "Connection reset during exit notification period, ignoring [%d]", status);
+		openvpn_sleep(1);
+	      }
+	    else
+#endif
+	      {
+		c->sig->signal_received = SIGUSR1; /* SOFT-SIGUSR1 -- TCP connection reset */
+		c->sig->signal_text = "connection-reset";
+		msg (D_STREAM_ERRORS, "Connection reset, restarting [%d]", status);
+	      }
 	  }
-	c->sig->signal_text = "connection-reset";
       }
       perf_pop ();
       return;
diff -urN openvpn-2.1.1/forward.h openvpn-2.1.3/forward.h
--- openvpn-2.1.1/forward.h	2009-10-01 21:35:38.000000000 +0200
+++ openvpn-2.1.3/forward.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/fragment.c openvpn-2.1.3/fragment.c
--- openvpn-2.1.1/fragment.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/fragment.c	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/fragment.h openvpn-2.1.3/fragment.h
--- openvpn-2.1.1/fragment.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/fragment.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/gremlin.c openvpn-2.1.3/gremlin.c
--- openvpn-2.1.1/gremlin.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/gremlin.c	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/gremlin.h openvpn-2.1.3/gremlin.h
--- openvpn-2.1.1/gremlin.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/gremlin.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/helper.c openvpn-2.1.3/helper.c
--- openvpn-2.1.1/helper.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/helper.c	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/helper.h openvpn-2.1.3/helper.h
--- openvpn-2.1.1/helper.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/helper.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/httpdigest.c openvpn-2.1.3/httpdigest.c
--- openvpn-2.1.1/httpdigest.c	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/httpdigest.c	2010-05-11 21:38:31.000000000 +0200
@@ -0,0 +1,143 @@
+/*
+ *  OpenVPN -- An application to securely tunnel IP networks
+ *             over a single TCP/UDP port, with support for SSL/TLS-based
+ *             session authentication and key exchange,
+ *             packet encryption, packet authentication, and
+ *             packet compression.
+ *
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program (see the file COPYING included with this
+ *  distribution); if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "syshead.h"
+
+#if PROXY_DIGEST_AUTH
+
+#include "crypto.h"
+#include "httpdigest.h"
+
+static void
+CvtHex(
+       IN HASH Bin,
+       OUT HASHHEX Hex
+       )
+{
+  unsigned short i;
+  unsigned char j;
+
+  for (i = 0; i < HASHLEN; i++) {
+    j = (Bin[i] >> 4) & 0xf;
+    if (j <= 9)
+      Hex[i*2] = (j + '0');
+    else
+      Hex[i*2] = (j + 'a' - 10);
+    j = Bin[i] & 0xf;
+    if (j <= 9)
+      Hex[i*2+1] = (j + '0');
+    else
+      Hex[i*2+1] = (j + 'a' - 10);
+  };
+  Hex[HASHHEXLEN] = '\0';
+};
+
+/* calculate H(A1) as per spec */
+void
+DigestCalcHA1(
+	      IN char * pszAlg,
+	      IN char * pszUserName,
+	      IN char * pszRealm,
+	      IN char * pszPassword,
+	      IN char * pszNonce,
+	      IN char * pszCNonce,
+	      OUT HASHHEX SessionKey
+	      )
+{
+  MD5_CTX Md5Ctx;
+  HASH HA1;
+
+  MD5_Init(&Md5Ctx);
+  MD5_Update(&Md5Ctx, pszUserName, strlen(pszUserName));
+  MD5_Update(&Md5Ctx, ":", 1);
+  MD5_Update(&Md5Ctx, pszRealm, strlen(pszRealm));
+  MD5_Update(&Md5Ctx, ":", 1);
+  MD5_Update(&Md5Ctx, pszPassword, strlen(pszPassword));
+  MD5_Final(HA1, &Md5Ctx);
+  if (pszAlg && strcasecmp(pszAlg, "md5-sess") == 0)
+    {
+      MD5_Init(&Md5Ctx);
+      MD5_Update(&Md5Ctx, HA1, HASHLEN);
+      MD5_Update(&Md5Ctx, ":", 1);
+      MD5_Update(&Md5Ctx, pszNonce, strlen(pszNonce));
+      MD5_Update(&Md5Ctx, ":", 1);
+      MD5_Update(&Md5Ctx, pszCNonce, strlen(pszCNonce));
+      MD5_Final(HA1, &Md5Ctx);
+    };
+  CvtHex(HA1, SessionKey);
+}
+
+/* calculate request-digest/response-digest as per HTTP Digest spec */
+void
+DigestCalcResponse(
+		   IN HASHHEX HA1,           /* H(A1) */
+		   IN char * pszNonce,       /* nonce from server */
+		   IN char * pszNonceCount,  /* 8 hex digits */
+		   IN char * pszCNonce,      /* client nonce */
+		   IN char * pszQop,         /* qop-value: "", "auth", "auth-int" */
+		   IN char * pszMethod,      /* method from the request */
+		   IN char * pszDigestUri,   /* requested URL */
+		   IN HASHHEX HEntity,       /* H(entity body) if qop="auth-int" */
+		   OUT HASHHEX Response      /* request-digest or response-digest */
+		   )
+{
+  MD5_CTX Md5Ctx;
+  HASH HA2;
+  HASH RespHash;
+  HASHHEX HA2Hex;
+
+  // calculate H(A2)
+  MD5_Init(&Md5Ctx);
+  MD5_Update(&Md5Ctx, pszMethod, strlen(pszMethod));
+  MD5_Update(&Md5Ctx, ":", 1);
+  MD5_Update(&Md5Ctx, pszDigestUri, strlen(pszDigestUri));
+  if (strcasecmp(pszQop, "auth-int") == 0)
+    {
+      MD5_Update(&Md5Ctx, ":", 1);
+      MD5_Update(&Md5Ctx, HEntity, HASHHEXLEN);
+    };
+  MD5_Final(HA2, &Md5Ctx);
+  CvtHex(HA2, HA2Hex);
+
+  // calculate response
+  MD5_Init(&Md5Ctx);
+  MD5_Update(&Md5Ctx, HA1, HASHHEXLEN);
+  MD5_Update(&Md5Ctx, ":", 1);
+  MD5_Update(&Md5Ctx, pszNonce, strlen(pszNonce));
+  MD5_Update(&Md5Ctx, ":", 1);
+  if (*pszQop)
+    {
+      MD5_Update(&Md5Ctx, pszNonceCount, strlen(pszNonceCount));
+      MD5_Update(&Md5Ctx, ":", 1);
+      MD5_Update(&Md5Ctx, pszCNonce, strlen(pszCNonce));
+      MD5_Update(&Md5Ctx, ":", 1);
+      MD5_Update(&Md5Ctx, pszQop, strlen(pszQop));
+      MD5_Update(&Md5Ctx, ":", 1);
+    };
+  MD5_Update(&Md5Ctx, HA2Hex, HASHHEXLEN);
+  MD5_Final(RespHash, &Md5Ctx);
+  CvtHex(RespHash, Response);
+}
+
+#endif
diff -urN openvpn-2.1.1/httpdigest.h openvpn-2.1.3/httpdigest.h
--- openvpn-2.1.1/httpdigest.h	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/httpdigest.h	2010-05-11 21:37:32.000000000 +0200
@@ -0,0 +1,60 @@
+/*
+ *  OpenVPN -- An application to securely tunnel IP networks
+ *             over a single TCP/UDP port, with support for SSL/TLS-based
+ *             session authentication and key exchange,
+ *             packet encryption, packet authentication, and
+ *             packet compression.
+ *
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program (see the file COPYING included with this
+ *  distribution); if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if PROXY_DIGEST_AUTH
+
+#define HASHLEN 16
+typedef unsigned char HASH[HASHLEN];
+#define HASHHEXLEN 32
+typedef unsigned char HASHHEX[HASHHEXLEN+1];
+#undef IN
+#undef OUT
+#define IN const
+#define OUT
+
+/* calculate H(A1) as per HTTP Digest spec */
+void DigestCalcHA1(
+    IN char * pszAlg,
+    IN char * pszUserName,
+    IN char * pszRealm,
+    IN char * pszPassword,
+    IN char * pszNonce,
+    IN char * pszCNonce,
+    OUT HASHHEX SessionKey
+    );
+
+/* calculate request-digest/response-digest as per HTTP Digest spec */
+void DigestCalcResponse(
+    IN HASHHEX HA1,           /* H(A1) */
+    IN char * pszNonce,       /* nonce from server */
+    IN char * pszNonceCount,  /* 8 hex digits */
+    IN char * pszCNonce,      /* client nonce */
+    IN char * pszQop,         /* qop-value: "", "auth", "auth-int" */
+    IN char * pszMethod,      /* method from the request */
+    IN char * pszDigestUri,   /* requested URL */
+    IN HASHHEX HEntity,       /* H(entity body) if qop="auth-int" */
+    OUT HASHHEX Response      /* request-digest or response-digest */
+    );
+
+#endif
diff -urN openvpn-2.1.1/images/Makefile.am openvpn-2.1.3/images/Makefile.am
--- openvpn-2.1.1/images/Makefile.am	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/images/Makefile.am	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+#  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/images/Makefile.in openvpn-2.1.3/images/Makefile.in
--- openvpn-2.1.1/images/Makefile.in	2009-12-12 00:27:05.000000000 +0100
+++ openvpn-2.1.3/images/Makefile.in	2010-08-27 18:10:02.000000000 +0200
@@ -21,7 +21,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+#  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/init.c openvpn-2.1.3/init.c
--- openvpn-2.1.1/init.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/init.c	2010-07-21 21:08:41.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -41,6 +41,8 @@
 
 #include "occ-inline.h"
 
+static struct context *static_context; /* GLOBAL */
+
 /*
  * Crypto initialization flags
  */
@@ -109,6 +111,101 @@
 #endif
 }
 
+#if HTTP_PROXY_FALLBACK
+
+static bool
+ce_http_proxy_fallback_defined(const struct context *c)
+{
+  const struct connection_list *l = c->options.connection_list;
+  if (l && l->current == 0)
+    {
+      int i;
+      for (i = 0; i < l->len; ++i)
+	{
+	  const struct connection_entry *ce = l->array[i];
+	  if (ce->flags & CE_HTTP_PROXY_FALLBACK)
+	    return true;
+	}
+    }
+  return false;
+}
+
+static void
+ce_http_proxy_fallback_start(struct context *c, const char *remote_ip_hint)
+{
+  const struct connection_list *l = c->options.connection_list;
+  if (l)
+    {
+      int i;
+      for (i = 0; i < l->len; ++i)
+	{
+	  struct connection_entry *ce = l->array[i];
+	  if (ce->flags & CE_HTTP_PROXY_FALLBACK)
+	    {
+	      ce->http_proxy_options = NULL;
+	      ce->ce_http_proxy_fallback_timestamp = 0;
+	      if (!remote_ip_hint)
+		remote_ip_hint = ce->remote;
+	    }
+	}
+    }
+
+  if (management)
+    management_http_proxy_fallback_notify(management, "NEED_LATER", remote_ip_hint);
+}
+
+static bool
+ce_http_proxy_fallback (struct context *c, volatile const struct connection_entry *ce)
+{
+  const int proxy_info_expire = 120; /* seconds before proxy info expires */
+
+  update_time();
+  if (management)
+    {
+      if (!ce->ce_http_proxy_fallback_timestamp)
+	{
+	  management_http_proxy_fallback_notify(management, "NEED_NOW", NULL);
+	  while (!ce->ce_http_proxy_fallback_timestamp)
+	    {
+	      management_event_loop_n_seconds (management, 1);
+	      if (IS_SIG (c))
+		return false;
+	    }
+	}
+      return (now < ce->ce_http_proxy_fallback_timestamp + proxy_info_expire && ce->http_proxy_options);
+    }
+  return false;
+}
+
+static bool
+management_callback_http_proxy_fallback_cmd (void *arg, const char *server, const char *port, const char *flags)
+{
+  struct context *c = (struct context *) arg;
+  const struct connection_list *l = c->options.connection_list;
+  int ret = false;
+  struct http_proxy_options *ho = parse_http_proxy_fallback (c, server, port, flags, M_WARN);
+
+  update_time();
+  if (l)
+    {
+      int i;
+      for (i = 0; i < l->len; ++i)
+	{
+	  struct connection_entry *ce = l->array[i];
+	  if (ce->flags & CE_HTTP_PROXY_FALLBACK)
+	    {
+	      ce->http_proxy_options = ho;
+	      ce->ce_http_proxy_fallback_timestamp = now;
+	      ret = true;
+	    }
+	}
+    }
+  
+  return ret;
+}
+
+#endif
+
 /*
  * Initialize and possibly randomize connection list.
  */
@@ -139,6 +236,30 @@
 #endif
 }
 
+#if 0 /* fixme -- disable for production */
+static void
+show_connection_list (const struct connection_list *l)
+{
+  int i;
+  dmsg (M_INFO, "CONNECTION_LIST len=%d current=%d",
+	l->len, l->current);
+  for (i = 0; i < l->len; ++i)
+    {
+      dmsg (M_INFO, "[%d] %s:%d proto=%s http_proxy=%d",
+	    i,
+	    l->array[i]->remote,
+	    l->array[i]->remote_port,
+	    proto2ascii(l->array[i]->proto, true),
+	    BOOL_CAST(l->array[i]->http_proxy_options));
+    }
+}
+#else
+static inline void
+show_connection_list (const struct connection_list *l)
+{
+}
+#endif
+
 /*
  * Increment to next connection entry
  */
@@ -149,27 +270,66 @@
   struct connection_list *l = c->options.connection_list;
   if (l)
     {
-      if (l->no_advance && l->current >= 0)
-	{
-	  l->no_advance = false;
-	}
-      else
-	{
-	  int i;
-	  if (++l->current >= l->len)
-	    l->current = 0;
+      bool ce_defined;
+      struct connection_entry *ce;
+      int n_cycles = 0;
+
+      do {
+	const char *remote_ip_hint = NULL;
+	bool newcycle = false;
 
-	  dmsg (D_CONNECTION_LIST, "CONNECTION_LIST len=%d current=%d",
-		l->len, l->current);
-	  for (i = 0; i < l->len; ++i)
-	    {
-	      dmsg (D_CONNECTION_LIST, "[%d] %s:%d",
-		    i,
-		    l->array[i]->remote,
-		    l->array[i]->remote_port);
-	    }
-	}
-      c->options.ce = *l->array[l->current];
+	ce_defined = true;
+	if (l->no_advance && l->current >= 0)
+	  {
+	    l->no_advance = false;
+	  }
+	else
+	  {
+	    if (++l->current >= l->len)
+	      {
+		l->current = 0;
+		++l->n_cycles;
+		if (++n_cycles >= 2)
+		  msg (M_FATAL, "No usable connection profiles are present");
+	      }
+
+	    if (l->current == 0)
+	      newcycle = true;
+	    show_connection_list(l);
+	  }
+
+	ce = l->array[l->current];
+
+	if (c->options.remote_ip_hint && !l->n_cycles)
+	  remote_ip_hint = c->options.remote_ip_hint;
+
+#if HTTP_PROXY_FALLBACK
+	if (newcycle && ce_http_proxy_fallback_defined(c))
+	  ce_http_proxy_fallback_start(c, remote_ip_hint);
+
+	if (ce->flags & CE_HTTP_PROXY_FALLBACK)
+	  {
+	    ce_defined = ce_http_proxy_fallback(c, ce);
+	    if (IS_SIG (c))
+	      break;
+	  }
+#endif
+
+	if (ce->flags & CE_DISABLED)
+	  ce_defined = false;
+
+	c->options.ce = *ce;
+
+	if (remote_ip_hint)
+	  c->options.ce.remote = remote_ip_hint;
+
+#if 0 /* fixme -- disable for production, this code simulates a network where proxy fallback is the only method to reach the OpenVPN server */
+	if (!(c->options.ce.flags & CE_HTTP_PROXY_FALLBACK))
+	  {
+	    c->options.ce.remote = "10.10.0.1"; /* use an unreachable address here */
+	  }
+#endif
+      } while (!ce_defined);
     }
 #endif
   update_options_ce_post (&c->options);
@@ -497,6 +657,60 @@
   }
 #endif
 
+#ifdef BUFFER_LIST_AGGREGATE_TEST
+  /* test buffer_list_aggregate function */
+  {
+    static const char *text[] = {
+      "It was a bright cold day in April, ",
+      "and the clocks were striking ",
+      "thirteen. ",
+      "Winston Smith, ",
+      "his chin nuzzled into his breast in an ",
+      "effort to escape the vile wind, ",
+      "slipped quickly through the glass doors ",
+      "of Victory Mansions, though not quickly ",
+      "enough to prevent a swirl of gritty dust from ",
+      "entering along with him."
+    };
+
+    int iter, listcap;
+    for (listcap = 0; listcap < 12; ++listcap)
+      {
+	for (iter = 0; iter < 512; ++iter)
+	  {
+	    struct buffer_list *bl = buffer_list_new(listcap);
+	    {
+	      int i;
+	      for (i = 0; i < SIZE(text); ++i)
+		buffer_list_push(bl, (unsigned char *)text[i]);
+	    }
+	    printf("[cap=%d i=%d] *************************\n", listcap, iter);
+	    if (!(iter & 8))
+	      buffer_list_aggregate(bl, iter/2);
+	    if (!(iter & 16))
+	      buffer_list_push(bl, (unsigned char *)"Even more text...");
+	    buffer_list_aggregate(bl, iter);
+	    if (!(iter & 1))
+	      buffer_list_push(bl, (unsigned char *)"More text...");
+	    {
+	      struct buffer *buf;
+	      while ((buf = buffer_list_peek(bl)))
+		{
+		  int c;
+		  printf ("'");
+		  while ((c = buf_read_u8(buf)) >= 0)
+		    putchar(c);
+		  printf ("'\n");
+		  buffer_list_advance(bl, 0);
+		}
+	    }
+	    buffer_list_free(bl);
+	  }
+      }
+    return false;
+  }
+#endif
+
   return true;
 }
 
@@ -924,6 +1138,10 @@
   if ((flags & (ISC_ERRORS|ISC_SERVER)) == 0 && connection_list_defined (&c->options))
     connection_list_set_no_advance (&c->options);
 
+#ifdef WIN32
+  fork_register_dns_action (c->c1.tuntap);
+#endif
+
 #ifdef ENABLE_MANAGEMENT
   /* Tell management interface that we initialized */
   if (management)
@@ -1109,6 +1327,7 @@
 			       SET_MTU_TUN | SET_MTU_UPPER_BOUND);
 
       ret = true;
+      static_context = c;
     }
   else
     {
@@ -1162,6 +1381,8 @@
 
       if (force || !(c->sig->signal_received == SIGUSR1 && c->options.persist_tun))
 	{
+	  static_context = NULL;
+
 #ifdef ENABLE_MANAGEMENT
 	  /* tell management layer we are about to close the TUN/TAP device */
 	  if (management)
@@ -1218,6 +1439,17 @@
   gc_free (&gc);
 }
 
+void
+tun_abort()
+{
+  struct context *c = static_context;
+  if (c)
+    {
+      static_context = NULL;
+      do_close_tun (c, true);
+    }
+}
+
 /*
  * Handle delayed tun/tap interface bringup due to --up-delay or --pull
  */
@@ -1778,6 +2010,9 @@
   to.renegotiate_packets = options->renegotiate_packets;
   to.renegotiate_seconds = options->renegotiate_seconds;
   to.single_session = options->single_session;
+#ifdef ENABLE_PUSH_PEER_INFO
+  to.push_peer_info = options->push_peer_info;
+#endif
 
   /* should we not xmit any packets until we get an initial
      response from client? */
@@ -2704,6 +2939,9 @@
       cb.arg = c;
       cb.status = management_callback_status_p2p;
       cb.show_net = management_show_net_callback;
+#if HTTP_PROXY_FALLBACK
+      cb.http_proxy_fallback_cmd = management_callback_http_proxy_fallback_cmd;
+#endif
       management_set_callback (management, &cb);
     }
 #endif
@@ -2828,6 +3066,17 @@
   c->sig->signal_text = NULL;
   c->sig->hard = false;
 
+  if (c->mode == CM_P2P)
+    init_management_callback_p2p (c);
+
+  /* possible sleep or management hold if restart */
+  if (c->mode == CM_P2P || c->mode == CM_TOP)
+    {
+      do_startup_pause (c);
+      if (IS_SIG (c))
+	goto sig;
+    }
+
   /* map in current connection entry */
   next_connection_entry (c);
 
@@ -2846,14 +3095,6 @@
   if (c->first_time && options->mlock)
     do_mlockall (true);
 
-  /* possible sleep or management hold if restart */
-  if (c->mode == CM_P2P || c->mode == CM_TOP)
-    {
-      do_startup_pause (c);
-      if (IS_SIG (c))
-	goto sig;
-    }
-
 #if P2MP
   /* get passwords if undefined */
   if (auth_retry_get () == AR_INTERACT)
diff -urN openvpn-2.1.1/init.h openvpn-2.1.3/init.h
--- openvpn-2.1.1/init.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/init.h	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/install-win32/Makefile.am openvpn-2.1.3/install-win32/Makefile.am
--- openvpn-2.1.1/install-win32/Makefile.am	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/install-win32/Makefile.am	2010-04-28 18:25:38.000000000 +0200
@@ -5,7 +5,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+#  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/install-win32/Makefile.in openvpn-2.1.3/install-win32/Makefile.in
--- openvpn-2.1.1/install-win32/Makefile.in	2009-12-12 00:27:05.000000000 +0100
+++ openvpn-2.1.3/install-win32/Makefile.in	2010-08-27 18:10:02.000000000 +0200
@@ -21,7 +21,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+#  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/install-win32/buildinstaller openvpn-2.1.3/install-win32/buildinstaller
--- openvpn-2.1.1/install-win32/buildinstaller	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/install-win32/buildinstaller	2010-08-27 18:08:58.000000000 +0200
@@ -10,5 +10,5 @@
 
 # sign the installer
 if [ -d "$SIGNTOOL" ]; then
-    TARGET_EXE="$(echo $(pwd)/$GENOUT/*.exe)" $SIGNTOOL/signexe
+    python $SIGNTOOL/signapp.py "$(echo $(pwd)/$GENOUT/*.exe)"
 fi
diff -urN openvpn-2.1.1/install-win32/getgui openvpn-2.1.3/install-win32/getgui
--- openvpn-2.1.1/install-win32/getgui	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/install-win32/getgui	2010-08-27 18:08:58.000000000 +0200
@@ -10,9 +10,6 @@
 if [ -f "$GUI" ]; then
     mkdir -p $GENOUT/bin &>/dev/null    
     cp $GUI $GENOUT/bin
-    if [ -d "$SIGNTOOL" ]; then
-	TARGET_EXE="$GENOUT/bin/$OPENVPN_GUI" $SIGNTOOL/signexe
-    fi
 fi
 
 if [ -f "$GENOUT/bin/$OPENVPN_GUI" ]; then
diff -urN openvpn-2.1.1/install-win32/getxgui openvpn-2.1.3/install-win32/getxgui
--- openvpn-2.1.1/install-win32/getxgui	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/install-win32/getxgui	2010-08-27 18:08:58.000000000 +0200
@@ -19,12 +19,6 @@
 	done
     fi
 
-    for f in $SIGNED_EXES; do
-	if [ -d "$SIGNTOOL" ]; then
-	    TARGET_EXE="$GENOUT/bin/`basename $f`" $SIGNTOOL/signexe
-	fi
-    done
-
     rm -rf $GENOUT/htdocs
     cp -a $OPENVPN_XGUI_DIR/ajax/htdocs $GENOUT/htdocs
 
diff -urN openvpn-2.1.1/install-win32/maketap openvpn-2.1.3/install-win32/maketap
--- openvpn-2.1.1/install-win32/maketap	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/install-win32/maketap	2010-08-27 18:08:58.000000000 +0200
@@ -1,101 +1,17 @@
 #!/bin/sh
 
-# Build the x86 and x64 versions of the TAP driver
-# Requires the Windows DDK
+# Get the x86 and x64 versions of the TAP driver
 
 # get version.nsi definitions
 . autodefs/defs.sh
 
-if [ -n "$DDKVER" ] && [ -d "/c/WINDDK/$DDKVER" ] ; then
-
-# common declarations for all DDK build targets
-. install-win32/ddk-common
-
-# configure tap driver sources
-MACRO="perl install-win32/macro.pl autodefs/defs.in"
-IFDEF="perl install-win32/ifdef.pl"
-rm -rf tap-win32/amd64
-mkdir tap-win32/amd64
-$MACRO <tap-win32/SOURCES.in >tap-win32/SOURCES
-$MACRO <tap-win32/i386/OemWin2k.inf.in | $IFDEF >tap-win32/i386/OemWin2k.inf
-$MACRO <tap-win32/i386/OemWin2k.inf.in | $IFDEF -DAMD64 >tap-win32/amd64/OemWin2k.inf
-
-if [ -n "$PRODUCT_TAP_DEBUG" ] ; then
-    w2ktarget="w2k c"
-    amdtarget="chk $x64_tag WNET"
-else
-    w2ktarget="w2k f"
-    amdtarget="fre $x64_tag WNET"
-fi
-
-if [ -z "$DRVBINSRC" ] ; then
-    if [ -n "$TAP_BIN_AMD64" ]; then
-	amdtarget=""
-    fi
-
-    cd tap-win32
-    t=`pwd`
-    cd ..
-
-    for mode in "$w2ktarget" "$amdtarget"; do
-	echo '**********' build TAP $mode
-	cmd //c "C:\\WINDDK\\$DDKVER\\bin\\setenv.bat C:\\WINDDK\\$DDKVER $mode && cd `perl install-win32/dosname.pl $t` && build -cef"
-	mv tap-win32/tapdrvr.cod "tap-win32/tapdrvr-$(echo $mode | tr ' ' '-').cod"
+if [ -d "$TAPBINSRC" ]; then
+    mkdir -p $GENOUT/driver/i386 &>/dev/null
+    mkdir -p $GENOUT/driver/amd64 &>/dev/null
+    for arch in i386 amd64; do
+	s=$TAPBINSRC/$arch
+	cp $s/*.sys $s/*.cat $s/*.inf $GENOUT/driver/$arch
     done
-
-    title openvpn-build &>/dev/null
-
-    if [ -n "$TAP_BIN_AMD64" ]; then
-	mkdir -p $t/amd64
-	cp "$TAP_BIN_AMD64" $t/amd64
-    fi
-
-    # copy driver files into tap-win32/dist
-    cd tap-win32
-    rm -rf dist
-    mkdir dist
-    cd dist
-    mkdir i386
-    mkdir amd64
-    cd i386
-    x86=`pwd`
-    cd ../amd64
-    x64=`pwd`
-    cd ../..
-    cp i386/OemWin2k.inf $x86
-    cp i386/*.sys $x86
-    cp amd64/OemWin2k.inf $x64
-    cp amd64/*.sys $x64
-    out="TAP driver catalog file is undefined";
-    echo "$out" >$x86/$PRODUCT_TAP_ID.cat
-    echo "$out" >$x64/$PRODUCT_TAP_ID.cat
-    cd ..
-fi
-
-# $DRVBINSRC, if defined, points to prebuilt TAP driver and
-# tapinstall.exe.
-mkdir $GENOUT &>/dev/null
-rm -rf $GENOUT/driver
-if [ -z "$DRVBINSRC" ] ; then
-    # Get TAP drivers
-    cp -a tap-win32/dist $GENOUT/driver
-
-    # Sign TAP drivers
-    if [ -d "$SIGNTOOL" ]; then
-	$SIGNTOOL/signtap
-    fi
-else
-    cp -a $DRVBINSRC/driver $GENOUT/driver
-fi
-
-# $DRVBINDEST, if defined, points to a destination directory
-# where TAP driver and tapinstall.exe will be saved, to be used
-# as a $DRVBINSRC in future builds.
-if [ -n "$DRVBINDEST" ] ; then
-    mkdir $DRVBINDEST &>/dev/null
-    cp -a $GENOUT/driver $DRVBINDEST
-fi
-
 else
-    echo Not building TAP driver -- DDK version $DDKVER NOT FOUND
+    echo Cannot find pre-built tap drivers
 fi
diff -urN openvpn-2.1.1/install-win32/maketapinstall openvpn-2.1.3/install-win32/maketapinstall
--- openvpn-2.1.1/install-win32/maketapinstall	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/install-win32/maketapinstall	2010-08-27 18:08:58.000000000 +0200
@@ -1,77 +1,15 @@
 #!/bin/sh
 
-# Build the x86 and x64 versions of the tapinstall tool
-# Requires the Windows DDK.
-# TISRC should be set to directory containing
-# tapinstall source code.
+# Get the x86 and x64 versions of the tapinstall tool
 
 # get version.nsi definitions
 . autodefs/defs.sh
 
-if [ -n "$DDKVER" ] && [ -d "/c/WINDDK/$DDKVER" ] ; then
-
-if ! [ -d "$TISRC" ] ; then
-    echo "$TISRC" NOT INSTALLED
-    exit 1
-fi
-
-# common declarations for all DDK build targets
-. install-win32/ddk-common
-
-amdtarget=""
-if [ -z "$TI_BIN_AMD64" ]; then
-    amdtarget="fre $x64_tag WNET"
-fi
-
-if [ -z "$DRVBINSRC" ] ; then
-    rm -rf tapinstall
-    cp -a "$TISRC" tapinstall
-
-    if [ -e tapinstall/sources.in ]; then
-	perl install-win32/ifdef.pl autodefs/defs.in <tapinstall/sources.in >tapinstall/sources
-    fi
-
-    cd tapinstall
-    t=`pwd`
-    cd ..
-
-    for mode in "w2k f" "$amdtarget"; do
-	if [ -n "$mode" ]; then
-	    echo '**********' build TAPINSTALL $mode
-	    cmd //c "C:\\WINDDK\\$DDKVER\\bin\\setenv.bat C:\\WINDDK\\$DDKVER $mode && cd `perl install-win32/dosname.pl $t` && build -cef"
-	fi
-    done
-fi
-
-if [ -n "$TI_BIN_AMD64" ]; then
-    mkdir -p $t/objfre_wnet_amd64/amd64
-    cp "$TI_BIN_AMD64" $t/objfre_wnet_amd64/amd64
-fi
-
-# $DRVBINSRC, if defined, points to prebuilt TAP driver and
-# tapinstall.exe.
-if [ -z "$DRVBINSRC" ] ; then
-    # Get tapinstall
+if [ -d "$TAPBINSRC" ]; then
     mkdir -p $GENOUT/tapinstall/i386 &>/dev/null
     mkdir -p $GENOUT/tapinstall/amd64 &>/dev/null
-    cp tapinstall/objfre_w2k_x86/i386/tapinstall.exe $GENOUT/tapinstall/i386
-    cp tapinstall/objfre_wnet_amd64/amd64/tapinstall.exe $GENOUT/tapinstall/amd64
-else
-    mkdir $GENOUT &>/dev/null
-    cp -a $DRVBINSRC/tapinstall $GENOUT/tapinstall
-fi
-
-# $DRVBINDEST, if defined, points to a destination directory
-# where TAP driver and tapinstall.exe will be saved, to be used
-# as a $DRVBINSRC in future builds.
-if [ -n "$DRVBINDEST" ] ; then
-    mkdir $DRVBINDEST &>/dev/null
-    cp -a $GENOUT/driver $DRVBINDEST
-    cp -a $GENOUT/tapinstall $DRVBINDEST
-fi
-
-title openvpn-build &>/dev/null
-
+    cp $TAPBINSRC/i386/tapinstall.exe $GENOUT/tapinstall/i386
+    cp $TAPBINSRC/amd64/tapinstall.exe $GENOUT/tapinstall/amd64
 else
-    echo Not building tapinstall -- DDK version $DDKVER NOT BUILT
+    echo Cannot find pre-built tapinstall
 fi
diff -urN openvpn-2.1.1/install-win32/openvpn.nsi openvpn-2.1.3/install-win32/openvpn.nsi
--- openvpn-2.1.1/install-win32/openvpn.nsi	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/install-win32/openvpn.nsi	2010-04-28 18:25:39.000000000 +0200
@@ -1,5 +1,5 @@
 ; ****************************************************************************
-; * Copyright (C) 2002-2009 OpenVPN Technologies, Inc.                            *
+; * Copyright (C) 2002-2010 OpenVPN Technologies, Inc.                            *
 ; *  This program is free software; you can redistribute it and/or modify    *
 ; *  it under the terms of the GNU General Public License version 2          *
 ; *  as published by the Free Software Foundation.                           *
diff -urN openvpn-2.1.1/install-win32/settings.in openvpn-2.1.3/install-win32/settings.in
--- openvpn-2.1.1/install-win32/settings.in	2009-11-12 09:32:52.000000000 +0100
+++ openvpn-2.1.3/install-win32/settings.in	2010-08-27 18:08:58.000000000 +0200
@@ -22,47 +22,24 @@
 ;!define OPENVPN_XGUI_DIR "../ovpnxml"
 
 # Prebuilt libraries.  DMALLOC is optional.
-!define OPENSSL_DIR	  "../openssl-0.9.8l"
+!define OPENSSL_DIR	  "../openssl.mingw/openssl-0.9.8o"
 !define LZO_DIR		  "../lzo-2.02"
 !define PKCS11_HELPER_DIR "../pkcs11-helper"
 ;!define DMALLOC_DIR	  "../dmalloc-5.4.2"
 
+# Prebuilt TAP drivers and tapinstall
+!define TAPBINSRC "../tap_dist"
+
+# Directory containing python script for signing .exe files
+!define SIGNTOOL        "../signtool"
+
 # Optional directory of prebuilt OpenVPN binary components,
 # to be used as a source when build-from-scratch prerequisites
 # are not met.
 ;!define GENOUT_PREBUILT  "../gen-prebuilt"
 
-# tapinstall.exe source code.
-# Not needed if DRVBINSRC is defined
-# (or if using pre-built mode).
-!define TISRC	"../tapinstall"
-
-# TAP Adapter parameters.  Note that PRODUCT_TAP_ID is
-# defined in version.m4.
-!define PRODUCT_TAP_DEVICE_DESCRIPTION  "TAP-Win32 Adapter V9"
-!define PRODUCT_TAP_PROVIDER            "TAP-Win32 Provider V9"
-!define PRODUCT_TAP_MAJOR_VER           9
-!define PRODUCT_TAP_MINOR_VER           6
-!define PRODUCT_TAP_RELDATE             "06/22/2009"
-
-# TAP adapter icon -- visible=0x81 or hidden=0x89
-!define PRODUCT_TAP_CHARACTERISTICS     0x81
-
-# Build debugging version of TAP driver
-;!define PRODUCT_TAP_DEBUG
-
-# DDK Version.
-# DDK distribution is assumed to be in C:\WINDDK\${DDKVER}
-!define DDKVER	     6001.18002
-!define DDKVER_MAJOR 6001
-
-# Code Signing.
-# If undefined, don't sign any files.
-!define SIGNTOOL        "../signtool"
-!define PRODUCT_SIGN_CN "openvpn"
-
 # -j parameter passed to make
-!define MAKE_JOBS 2
+!define MAKE_JOBS 1
 
 # output directory for built binaries
 # and other generated files
diff -urN openvpn-2.1.1/install-win32/winconfig openvpn-2.1.3/install-win32/winconfig
--- openvpn-2.1.1/install-win32/winconfig	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/install-win32/winconfig	2010-04-28 18:16:46.000000000 +0200
@@ -13,3 +13,6 @@
 done
 
 cat /dev/null >autodefs/guidefs.nsi
+
+echo '#include "autodefs/defs.h"' >autodefs.h
+echo '#include "config.h"' >>autodefs.h
diff -urN openvpn-2.1.1/integer.h openvpn-2.1.3/integer.h
--- openvpn-2.1.1/integer.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/integer.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/interval.c openvpn-2.1.3/interval.c
--- openvpn-2.1.1/interval.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/interval.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/interval.h openvpn-2.1.3/interval.h
--- openvpn-2.1.1/interval.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/interval.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/list.c openvpn-2.1.3/list.c
--- openvpn-2.1.1/list.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/list.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/list.h openvpn-2.1.3/list.h
--- openvpn-2.1.1/list.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/list.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/lzo.c openvpn-2.1.3/lzo.c
--- openvpn-2.1.1/lzo.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/lzo.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/lzo.h openvpn-2.1.3/lzo.h
--- openvpn-2.1.1/lzo.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/lzo.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/manage.c openvpn-2.1.3/manage.c
--- openvpn-2.1.1/manage.c	2009-10-01 22:30:21.000000000 +0200
+++ openvpn-2.1.3/manage.c	2010-06-01 08:45:23.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -97,6 +97,7 @@
   msg (M_CLIENT, "client-deny CID KID R [CR] : Deny auth client-id/key-id CID/KID with log reason");
   msg (M_CLIENT, "                             text R and optional client reason text CR");
   msg (M_CLIENT, "client-kill CID        : Kill client instance CID");
+  msg (M_CLIENT, "env-filter [level]     : Set env-var filter level");
 #ifdef MANAGEMENT_PF
   msg (M_CLIENT, "client-pf CID          : Define packet filter for client CID (MULTILINE)");
 #endif
@@ -109,6 +110,10 @@
   msg (M_CLIENT, "username type u        : Enter username u for a queried OpenVPN username.");
   msg (M_CLIENT, "verb [n]               : Set log verbosity level to n, or show if n is absent.");
   msg (M_CLIENT, "version                : Show current version number.");
+#if HTTP_PROXY_FALLBACK
+  msg (M_CLIENT, "http-proxy-fallback <server> <port> [flags] : Enter dynamic HTTP proxy fallback info.");
+  msg (M_CLIENT, "http-proxy-fallback-disable : Disable HTTP proxy fallback.");
+#endif
   msg (M_CLIENT, "END");
 }
 
@@ -203,12 +208,10 @@
 }
 
 static void
-man_output_list_push (struct management *man, const char *str)
+man_output_list_push_finalize (struct management *man)
 {
   if (management_connected (man))
     {
-      if (str)
-	buffer_list_push (man->connection.out, (const unsigned char *) str);
       man_update_io_state (man);
       if (!man->persist.standalone_disabled)
 	{
@@ -219,13 +222,29 @@
 }
 
 static void
+man_output_list_push_str (struct management *man, const char *str)
+{
+  if (management_connected (man) && str)
+    {
+      buffer_list_push (man->connection.out, (const unsigned char *) str);
+    }
+}
+
+static void
+man_output_list_push (struct management *man, const char *str)
+{
+  man_output_list_push_str (man, str);
+  man_output_list_push_finalize (man);
+}
+
+static void
 man_prompt (struct management *man)
 {
   if (man_password_needed (man))
     man_output_list_push (man, "ENTER PASSWORD:");
 #if 0 /* should we use prompt? */
   else
-    man_output_list_push (man, PACKAGE_NAME ">");
+    man_output_list_push (man, ">");
 #endif
 }
 
@@ -255,12 +274,13 @@
 static void
 virtual_output_callback_func (void *arg, const unsigned int flags, const char *str)
 {
+  struct management *man = (struct management *) arg;
   static int recursive_level = 0; /* GLOBAL */
+  bool did_push = false;
 
   if (!recursive_level) /* don't allow recursion */
     {
       struct gc_arena gc = gc_new ();
-      struct management *man = (struct management *) arg;
       struct log_entry e;
       const char *out = NULL;
 
@@ -288,13 +308,17 @@
 				   |   LOG_PRINT_LOG_PREFIX
 				   |   LOG_PRINT_CRLF, &gc);
 	  if (out)
-	    man_output_list_push (man, out);
+	    {
+	      man_output_list_push_str (man, out);
+	      did_push = true;
+	    }
 	  if (flags & M_FATAL)
 	    {
 	      out = log_entry_print (&e, LOG_FATAL_NOTIFY|LOG_PRINT_CRLF, &gc);
 	      if (out)
 		{
-		  man_output_list_push (man, out);
+		  man_output_list_push_str (man, out);
+		  did_push = true;
 		  man_reset_client_socket (man, true);
 		}
 	    }
@@ -303,6 +327,9 @@
       --recursive_level;
       gc_free (&gc);
     }
+
+  if (did_push)
+    man_output_list_push_finalize (man);
 }
 
 /*
@@ -935,6 +962,13 @@
     }
 }
 
+static void
+man_env_filter (struct management *man, const int level)
+{
+  man->connection.env_filter_level = level;
+  msg (M_CLIENT, "SUCCESS: env_filter_level=%d", level);
+}
+
 #ifdef MANAGEMENT_PF
 
 static void
@@ -990,6 +1024,31 @@
   return true;
 }
 
+#if HTTP_PROXY_FALLBACK
+
+static void
+man_http_proxy_fallback (struct management *man, const char *server, const char *port, const char *flags)
+{
+  if (man->persist.callback.http_proxy_fallback_cmd)
+    {
+      const bool status = (*man->persist.callback.http_proxy_fallback_cmd)(man->persist.callback.arg, server, port, flags);
+      if (status)
+	{
+	  msg (M_CLIENT, "SUCCESS: proxy-fallback command succeeded");
+	}
+      else
+	{
+	  msg (M_CLIENT, "ERROR: proxy-fallback command failed");
+	}
+    }
+  else
+    {
+      msg (M_CLIENT, "ERROR: The proxy-fallback command is not supported by the current daemon mode");
+    }
+}
+
+#endif
+
 static void
 man_dispatch_command (struct management *man, struct status_output *so, const char **p, const int nparms)
 {
@@ -1020,6 +1079,13 @@
     {
       man_client_n_clients (man);
     }
+  else if (streq (p[0], "env-filter"))
+    {
+      int level = 0;
+      if (p[1])
+	level = atoi (p[1]);
+      man_env_filter (man, level);
+    }
 #endif
   else if (streq (p[0], "signal"))
     {
@@ -1195,6 +1261,17 @@
 	man_pkcs11_id_get (man, atoi(p[1]));
     }
 #endif
+#if HTTP_PROXY_FALLBACK
+  else if (streq (p[0], "http-proxy-fallback"))
+    {
+      if (man_need (man, p, 2, MN_AT_LEAST))
+	man_http_proxy_fallback (man, p[1], p[2], p[3]);
+    }
+  else if (streq (p[0], "http-proxy-fallback-disable"))
+    {
+      man_http_proxy_fallback (man, NULL, NULL, NULL);
+    }
+#endif
 #if 1
   else if (streq (p[0], "test"))
     {
@@ -1541,17 +1618,18 @@
 {
   if (socket_defined (man->connection.sd_cli))
     {
-      msg (D_MANAGEMENT, "MANAGEMENT: Client disconnected");
 #ifdef WIN32
       man_stop_ne32 (man);
 #endif
       man_close_socket (man, man->connection.sd_cli);
       man->connection.sd_cli = SOCKET_UNDEFINED;
+      man->connection.state = MS_INITIAL;
       command_line_reset (man->connection.in);
       buffer_list_reset (man->connection.out);
 #ifdef MANAGEMENT_DEF_AUTH
       in_extra_reset (&man->connection, false);
 #endif
+      msg (D_MANAGEMENT, "MANAGEMENT: Client disconnected");
     }
   if (!exiting)
     {
@@ -1722,13 +1800,15 @@
 static int
 man_write (struct management *man)
 {
-  const int max_send = 256;
+  const int size_hint = 1024;
   int sent = 0;
+  const struct buffer *buf;
 
-  const struct buffer *buf = buffer_list_peek (man->connection.out);
+  buffer_list_aggregate(man->connection.out, size_hint);
+  buf = buffer_list_peek (man->connection.out);
   if (buf && BLEN (buf))
     {
-      const int len = min_int (max_send, BLEN (buf));
+      const int len = min_int (size_hint, BLEN (buf));
       sent = send (man->connection.sd_cli, BPTR (buf), len, MSG_NOSIGNAL);
       if (sent >= 0)
 	{
@@ -2085,7 +2165,7 @@
   man->persist.standalone_disabled = false;
   man->persist.hold_release = false;
   CLEAR (man->persist.callback);
-  man_output_list_push (man, NULL); /* flush output queue */
+  man_output_list_push_finalize (man); /* flush output queue */
 }
 
 void
@@ -2129,15 +2209,51 @@
 
 #ifdef MANAGEMENT_DEF_AUTH
 
+static bool
+env_filter_match (const char *env_str, const int env_filter_level)
+{
+  static const char *env_names[] = {
+    "username=",
+    "password=",
+    "X509_0_CN=",
+    "tls_serial_0=",
+    "untrusted_ip=",
+    "ifconfig_local=",
+    "ifconfig_netmask=",
+    "daemon_start_time=",
+    "daemon_pid=",
+    "dev=",
+    "ifconfig_pool_remote_ip=",
+    "ifconfig_pool_netmask=",
+    "time_duration=",
+    "bytes_sent=",
+    "bytes_received="
+  };
+  if (env_filter_level >= 1)
+    {
+      size_t i;
+      for (i = 0; i < SIZE(env_names); ++i)
+	{
+	  const char *en = env_names[i];
+	  const size_t len = strlen(en);
+	  if (strncmp(env_str, en, len) == 0)
+	    return true;
+	}
+      return false;
+    }
+  else
+    return true;
+}
+
 static void
-man_output_env (const struct env_set *es, const bool tail)
+man_output_env (const struct env_set *es, const bool tail, const int env_filter_level)
 {
   if (es)
     {
       struct env_item *e;
       for (e = es->list; e != NULL; e = e->next)
 	{
-	  if (e->string)
+	  if (e->string && (!env_filter_level || env_filter_match(e->string, env_filter_level)))
 	    msg (M_CLIENT, ">CLIENT:ENV,%s", e->string);
 	}
     }
@@ -2155,10 +2271,62 @@
       const int nclients = (*man->persist.callback.n_clients) (man->persist.callback.arg);
       setenv_int (es, "n_clients", nclients);
     }
-  man_output_env (es, false);
+  man_output_env (es, false, man->connection.env_filter_level);
   gc_free (&gc);
 }
 
+static bool
+validate_peer_info_line(const char *line)
+{
+  uint8_t c;
+  int state = 0;
+  while ((c=*line++))
+    {
+      switch (state)
+	{
+	case 0:
+	case 1:
+	  if (c == '=' && state == 1)
+	    state = 2;
+	  else if (isalnum(c) || c == '_')
+	    state = 1;
+	  else
+	    return false;
+	case 2:
+	  if (isprint(c))
+	    ;
+	  else
+	    return false;
+	}
+    }
+  return (state == 2);
+}
+
+static void
+man_output_peer_info_env (struct management *man, struct man_def_auth_context *mdac)
+{
+  char line[256];
+  if (man->persist.callback.get_peer_info)
+    {
+      const char *peer_info = (*man->persist.callback.get_peer_info) (man->persist.callback.arg, mdac->cid);
+      if (peer_info)
+	{
+	  struct buffer buf;
+	  buf_set_read (&buf, (const uint8_t *) peer_info, strlen(peer_info));
+	  while (buf_parse (&buf, '\n', line, sizeof (line)))
+	    {
+	      chomp (line);
+	      if (validate_peer_info_line(line))
+		{
+		  msg (M_CLIENT, ">CLIENT:ENV,%s", line);
+		}
+	      else
+		msg (D_MANAGEMENT, "validation failed on peer_info line received from client");
+	    }
+	}
+    }
+}
+
 void
 management_notify_client_needing_auth (struct management *management,
 				       const unsigned int mda_key_id,
@@ -2172,7 +2340,8 @@
 	mode = "REAUTH";
       msg (M_CLIENT, ">CLIENT:%s,%lu,%u", mode, mdac->cid, mda_key_id);
       man_output_extra_env (management);
-      man_output_env (es, true);
+      man_output_peer_info_env(management, mdac);
+      man_output_env (es, true, management->connection.env_filter_level);
       mdac->flags |= DAF_INITIAL_AUTH;
     }
 }
@@ -2185,7 +2354,7 @@
   mdac->flags |= DAF_CONNECTION_ESTABLISHED;
   msg (M_CLIENT, ">CLIENT:ESTABLISHED,%lu", mdac->cid);
   man_output_extra_env (management);
-  man_output_env (es, true);
+  man_output_env (es, true, management->connection.env_filter_level);
 }
 
 void
@@ -2196,7 +2365,7 @@
   if ((mdac->flags & DAF_INITIAL_AUTH) && !(mdac->flags & DAF_CONNECTION_CLOSED))
     {
       msg (M_CLIENT, ">CLIENT:DISCONNECT,%lu", mdac->cid);
-      man_output_env (es, true);
+      man_output_env (es, true, management->connection.env_filter_level);
       mdac->flags |= DAF_CONNECTION_CLOSED;
     }
 }
@@ -2272,9 +2441,12 @@
 }
 
 void
-management_auth_failure (struct management *man, const char *type)
+management_auth_failure (struct management *man, const char *type, const char *reason)
 {
-  msg (M_CLIENT, ">PASSWORD:Verification Failed: '%s'", type);
+  if (reason)
+    msg (M_CLIENT, ">PASSWORD:Verification Failed: '%s' ['%s']", type, reason);
+  else
+    msg (M_CLIENT, ">PASSWORD:Verification Failed: '%s'", type);
 }
 
 static inline bool
@@ -2345,7 +2517,7 @@
 		  net_event_win32_clear_selected_events (&man->connection.ne32, FD_ACCEPT);
 		}
 	    }
-	  else if (man->connection.state == MS_CC_WAIT_READ)
+	  else if (man->connection.state == MS_CC_WAIT_READ || man->connection.state == MS_CC_WAIT_WRITE)
 	    {
 	      if (net_events & FD_READ)
 		{
@@ -2353,18 +2525,13 @@
 		    ;
 		  net_event_win32_clear_selected_events (&man->connection.ne32, FD_READ);
 		}
-	    }
 
-	  if (man->connection.state == MS_CC_WAIT_WRITE)
-	    {
 	      if (net_events & FD_WRITE)
 		{
 		  int status;
-		  /* dmsg (M_INFO, "FD_WRITE set"); */
 		  status = man_write (man);
 		  if (status < 0 && WSAGetLastError() == WSAEWOULDBLOCK)
 		    {
-		      /* dmsg (M_INFO, "FD_WRITE cleared"); */
 		      net_event_win32_clear_selected_events (&man->connection.ne32, FD_WRITE);
 		    }
 		}
@@ -2455,7 +2622,7 @@
   
   if (man_standalone_ok (man))
     {
-      do
+      while (true)
 	{
 	  event_reset (man->connection.es);
 	  management_socket_set (man, man->connection.es, NULL, NULL);
@@ -2473,15 +2640,18 @@
 	      status = -1;
 	      break;
 	    }
-	  /* set SIGINT signal if expiration time exceeded */
-	  if (expire && now >= expire)
+
+	  if (status > 0)
+	    break;
+	  else if (expire && now >= expire)
 	    {
+	      /* set SIGINT signal if expiration time exceeded */
 	      status = 0;
 	      if (signal_received)
 		*signal_received = SIGINT;
 	      break;
 	    }
-	} while (status != 1);
+	}
     }
   return status;
 }
@@ -2511,11 +2681,13 @@
 static int
 man_standalone_event_loop (struct management *man, volatile int *signal_received, const time_t expire)
 {
-  int status;
-  ASSERT (man_standalone_ok (man));
-  status = man_block (man, signal_received, expire);
-  if (status > 0)
-    management_io (man);
+  int status = -1;
+  if (man_standalone_ok (man))
+    {
+      status = man_block (man, signal_received, expire);
+      if (status > 0)
+	management_io (man);
+    }
   return status;
 }
 
@@ -2556,26 +2728,29 @@
     {
       volatile int signal_received = 0;
       const bool standalone_disabled_save = man->persist.standalone_disabled;
-      time_t expire;
+      time_t expire = 0;
 
       man->persist.standalone_disabled = false; /* This is so M_CLIENT messages will be correctly passed through msg() */
 
       /* set expire time */
       update_time ();
-      expire = now + sec;
+      if (sec)
+	expire = now + sec;
 
       /* if no client connection, wait for one */
       man_wait_for_client_connection (man, &signal_received, expire, 0);
       if (signal_received)
 	return;
 
-      /* run command processing event loop until we get our username/password */
-      while (true)
+      /* run command processing event loop */
+      do
 	{
 	  man_standalone_event_loop (man, &signal_received, expire);
+	  if (!signal_received)
+	    man_check_for_signals (&signal_received);
 	  if (signal_received)
 	    return;
-	}
+	} while (expire);
 
       /* revert state */
       man->persist.standalone_disabled = standalone_disabled_save;
@@ -2662,6 +2837,8 @@
 	  do
 	    {
 	      man_standalone_event_loop (man, &signal_received, 0);
+	      if (!signal_received)
+		man_check_for_signals (&signal_received);
 	      if (signal_received)
 		{
 		  ret = false;
@@ -2742,6 +2919,8 @@
 	  do
 	    {
 	      man_standalone_event_loop (man, &signal_received, 0);
+	      if (!signal_received)
+		man_check_for_signals (&signal_received);
 	      if (signal_received)
 		break;
 	    } while (!man->persist.hold_release);
@@ -2963,6 +3142,19 @@
     return NULL;
 }
 
+#if HTTP_PROXY_FALLBACK
+
+void
+management_http_proxy_fallback_notify (struct management *man, const char *type, const char *remote_ip_hint)
+{
+  if (remote_ip_hint)
+    msg (M_CLIENT, ">PROXY:%s,%s", type, remote_ip_hint);
+  else
+    msg (M_CLIENT, ">PROXY:%s", type);
+}
+
+#endif /* HTTP_PROXY_FALLBACK */
+
 #else
 static void dummy(void) {}
 #endif /* ENABLE_MANAGEMENT */
diff -urN openvpn-2.1.1/manage.h openvpn-2.1.3/manage.h
--- openvpn-2.1.1/manage.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/manage.h	2010-05-31 20:05:33.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -164,12 +164,16 @@
 		       const char *reason,
 		       const char *client_reason,
 		       struct buffer_list *cc_config); /* ownership transferred */
+  char *(*get_peer_info) (void *arg, const unsigned long cid);
 #endif
 #ifdef MANAGEMENT_PF
   bool (*client_pf) (void *arg,
 		     const unsigned long cid,
 		     struct buffer_list *pf_config);   /* ownership transferred */
 #endif
+#if HTTP_PROXY_FALLBACK
+  bool (*http_proxy_fallback_cmd) (void *arg, const char *server, const char *port, const char *flags);
+#endif
 };
 
 /*
@@ -268,6 +272,7 @@
   unsigned long in_extra_cid;
   unsigned int in_extra_kid;
   struct buffer_list *in_extra;
+  int env_filter_level;
 #endif
   struct event_set *es;
 
@@ -435,7 +440,7 @@
  * OpenVPN calls here to indicate a password failure
  */
 
-void management_auth_failure (struct management *man, const char *type);
+void management_auth_failure (struct management *man, const char *type, const char *reason);
 
 /*
  * These functions drive the bytecount in/out counters.
@@ -501,5 +506,11 @@
 
 #endif /* MANAGEMENT_DEF_AUTH */
 
+#if HTTP_PROXY_FALLBACK
+
+void management_http_proxy_fallback_notify (struct management *man, const char *type, const char *remote_ip_hint);
+
+#endif /* HTTP_PROXY_FALLBACK */
+
 #endif
 #endif
diff -urN openvpn-2.1.1/mbuf.c openvpn-2.1.3/mbuf.c
--- openvpn-2.1.1/mbuf.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mbuf.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mbuf.h openvpn-2.1.3/mbuf.h
--- openvpn-2.1.1/mbuf.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mbuf.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/memcmp.c openvpn-2.1.3/memcmp.c
--- openvpn-2.1.1/memcmp.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/memcmp.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/memdbg.h openvpn-2.1.3/memdbg.h
--- openvpn-2.1.1/memdbg.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/memdbg.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/misc.c openvpn-2.1.3/misc.c
--- openvpn-2.1.1/misc.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/misc.c	2010-05-31 20:32:32.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -1194,7 +1194,7 @@
 const char *
 hostname_randomize(const char *hostname, struct gc_arena *gc)
 {
-  const int n_rnd_bytes = 6;
+# define n_rnd_bytes 6
 
   char *hst = string_alloc(hostname, gc);
   char *dot = strchr(hst, '.');
@@ -1213,6 +1213,7 @@
     }
   else
     return hostname;
+# undef n_rnd_bytes
 }
 
 #else
@@ -1373,6 +1374,9 @@
     {
       const bool from_stdin = (!auth_file || !strcmp (auth_file, "stdin"));
 
+      if (flags & GET_USER_PASS_PREVIOUS_CREDS_FAILED)
+	msg (M_WARN, "Note: previous '%s' credentials failed", prefix);
+
 #ifdef ENABLE_MANAGEMENT
       /*
        * Get username/password from standard input?
@@ -1381,6 +1385,9 @@
 	  && ((auth_file && streq (auth_file, "management")) || (from_stdin && (flags & GET_USER_PASS_MANAGEMENT)))
 	  && management_query_user_pass_enabled (management))
 	{
+	  if (flags & GET_USER_PASS_PREVIOUS_CREDS_FAILED)
+	    management_auth_failure (management, prefix, "previous auth credentials failed");
+
 	  if (!management_query_user_pass (management, up, prefix, flags))
 	    {
 	      if ((flags & GET_USER_PASS_NOFATAL) != 0)
diff -urN openvpn-2.1.1/misc.h openvpn-2.1.3/misc.h
--- openvpn-2.1.1/misc.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/misc.h	2010-05-25 00:49:18.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -263,12 +263,17 @@
 #define GET_USER_PASS_NEED_OK       (1<<3)
 #define GET_USER_PASS_NOFATAL       (1<<4)
 #define GET_USER_PASS_NEED_STR      (1<<5)
+#define GET_USER_PASS_PREVIOUS_CREDS_FAILED (1<<6)
 
 bool get_user_pass (struct user_pass *up,
 		    const char *auth_file,
 		    const char *prefix,
 		    const unsigned int flags);
 
+void fail_user_pass (const char *prefix,
+		     const unsigned int flags,
+		     const char *reason);
+
 void purge_user_pass (struct user_pass *up, const bool force);
 
 /*
diff -urN openvpn-2.1.1/mroute.c openvpn-2.1.3/mroute.c
--- openvpn-2.1.1/mroute.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mroute.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mroute.h openvpn-2.1.3/mroute.h
--- openvpn-2.1.1/mroute.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mroute.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mss.c openvpn-2.1.3/mss.c
--- openvpn-2.1.1/mss.c	2009-11-12 09:18:05.000000000 +0100
+++ openvpn-2.1.3/mss.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mss.h openvpn-2.1.3/mss.h
--- openvpn-2.1.1/mss.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mss.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mtcp.c openvpn-2.1.3/mtcp.c
--- openvpn-2.1.1/mtcp.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mtcp.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mtcp.h openvpn-2.1.3/mtcp.h
--- openvpn-2.1.1/mtcp.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mtcp.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mtu.c openvpn-2.1.3/mtu.c
--- openvpn-2.1.1/mtu.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mtu.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mtu.h openvpn-2.1.3/mtu.h
--- openvpn-2.1.1/mtu.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mtu.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mudp.c openvpn-2.1.3/mudp.c
--- openvpn-2.1.1/mudp.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mudp.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/mudp.h openvpn-2.1.3/mudp.h
--- openvpn-2.1.1/mudp.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/mudp.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/multi.c openvpn-2.1.3/multi.c
--- openvpn-2.1.1/multi.c	2009-10-25 01:17:29.000000000 +0200
+++ openvpn-2.1.3/multi.c	2010-07-27 07:55:16.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -721,7 +721,7 @@
 	  /*
 	   * Status file version 1
 	   */
-	  status_printf (so, PACKAGE_NAME " CLIENT LIST");
+	  status_printf (so, "OpenVPN CLIENT LIST");
 	  status_printf (so, "Updated,%s", time_string (0, 0, false, &gc_top));
 	  status_printf (so, "Common Name,Real Address,Bytes Received,Bytes Sent,Connected Since");
 	  hash_iterator_init (m->hash, &hi, true);
@@ -1843,6 +1843,20 @@
     }
 }
 
+static void
+multi_schedule_context_wakeup (struct multi_context *m, struct multi_instance *mi)
+{
+  /* calculate an absolute wakeup time */
+  ASSERT (!openvpn_gettimeofday (&mi->wakeup, NULL));
+  tv_add (&mi->wakeup, &mi->context.c2.timeval);
+
+  /* tell scheduler to wake us up at some point in the future */
+  schedule_add_entry (m->schedule,
+		      (struct schedule_entry *) mi,
+		      &mi->wakeup,
+		      compute_wakeup_sigma (&mi->context.c2.timeval));
+}
+
 /*
  * Figure instance-specific timers, convert
  * earliest to absolute time in mi->wakeup,
@@ -1863,15 +1877,8 @@
 
       if (!IS_SIG (&mi->context))
 	{
-	  /* calculate an absolute wakeup time */
-	  ASSERT (!openvpn_gettimeofday (&mi->wakeup, NULL));
-	  tv_add (&mi->wakeup, &mi->context.c2.timeval);
-
 	  /* tell scheduler to wake us up at some point in the future */
-	  schedule_add_entry (m->schedule,
-			      (struct schedule_entry *) mi,
-			      &mi->wakeup,
-			      compute_wakeup_sigma (&mi->context.c2.timeval));
+	  multi_schedule_context_wakeup(m, mi);
 
 	  /* connection is "established" when SSL/TLS key negotiation succeeds
 	     and (if specified) auth user/pass succeeds */
@@ -2566,19 +2573,44 @@
       ret = tls_authenticate_key (mi->context.c2.tls_multi, mda_key_id, auth, client_reason);
       if (ret)
 	{
-	  if (auth && !mi->connection_established_flag)
+	  if (auth)
 	    {
-	      set_cc_config (mi, cc_config);
-	      cc_config_owned = false;
+	      if (!mi->connection_established_flag)
+		{
+		  set_cc_config (mi, cc_config);
+		  cc_config_owned = false;
+		}
+	    }
+	  else
+	    {
+	      if (reason)
+		msg (D_MULTI_LOW, "MULTI: connection rejected: %s, CLI:%s", reason, np(client_reason));
+	      if (mi->connection_established_flag)
+		{
+		  send_auth_failed (&mi->context, client_reason); /* mid-session reauth failed */
+		  multi_schedule_context_wakeup(m, mi);
+		}
 	    }
-	  if (!auth && reason)
-	    msg (D_MULTI_LOW, "MULTI: connection rejected: %s, CLI:%s", reason, np(client_reason));
 	}
     }
   if (cc_config_owned && cc_config)
     buffer_list_free (cc_config);
   return ret;
 }
+
+static char *
+management_get_peer_info (void *arg, const unsigned long cid)
+{
+  struct multi_context *m = (struct multi_context *) arg;
+  struct multi_instance *mi = lookup_by_cid (m, cid);
+  char *ret = NULL;
+
+  if (mi)
+      ret = tls_get_peer_info (mi->context.c2.tls_multi);
+
+  return ret;
+}
+
 #endif
 
 #ifdef MANAGEMENT_PF
@@ -2619,6 +2651,7 @@
 #ifdef MANAGEMENT_DEF_AUTH
       cb.kill_by_cid = management_kill_by_cid;
       cb.client_auth = management_client_auth;
+      cb.get_peer_info = management_get_peer_info;
 #endif
 #ifdef MANAGEMENT_PF
       cb.client_pf = management_client_pf;
diff -urN openvpn-2.1.1/multi.h openvpn-2.1.3/multi.h
--- openvpn-2.1.1/multi.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/multi.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/occ-inline.h openvpn-2.1.3/occ-inline.h
--- openvpn-2.1.1/occ-inline.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/occ-inline.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/occ.c openvpn-2.1.3/occ.c
--- openvpn-2.1.1/occ.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/occ.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/occ.h openvpn-2.1.3/occ.h
--- openvpn-2.1.1/occ.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/occ.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/openvpn-plugin.h openvpn-2.1.3/openvpn-plugin.h
--- openvpn-2.1.1/openvpn-plugin.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/openvpn-plugin.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/openvpn.8 openvpn-2.1.3/openvpn.8
--- openvpn-2.1.1/openvpn.8	2009-12-11 09:04:24.000000000 +0100
+++ openvpn-2.1.3/openvpn.8	2010-08-10 19:27:02.000000000 +0200
@@ -4,7 +4,7 @@
 .\"             packet encryption, packet authentication, and
 .\"             packet compression.
 .\"
-.\"  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+.\"  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 .\"
 .\"  This program is free software; you can redistribute it and/or modify
 .\"  it under the terms of the GNU General Public License version 2
@@ -474,7 +474,7 @@
 This option exists in OpenVPN 2.1 or higher.
 .\"*********************************************************
 .TP
-.B --http-proxy server port [authfile|'auto'] [auth-method]
+.B --http-proxy server port [authfile|'auto'|'auto-nct'] [auth-method]
 Connect to remote host through an HTTP proxy at address
 .B server
 and port
@@ -487,6 +487,13 @@
 .B auth-method
 should be one of "none", "basic", or "ntlm".
 
+HTTP Digest authentication is supported as well, but only via
+the
+.B auto
+or
+.B auto-nct
+flags (below).
+
 The
 .B auto
 flag causes OpenVPN to automatically determine the
@@ -494,6 +501,12 @@
 and query stdin or the management interface for
 username/password credentials, if required.  This flag
 exists on OpenVPN 2.1 or higher.
+
+The
+.B auto-nct
+flag (no clear-text auth) instructs OpenVPN to automatically
+determine the authentication method, but to reject weak
+authentication protocols such as HTTP Basic Authentication.
 .\"*********************************************************
 .TP
 .B --http-proxy-retry
@@ -4265,6 +4278,13 @@
 The remote host must also pass all other tests
 of verification.
 
+.B NOTE:
+Because tls-remote may test against a common name prefix,
+only use this option when you are using OpenVPN with a custom CA
+certificate that is under your control.
+Never use this option when your client certificates are signed by
+a third party, such as a commercial web CA.
+
 Name can also be a common name prefix, for example if you
 want a client to only accept connections to "Server-1",
 "Server-2", etc., you can simply use
@@ -4736,6 +4756,13 @@
 above.
 .\"*********************************************************
 .TP
+.B --register-dns
+Run net stop dnscache, net start dnscache, ipconfig /flushdns
+and ipconfig /registerdns on connection initiation.
+This is known to kick Windows into
+recognizing pushed DNS servers.
+.\"*********************************************************
+.TP
 .B --pause-exit
 Put up a "press any key to continue" message on the console prior
 to OpenVPN program exit.  This option is automatically used by the
@@ -5836,7 +5863,7 @@
 .I http://www.oberhumer.com/opensource/lzo/
 .\"*********************************************************
 .SH COPYRIGHT
-Copyright (C) 2002-2009 OpenVPN Technologies, Inc. This program is free software;
+Copyright (C) 2002-2010 OpenVPN Technologies, Inc. This program is free software;
 you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 2
 as published by the Free Software Foundation.
diff -urN openvpn-2.1.1/openvpn.c openvpn-2.1.3/openvpn.c
--- openvpn-2.1.1/openvpn.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/openvpn.c	2010-05-25 00:49:18.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -55,8 +55,6 @@
   if (IS_SIG (c))
     return;
 
-  init_management_callback_p2p (c);
-
   /* main event loop */
   while (true)
     {
diff -urN openvpn-2.1.1/openvpn.h openvpn-2.1.3/openvpn.h
--- openvpn-2.1.1/openvpn.h	2009-10-01 21:35:38.000000000 +0200
+++ openvpn-2.1.3/openvpn.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/openvpn.spec openvpn-2.1.3/openvpn.spec
--- openvpn-2.1.1/openvpn.spec	2009-12-12 00:27:36.000000000 +0100
+++ openvpn-2.1.3/openvpn.spec	2010-08-27 18:10:35.000000000 +0200
@@ -16,7 +16,7 @@
 
 Summary:	OpenVPN is a robust and highly flexible VPN daemon by James Yonan.
 Name:           openvpn
-Version:        2.1.1
+Version:        2.1.3
 Release:	1
 URL:		http://openvpn.net/
 Source0:	http://prdownloads.sourceforge.net/openvpn/%{name}-%{version}.tar.gz
diff -urN openvpn-2.1.1/options.c openvpn-2.1.3/options.c
--- openvpn-2.1.1/options.c	2009-12-11 09:09:39.000000000 +0100
+++ openvpn-2.1.3/options.c	2010-07-27 23:44:34.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -108,8 +108,9 @@
   "                  up is a file containing username/password on 2 lines, or\n"
   "                  'stdin' to prompt from console.  Add auth='ntlm' if\n"
   "                  the proxy requires NTLM authentication.\n"
-  "--http-proxy s p 'auto': Like the above directive, but automatically determine\n"
-  "                         auth method and query for username/password if needed.\n"
+  "--http-proxy s p 'auto[-nct]' : Like the above directive, but automatically\n"
+  "                  determine auth method and query for username/password\n"
+  "                  if needed.  auto-nct disables weak proxy auth methods.\n"
   "--http-proxy-retry     : Retry indefinitely on HTTP proxy errors.\n"
   "--http-proxy-timeout n : Proxy timeout in seconds, default=5.\n"
   "--http-proxy-option type [parm] : Set extended HTTP proxy options.\n"
@@ -195,6 +196,9 @@
   "                  Add 'bypass-dns' flag to similarly bypass tunnel for DNS.\n"
   "--redirect-private [flags]: Like --redirect-gateway, but omit actually changing\n"
   "                  the default gateway.  Useful when pushing private subnets.\n"
+#ifdef ENABLE_PUSH_PEER_INFO
+  "--push-peer-info : (client only) push client info to server.\n"
+#endif
   "--setenv name value : Set a custom environmental variable to pass to script.\n"
   "--setenv FORWARD_COMPATIBLE 1 : Relax config file syntax checking to allow\n"
   "                  directives for future OpenVPN versions to be ignored.\n"
@@ -611,6 +615,8 @@
   "--dhcp-pre-release : Ask Windows to release the previous TAP adapter lease on\n"
 "                       startup.\n"
   "--dhcp-release     : Ask Windows to release the TAP adapter lease on shutdown.\n"
+  "--register-dns  : Run net stop dnscache, net start dnscache, ipconfig /flushdns\n"
+  "                  and ipconfig /registerdns on connection initiation.\n"
   "--tap-sleep n   : Sleep for n seconds after TAP adapter open before\n"
   "                  attempting to set adapter properties.\n"
   "--pause-exit         : When run from a console window, pause before exiting.\n"
@@ -760,7 +766,9 @@
 uninit_options (struct options *o)
 {
   if (o->gc_owned)
-    gc_free (&o->gc);
+    {
+      gc_free (&o->gc);
+    }
 }
 
 #ifdef ENABLE_DEBUG
@@ -1345,6 +1353,9 @@
   SHOW_INT (transition_window);
 
   SHOW_BOOL (single_session);
+#ifdef ENABLE_PUSH_PEER_INFO
+  SHOW_BOOL (push_peer_info);
+#endif
   SHOW_BOOL (tls_exit);
 
   SHOW_STR (tls_auth_file);
@@ -1411,6 +1422,142 @@
 
 #endif
 
+#if HTTP_PROXY_FALLBACK
+
+static struct http_proxy_options *
+parse_http_proxy_override (const char *server,
+			   const char *port,
+			   const char *flags,
+			   const int msglevel,
+			   struct gc_arena *gc)
+{
+  if (server && port)
+    {
+      struct http_proxy_options *ho;
+      const int int_port = atoi(port);
+
+      if (!legal_ipv4_port (int_port))
+	{
+	  msg (msglevel, "Bad http-proxy port number: %s", port);
+	  return NULL;
+	}
+
+      ALLOC_OBJ_CLEAR_GC (ho, struct http_proxy_options, gc);
+      ho->server = string_alloc(server, gc);
+      ho->port = int_port;
+      ho->retry = true;
+      ho->timeout = 5;
+      if (flags && !strcmp(flags, "nct"))
+	ho->auth_retry = PAR_NCT;
+      else
+	ho->auth_retry = PAR_ALL;
+      ho->http_version = "1.0";
+      ho->user_agent = "OpenVPN-Autoproxy/1.0";
+      return ho;
+    }
+  else
+    return NULL;
+}
+
+struct http_proxy_options *
+parse_http_proxy_fallback (struct context *c,
+			   const char *server,
+			   const char *port,
+			   const char *flags,
+			   const int msglevel)
+{
+  struct gc_arena gc = gc_new ();
+  struct http_proxy_options *ret = NULL;
+  struct http_proxy_options *hp = parse_http_proxy_override(server, port, flags, msglevel, &gc);
+  if (hp)
+    {
+      struct hpo_store *hpos = c->options.hpo_store;
+      if (!hpos)
+	{
+	  ALLOC_OBJ_CLEAR_GC (hpos, struct hpo_store, &c->options.gc);
+	  c->options.hpo_store = hpos;
+	}
+      hpos->hpo = *hp;
+      hpos->hpo.server = hpos->server;
+      strncpynt(hpos->server, hp->server, sizeof(hpos->server));
+      ret = &hpos->hpo;
+    }
+  gc_free (&gc);
+  return ret;
+}
+
+static void
+http_proxy_warn(const char *name)
+{
+  msg (M_WARN, "Note: option %s ignored because no TCP-based connection profiles are defined", name);
+}
+
+void
+options_postprocess_http_proxy_fallback (struct options *o)
+{
+  struct connection_list *l = o->connection_list;
+  if (l)
+    {
+      int i;
+      for (i = 0; i < l->len; ++i)
+	{
+	  struct connection_entry *ce = l->array[i];
+	  if (ce->proto == PROTO_TCPv4_CLIENT || ce->proto == PROTO_TCPv4)
+	    {
+	      if (l->len < CONNECTION_LIST_SIZE)
+		{
+		  struct connection_entry *newce;
+		  ALLOC_OBJ_GC (newce, struct connection_entry, &o->gc);
+		  *newce = *ce;
+		  newce->flags |= CE_HTTP_PROXY_FALLBACK;
+		  newce->http_proxy_options = NULL;
+		  newce->ce_http_proxy_fallback_timestamp = 0;
+		  l->array[l->len++] = newce;
+		}
+	      return;
+	    }
+	}
+    }
+  http_proxy_warn("http-proxy-fallback");
+}
+
+void
+options_postprocess_http_proxy_override (struct options *o)
+{
+  const struct connection_list *l = o->connection_list;
+   if (l)
+    {
+      int i;
+      bool succeed = false;
+      for (i = 0; i < l->len; ++i)
+	{
+	  struct connection_entry *ce = l->array[i];
+	  if (ce->proto == PROTO_TCPv4_CLIENT || ce->proto == PROTO_TCPv4)
+	    {
+	      ce->http_proxy_options = o->http_proxy_override;
+	      succeed = true;
+	    }
+	}
+      if (succeed)
+	{
+	  for (i = 0; i < l->len; ++i)
+	    {
+	      struct connection_entry *ce = l->array[i];
+	      if (ce->proto == PROTO_UDPv4)
+		{
+		  ce->flags |= CE_DISABLED;
+		}
+	    }
+	}
+      else
+	{
+	  http_proxy_warn("http-proxy-override");
+	}
+    }
+}
+
+#endif
+
 #if ENABLE_CONNECTION
 
 static struct connection_list *
@@ -1923,6 +2070,9 @@
       MUST_BE_UNDEF (transition_window);
       MUST_BE_UNDEF (tls_auth_file);
       MUST_BE_UNDEF (single_session);
+#ifdef ENABLE_PUSH_PEER_INFO
+      MUST_BE_UNDEF (push_peer_info);
+#endif
       MUST_BE_UNDEF (tls_exit);
       MUST_BE_UNDEF (crl_file);
       MUST_BE_UNDEF (key_method);
@@ -2094,7 +2244,7 @@
        * For compatibility with 2.0.x, map multiple --remote options
        * into connection list (connection lists added in 2.1).
        */
-      if (o->remote_list->len > 1)
+      if (o->remote_list->len > 1 || o->force_connection_list)
 	{
 	  const struct remote_list *rl = o->remote_list;
 	  int i;
@@ -2111,7 +2261,7 @@
 	      *ace = ce;
 	    }
 	}
-      else if (o->remote_list->len == 1) /* one --remote option specfied */
+      else if (o->remote_list->len == 1) /* one --remote option specified */
 	{
 	  connection_entry_load_re (&o->ce, o->remote_list->array[0]);
 	}
@@ -2125,6 +2275,13 @@
       int i;
       for (i = 0; i < o->connection_list->len; ++i)
 	options_postprocess_mutate_ce (o, o->connection_list->array[i]);
+
+#if HTTP_PROXY_FALLBACK
+      if (o->http_proxy_override)
+	options_postprocess_http_proxy_override(o);
+      else if (o->http_proxy_fallback)
+	options_postprocess_http_proxy_fallback(o);
+#endif
     }
   else
 #endif
@@ -2745,7 +2902,7 @@
 {
   msg (M_INFO|M_NOPREFIX, "%s", title_string);
   msg (M_INFO|M_NOPREFIX, "Originally developed by James Yonan");
-  msg (M_INFO|M_NOPREFIX, "Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>");
+  msg (M_INFO|M_NOPREFIX, "Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>");
   openvpn_exit (OPENVPN_EXIT_STATUS_USAGE); /* exit point */
 }
 
@@ -3632,6 +3789,29 @@
 	}
     }
 #endif
+#ifdef ENABLE_CONNECTION
+  else if (streq (p[0], "remote-ip-hint") && p[1])
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      options->remote_ip_hint = p[1];
+    }
+#endif
+#if HTTP_PROXY_FALLBACK
+  else if (streq (p[0], "http-proxy-fallback"))
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      options->http_proxy_fallback = true;
+      options->force_connection_list = true;
+    }
+  else if (streq (p[0], "http-proxy-override") && p[1] && p[2])
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      options->http_proxy_override = parse_http_proxy_override(p[1], p[2], p[3], msglevel, &options->gc);
+      if (!options->http_proxy_override)
+	goto err;
+      options->force_connection_list = true;
+    }
+#endif
   else if (streq (p[0], "remote") && p[1])
     {
       struct remote_entry re;
@@ -4192,8 +4372,13 @@
 
       if (p[3])
 	{
+	  /* auto -- try to figure out proxy addr, port, and type automatically */
+	  /* semiauto -- given proxy addr:port, try to figure out type automatically */
+	  /* (auto|semiauto)-nct -- disable proxy auth cleartext protocols (i.e. basic auth) */
 	  if (streq (p[3], "auto"))
-	    ho->auth_retry = true;
+	    ho->auth_retry = PAR_ALL;
+	  else if (streq (p[3], "auto-nct"))
+	    ho->auth_retry = PAR_NCT;
 	  else
 	    {
 	      ho->auth_method_string = "basic";
@@ -5105,7 +5290,7 @@
       VERIFY_PERMISSION (OPT_P_IPWIN32);
       options->tuntap_options.dhcp_release = true;
     }
-  else if (streq (p[0], "dhcp-rr") && p[1]) /* standalone method for internal use */
+  else if (streq (p[0], "dhcp-internal") && p[1]) /* standalone method for internal use */
     {
       unsigned int adapter_index;
       VERIFY_PERMISSION (OPT_P_GENERAL);
@@ -5116,13 +5301,26 @@
 	dhcp_release_by_adapter_index (adapter_index);
       if (options->tuntap_options.dhcp_renew)
 	dhcp_renew_by_adapter_index (adapter_index);
-      openvpn_exit (OPENVPN_EXIT_STATUS_USAGE); /* exit point */
+      openvpn_exit (OPENVPN_EXIT_STATUS_GOOD); /* exit point */
+    }
+  else if (streq (p[0], "register-dns"))
+    {
+      VERIFY_PERMISSION (OPT_P_IPWIN32);
+      options->tuntap_options.register_dns = true;
+    }
+  else if (streq (p[0], "rdns-internal")) /* standalone method for internal use */
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      set_debug_level (options->verbosity, SDL_CONSTRAIN);
+      if (options->tuntap_options.register_dns)
+	ipconfig_register_dns (NULL);
+      openvpn_exit (OPENVPN_EXIT_STATUS_GOOD); /* exit point */
     }
   else if (streq (p[0], "show-valid-subnets"))
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
       show_valid_win32_tun_subnets ();
-      openvpn_exit (OPENVPN_EXIT_STATUS_USAGE); /* exit point */
+      openvpn_exit (OPENVPN_EXIT_STATUS_GOOD); /* exit point */
     }
   else if (streq (p[0], "pause-exit"))
     {
@@ -5503,6 +5701,13 @@
       VERIFY_PERMISSION (OPT_P_GENERAL);
       options->single_session = true;
     }
+#ifdef ENABLE_PUSH_PEER_INFO
+  else if (streq (p[0], "push-peer-info"))
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      options->push_peer_info = true;
+    }
+#endif
   else if (streq (p[0], "tls-exit"))
     {
       VERIFY_PERMISSION (OPT_P_GENERAL);
diff -urN openvpn-2.1.1/options.h openvpn-2.1.3/options.h
--- openvpn-2.1.1/options.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/options.h	2010-05-31 10:05:13.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -97,6 +97,14 @@
   int socks_proxy_port;
   bool socks_proxy_retry;
 #endif
+
+# define CE_DISABLED (1<<0)
+#if HTTP_PROXY_FALLBACK
+# define CE_HTTP_PROXY_FALLBACK (1<<1)
+  time_t ce_http_proxy_fallback_timestamp; /* time when fallback http_proxy_options was last updated */
+#endif
+
+  unsigned int flags;
 };
 
 struct remote_entry
@@ -114,6 +122,7 @@
 {
   int len;
   int current;
+  int n_cycles;
   bool no_advance;
   struct connection_entry *array[CONNECTION_LIST_SIZE];
 };
@@ -126,6 +135,14 @@
 
 #endif
 
+#if HTTP_PROXY_FALLBACK
+struct hpo_store
+{
+  struct http_proxy_options hpo;
+  char server[80];
+};
+#endif
+
 /* Command line options */
 struct options
 {
@@ -162,14 +179,22 @@
   struct connection_entry ce;
 
 #ifdef ENABLE_CONNECTION
+  char *remote_ip_hint;
   struct connection_list *connection_list;
   struct remote_list *remote_list;
+  bool force_connection_list;
 #endif
 
 #ifdef GENERAL_PROXY_SUPPORT
   struct auto_proxy_info *auto_proxy_info;
 #endif
 
+#if HTTP_PROXY_FALLBACK
+  bool http_proxy_fallback;
+  struct http_proxy_options *http_proxy_override;
+  struct hpo_store *hpo_store; /* used to store dynamic proxy info given by management interface */
+#endif
+
   bool remote_random;
   const char *ipchange;
   const char *dev;
@@ -495,6 +520,10 @@
   /* Allow only one session */
   bool single_session;
 
+#ifdef ENABLE_PUSH_PEER_INFO
+  bool push_peer_info;
+#endif
+
   bool tls_exit;
 
 #endif /* USE_SSL */
@@ -710,4 +739,15 @@
 #endif
 }
 
+#if HTTP_PROXY_FALLBACK
+
+struct http_proxy_options *
+parse_http_proxy_fallback (struct context *c,
+			   const char *server,
+			   const char *port,
+			   const char *flags,
+			   const int msglevel);
+
+#endif /* HTTP_PROXY_FALLBACK */
+
 #endif
diff -urN openvpn-2.1.1/otime.c openvpn-2.1.3/otime.c
--- openvpn-2.1.1/otime.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/otime.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/otime.h openvpn-2.1.3/otime.h
--- openvpn-2.1.1/otime.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/otime.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/packet_id.c openvpn-2.1.3/packet_id.c
--- openvpn-2.1.1/packet_id.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/packet_id.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/packet_id.h openvpn-2.1.3/packet_id.h
--- openvpn-2.1.1/packet_id.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/packet_id.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/perf.c openvpn-2.1.3/perf.c
--- openvpn-2.1.1/perf.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/perf.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/perf.h openvpn-2.1.3/perf.h
--- openvpn-2.1.1/perf.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/perf.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/pf-inline.h openvpn-2.1.3/pf-inline.h
--- openvpn-2.1.1/pf-inline.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/pf-inline.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/pf.c openvpn-2.1.3/pf.c
--- openvpn-2.1.1/pf.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/pf.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/pf.h openvpn-2.1.3/pf.h
--- openvpn-2.1.1/pf.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/pf.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/ping-inline.h openvpn-2.1.3/ping-inline.h
--- openvpn-2.1.1/ping-inline.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/ping-inline.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/ping.c openvpn-2.1.3/ping.c
--- openvpn-2.1.1/ping.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/ping.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/ping.h openvpn-2.1.3/ping.h
--- openvpn-2.1.1/ping.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/ping.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/pkcs11.c openvpn-2.1.3/pkcs11.c
--- openvpn-2.1.1/pkcs11.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/pkcs11.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/pkcs11.h openvpn-2.1.3/pkcs11.h
--- openvpn-2.1.1/pkcs11.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/pkcs11.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/plugin/auth-pam/auth-pam.c openvpn-2.1.3/plugin/auth-pam/auth-pam.c
--- openvpn-2.1.1/plugin/auth-pam/auth-pam.c	2009-12-11 00:35:04.000000000 +0100
+++ openvpn-2.1.3/plugin/auth-pam/auth-pam.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/plugin/defer/simple.c openvpn-2.1.3/plugin/defer/simple.c
--- openvpn-2.1.1/plugin/defer/simple.c	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/plugin/defer/simple.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/plugin/down-root/down-root.c openvpn-2.1.3/plugin/down-root/down-root.c
--- openvpn-2.1.1/plugin/down-root/down-root.c	2009-12-11 00:35:04.000000000 +0100
+++ openvpn-2.1.3/plugin/down-root/down-root.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/plugin/examples/log.c openvpn-2.1.3/plugin/examples/log.c
--- openvpn-2.1.1/plugin/examples/log.c	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/plugin/examples/log.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/plugin/examples/simple.c openvpn-2.1.3/plugin/examples/simple.c
--- openvpn-2.1.1/plugin/examples/simple.c	2009-10-01 20:02:16.000000000 +0200
+++ openvpn-2.1.3/plugin/examples/simple.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/plugin.c openvpn-2.1.3/plugin.c
--- openvpn-2.1.1/plugin.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/plugin.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/plugin.h openvpn-2.1.3/plugin.h
--- openvpn-2.1.1/plugin.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/plugin.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/pool.c openvpn-2.1.3/pool.c
--- openvpn-2.1.1/pool.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/pool.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/pool.h openvpn-2.1.3/pool.h
--- openvpn-2.1.1/pool.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/pool.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/proto.c openvpn-2.1.3/proto.c
--- openvpn-2.1.1/proto.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/proto.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/proto.h openvpn-2.1.3/proto.h
--- openvpn-2.1.1/proto.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/proto.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/proxy.c openvpn-2.1.3/proxy.c
--- openvpn-2.1.1/proxy.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/proxy.c	2010-06-10 05:13:35.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -26,11 +26,13 @@
 
 #include "common.h"
 #include "misc.h"
+#include "crypto.h"
 #include "win32.h"
 #include "socket.h"
 #include "fdmisc.h"
 #include "proxy.h"
 #include "base64.h"
+#include "httpdigest.h"
 #include "ntlm.h"
 
 #ifdef WIN32
@@ -41,6 +43,8 @@
 
 #ifdef ENABLE_HTTP_PROXY
 
+#define UP_TYPE_PROXY        "HTTP Proxy"
+
 /* cached proxy username/password */
 static struct user_pass static_proxy_user_pass;
 
@@ -220,13 +224,200 @@
 {
   if (!static_proxy_user_pass.defined || force)
     {
+      unsigned int flags = GET_USER_PASS_MANAGEMENT;
+      if (p->queried_creds)
+	flags |= GET_USER_PASS_PREVIOUS_CREDS_FAILED;
       get_user_pass (&static_proxy_user_pass,
 		     p->options.auth_file,
-		     "HTTP Proxy",
-		     GET_USER_PASS_MANAGEMENT);
+		     UP_TYPE_PROXY,
+		     flags);
+      p->queried_creds = true;
       p->up = static_proxy_user_pass;
     }
 }
+static void
+clear_user_pass_http (void)
+{
+  purge_user_pass (&static_proxy_user_pass, true);
+}
+
+static void
+dump_residual (socket_descriptor_t sd,
+	       int timeout,
+	       volatile int *signal_received)
+{
+  char buf[256];
+  while (true)
+    {
+      if (!recv_line (sd, buf, sizeof (buf), timeout, true, NULL, signal_received))
+	return;
+      chomp (buf);
+      msg (D_PROXY, "PROXY HEADER: '%s'", buf);
+    }
+}
+
+/*
+ * Extract the Proxy-Authenticate header from the stream.
+ * Consumes all headers.
+ */
+static int
+get_proxy_authenticate (socket_descriptor_t sd,
+		        int timeout,
+			char **data,
+			struct gc_arena *gc,
+		        volatile int *signal_received)
+{
+  char buf[256];
+  int ret = HTTP_AUTH_NONE;
+  while (true)
+    {
+      if (!recv_line (sd, buf, sizeof (buf), timeout, true, NULL, signal_received))
+	{
+	  *data = NULL;
+	  return HTTP_AUTH_NONE;
+	}
+      chomp (buf);
+      if (!strlen(buf))
+	return ret;
+      if (ret == HTTP_AUTH_NONE && !strncmp(buf, "Proxy-Authenticate: ", 20))
+	{
+	  if (!strncmp(buf+20, "Basic ", 6))
+	    {
+	      msg (D_PROXY, "PROXY AUTH BASIC: '%s'", buf);
+	      *data = string_alloc(buf+26, gc);
+	      ret = HTTP_AUTH_BASIC;
+	    }
+#if PROXY_DIGEST_AUTH
+	  else if (!strncmp(buf+20, "Digest ", 7))
+	    {
+	      msg (D_PROXY, "PROXY AUTH DIGEST: '%s'", buf);
+	      *data = string_alloc(buf+27, gc);
+	      ret = HTTP_AUTH_DIGEST;
+	    }
+#endif
+#if NTLM
+	  else if (!strncmp(buf+20, "NTLM", 4))
+	    {
+	      msg (D_PROXY, "PROXY AUTH HTLM: '%s'", buf);
+	      *data = NULL;
+	      ret = HTTP_AUTH_NTLM;
+	    }
+#endif
+	}
+    }
+}
+
+static void
+store_proxy_authenticate (struct http_proxy_info *p, char *data)
+{
+  if (p->proxy_authenticate)
+    free (p->proxy_authenticate);
+  p->proxy_authenticate = data;
+}
+
+/*
+ * Parse out key/value pairs from Proxy-Authenticate string.
+ * Return true on success, or false on parse failure.
+ */
+static bool
+get_key_value(const char *str,       /* source string */
+	      char *key,             /* key stored here */
+	      char *value,           /* value stored here */
+	      int max_key_len,
+	      int max_value_len,
+	      const char **endptr)   /* next search position */
+{
+  int c;
+  bool starts_with_quote = false;
+  bool escape = false;
+
+  for (c = max_key_len-1; (*str && (*str != '=') && c--); )
+    *key++ = *str++;
+  *key = '\0';
+
+  if('=' != *str++)
+    /* no key/value found */
+    return false;
+
+  if('\"' == *str)
+    {
+      /* quoted string */
+      str++;
+      starts_with_quote = true;
+    }
+
+  for (c = max_value_len-1; *str && c--; str++)
+    {
+      switch (*str)
+	{
+	case '\\':
+	  if (!escape)
+	    {
+	      /* possibly the start of an escaped quote */
+	      escape = true;
+	      *value++ = '\\'; /* even though this is an escape character, we still
+				  store it as-is in the target buffer */
+	      continue;
+	    }
+	  break;
+	case ',':
+	  if (!starts_with_quote)
+	    {
+	      /* this signals the end of the value if we didn't get a starting quote
+		 and then we do "sloppy" parsing */
+	      c=0; /* the end */
+	      continue;
+	    }
+	  break;
+	case '\r':
+	case '\n':
+	  /* end of string */
+	  c=0;
+	continue;
+	case '\"':
+	  if (!escape && starts_with_quote)
+	    {
+	      /* end of string */
+	      c=0;
+	      continue;
+	    }
+	  break;
+	}
+      escape = false;
+      *value++ = *str;
+    }
+  *value = '\0';
+
+  *endptr = str;
+
+  return true; /* success */
+}
+
+static char *
+get_pa_var (const char *key, const char *pa, struct gc_arena *gc)
+{
+  char k[64];
+  char v[256];
+  const char *content = pa;
+
+  while (true)
+    {
+      const int status = get_key_value(content, k, v, sizeof(k), sizeof(v), &content);
+      if (status)
+	{
+	  if (!strcmp(key, k))
+	    return string_alloc(v, gc);
+	}
+      else
+	return NULL;
+
+      /* advance to start of next key */
+      if (*content == ',')
+	++content;
+      while (*content && isspace(*content))
+	++content;
+    }
+}
 
 struct http_proxy_info *
 http_proxy_new (const struct http_proxy_options *o,
@@ -263,7 +454,8 @@
 
 	  opt.server = auto_proxy_info->http.server;
 	  opt.port = auto_proxy_info->http.port;
-	  opt.auth_retry = true;
+	  if (!opt.auth_retry)
+	    opt.auth_retry = PAR_ALL;
 
 	  o = &opt;
 	}
@@ -285,12 +477,14 @@
 	p->auth_method = HTTP_AUTH_NONE;
       else if (!strcmp (o->auth_method_string, "basic"))
 	p->auth_method = HTTP_AUTH_BASIC;
+#if NTLM
       else if (!strcmp (o->auth_method_string, "ntlm"))
 	p->auth_method = HTTP_AUTH_NTLM;
       else if (!strcmp (o->auth_method_string, "ntlm2"))
 	p->auth_method = HTTP_AUTH_NTLM2;
+#endif
       else
-	msg (M_FATAL, "ERROR: unknown HTTP authentication method: '%s' -- only the 'none', 'basic', 'ntlm', or 'ntlm2' methods are currently supported",
+	msg (M_FATAL, "ERROR: unknown HTTP authentication method: '%s'",
 	     o->auth_method_string);
     }
 
@@ -324,101 +518,113 @@
 			       volatile int *signal_received)
 {
   struct gc_arena gc = gc_new ();
-  char buf[256];
+  char buf[512];
   char buf2[128];
   char get[80];
   int status;
   int nparms;
   bool ret = false;
+  bool processed = false;
 
   /* get user/pass if not previously given or if --auto-proxy is being used */
   if (p->auth_method == HTTP_AUTH_BASIC
+      || p->auth_method == HTTP_AUTH_DIGEST
       || p->auth_method == HTTP_AUTH_NTLM)
     get_user_pass_http (p, false);
 
-  /* format HTTP CONNECT message */
-  openvpn_snprintf (buf, sizeof(buf), "CONNECT %s:%d HTTP/%s",
-		    host,
-		    port,
-		    p->options.http_version);
-
-  msg (D_PROXY, "Send to HTTP proxy: '%s'", buf);
-
-  /* send HTTP CONNECT message to proxy */
-  if (!send_line_crlf (sd, buf))
-    goto error;
-
-  /* send User-Agent string if provided */
-  if (p->options.user_agent)
+  /* are we being called again after getting the digest server nonce in the previous transaction? */
+  if (p->auth_method == HTTP_AUTH_DIGEST && p->proxy_authenticate)
     {
-      openvpn_snprintf (buf, sizeof(buf), "User-Agent: %s",
-			p->options.user_agent);
-      if (!send_line_crlf (sd, buf))
-	goto error;
+      nparms = 1;
+      status = 407;
     }
-
-  /* auth specified? */
-  switch (p->auth_method)
+  else
     {
-    case HTTP_AUTH_NONE:
-      break;
+      /* format HTTP CONNECT message */
+      openvpn_snprintf (buf, sizeof(buf), "CONNECT %s:%d HTTP/%s",
+			host,
+			port,
+			p->options.http_version);
 
-    case HTTP_AUTH_BASIC:
-      openvpn_snprintf (buf, sizeof(buf), "Proxy-Authorization: Basic %s",
-			username_password_as_base64 (p, &gc));
-      msg (D_PROXY, "Attempting Basic Proxy-Authorization");
-      dmsg (D_SHOW_KEYS, "Send to HTTP proxy: '%s'", buf);
-      openvpn_sleep (1);
+      msg (D_PROXY, "Send to HTTP proxy: '%s'", buf);
+
+      /* send HTTP CONNECT message to proxy */
       if (!send_line_crlf (sd, buf))
 	goto error;
-      break;
+
+      /* send User-Agent string if provided */
+      if (p->options.user_agent)
+	{
+	  openvpn_snprintf (buf, sizeof(buf), "User-Agent: %s",
+			    p->options.user_agent);
+	  if (!send_line_crlf (sd, buf))
+	    goto error;
+	}
+
+      /* auth specified? */
+      switch (p->auth_method)
+	{
+	case HTTP_AUTH_NONE:
+	  break;
+
+	case HTTP_AUTH_BASIC:
+	  openvpn_snprintf (buf, sizeof(buf), "Proxy-Authorization: Basic %s",
+			    username_password_as_base64 (p, &gc));
+	  msg (D_PROXY, "Attempting Basic Proxy-Authorization");
+	  dmsg (D_SHOW_KEYS, "Send to HTTP proxy: '%s'", buf);
+	  if (!send_line_crlf (sd, buf))
+	    goto error;
+	  break;
 
 #if NTLM
-    case HTTP_AUTH_NTLM:
-    case HTTP_AUTH_NTLM2:
-      /* keep-alive connection */
-      openvpn_snprintf (buf, sizeof(buf), "Proxy-Connection: Keep-Alive");
-      if (!send_line_crlf (sd, buf))
-	goto error;
+	case HTTP_AUTH_NTLM:
+	case HTTP_AUTH_NTLM2:
+	  /* keep-alive connection */
+	  openvpn_snprintf (buf, sizeof(buf), "Proxy-Connection: Keep-Alive");
+	  if (!send_line_crlf (sd, buf))
+	    goto error;
 
-      openvpn_snprintf (buf, sizeof(buf), "Proxy-Authorization: NTLM %s",
-			ntlm_phase_1 (p, &gc));
-      msg (D_PROXY, "Attempting NTLM Proxy-Authorization phase 1");
-      dmsg (D_SHOW_KEYS, "Send to HTTP proxy: '%s'", buf);
-      openvpn_sleep (1);
-      if (!send_line_crlf (sd, buf))
-	goto error;
-      break;
+	  openvpn_snprintf (buf, sizeof(buf), "Proxy-Authorization: NTLM %s",
+			    ntlm_phase_1 (p, &gc));
+	  msg (D_PROXY, "Attempting NTLM Proxy-Authorization phase 1");
+	  dmsg (D_SHOW_KEYS, "Send to HTTP proxy: '%s'", buf);
+	  if (!send_line_crlf (sd, buf))
+	    goto error;
+	  break;
 #endif
 
-    default:
-      ASSERT (0);
-    }
+	default:
+	  ASSERT (0);
+	}
 
-  /* send empty CR, LF */
-  openvpn_sleep (1);
-  if (!send_crlf (sd))
-    goto error;
+      /* send empty CR, LF */
+      if (!send_crlf (sd))
+	goto error;
 
-  /* receive reply from proxy */
-  if (!recv_line (sd, buf, sizeof(buf), p->options.timeout, true, NULL, signal_received))
-    goto error;
+      /* receive reply from proxy */
+      if (!recv_line (sd, buf, sizeof(buf), p->options.timeout, true, NULL, signal_received))
+	goto error;
+
+      /* remove trailing CR, LF */
+      chomp (buf);
 
-  /* remove trailing CR, LF */
-  chomp (buf);
+      msg (D_PROXY, "HTTP proxy returned: '%s'", buf);
 
-  msg (D_PROXY, "HTTP proxy returned: '%s'", buf);
+      /* parse return string */
+      nparms = sscanf (buf, "%*s %d", &status);
 
-  /* parse return string */
-  nparms = sscanf (buf, "%*s %d", &status);
+    }
 
   /* check for a "407 Proxy Authentication Required" response */
-  if (nparms >= 1 && status == 407)
+  while (nparms >= 1 && status == 407)
     {
       msg (D_PROXY, "Proxy requires authentication");
 
-      /* check for NTLM */
-      if (p->auth_method == HTTP_AUTH_NTLM || p->auth_method == HTTP_AUTH_NTLM2)
+      if (p->auth_method == HTTP_AUTH_BASIC && !processed)
+	{
+	  processed = true;
+	}
+      else if ((p->auth_method == HTTP_AUTH_NTLM || p->auth_method == HTTP_AUTH_NTLM2) && !processed) /* check for NTLM */
         {
 #if NTLM
           /* look for the phase 2 response */
@@ -446,7 +652,7 @@
           msg (D_PROXY, "Received NTLM Proxy-Authorization phase 2 response");
 
           /* receive and discard everything else */
-          while (recv_line (sd, NULL, 0, p->options.timeout, true, NULL, signal_received))
+          while (recv_line (sd, NULL, 0, 2, true, NULL, signal_received))
             ;
 
           /* now send the phase 3 reply */
@@ -470,7 +676,6 @@
 
           
           /* send HOST etc, */
-          openvpn_sleep (1);
           openvpn_snprintf (buf, sizeof(buf), "Host: %s", host);
           msg (D_PROXY, "Send to HTTP proxy: '%s'", buf);
           if (!send_line_crlf (sd, buf))
@@ -488,12 +693,10 @@
 	  }
 
           msg (D_PROXY, "Send to HTTP proxy: '%s'", buf);
-          openvpn_sleep (1);
           if (!send_line_crlf (sd, buf))
 	    goto error;
           /* ok so far... */
           /* send empty CR, LF */
-          openvpn_sleep (1);
           if (!send_crlf (sd))
             goto error;
 
@@ -508,27 +711,167 @@
 
           /* parse return string */
           nparms = sscanf (buf, "%*s %d", &status);
-#else
-	  ASSERT (0); /* No NTLM support */
+	  processed = true;
 #endif
 	}
-      else if (p->auth_method == HTTP_AUTH_NONE && p->options.auth_retry)
+#if PROXY_DIGEST_AUTH
+      else if (p->auth_method == HTTP_AUTH_DIGEST && !processed)
+	{
+	  char *pa = p->proxy_authenticate;
+	  const int method = p->auth_method;
+	  ASSERT(pa);
+
+	  if (method == HTTP_AUTH_DIGEST)
+	    {
+	      const char *http_method = "CONNECT";
+	      const char *nonce_count = "00000001";
+	      const char *qop = "auth";
+	      const char *username = p->up.username;
+	      const char *password = p->up.password;
+	      char *opaque_kv = "";
+	      char uri[128];
+	      uint8_t cnonce_raw[8];
+	      uint8_t *cnonce;
+	      HASHHEX session_key;
+	      HASHHEX response;
+
+	      const char *realm = get_pa_var("realm", pa, &gc);
+	      const char *nonce = get_pa_var("nonce", pa, &gc);
+	      const char *algor = get_pa_var("algorithm", pa, &gc);
+	      const char *opaque = get_pa_var("opaque", pa, &gc);
+
+	      /* generate a client nonce */
+	      ASSERT(RAND_bytes(cnonce_raw, sizeof(cnonce_raw)));
+	      cnonce = make_base64_string2(cnonce_raw, sizeof(cnonce_raw), &gc);
+
+
+	      /* build the digest response */
+	      openvpn_snprintf (uri, sizeof(uri), "%s:%d",
+				host,
+				port);
+
+	      if (opaque)
+		{
+		  const int len = strlen(opaque)+16;
+		  opaque_kv = gc_malloc(len, false, &gc);
+		  openvpn_snprintf (opaque_kv, len, ", opaque=\"%s\"", opaque);
+		}
+
+	      DigestCalcHA1(algor,
+			    username,
+			    realm,
+			    password,
+			    nonce,
+			    (char *)cnonce,
+			    session_key);
+	      DigestCalcResponse(session_key,
+				 nonce,
+				 nonce_count,
+				 (char *)cnonce,
+				 qop,
+				 http_method,
+				 uri,
+				 NULL,
+				 response);
+
+	      /* format HTTP CONNECT message */
+	      openvpn_snprintf (buf, sizeof(buf), "%s %s HTTP/%s",
+				http_method,
+				uri,
+				p->options.http_version);
+
+	      msg (D_PROXY, "Send to HTTP proxy: '%s'", buf);
+
+	      /* send HTTP CONNECT message to proxy */
+	      if (!send_line_crlf (sd, buf))
+		goto error;
+
+	      /* send HOST etc, */
+	      openvpn_snprintf (buf, sizeof(buf), "Host: %s", host);
+	      msg (D_PROXY, "Send to HTTP proxy: '%s'", buf);
+	      if (!send_line_crlf (sd, buf))
+		goto error;
+
+	      /* send digest response */
+	      openvpn_snprintf (buf, sizeof(buf), "Proxy-Authorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", qop=%s, nc=%s, cnonce=\"%s\", response=\"%s\"%s",
+				username,
+				realm,
+				nonce,
+				uri,
+				qop,
+				nonce_count,
+				cnonce,
+				response,
+				opaque_kv
+				);
+	      msg (D_PROXY, "Send to HTTP proxy: '%s'", buf);
+	      if (!send_line_crlf (sd, buf))
+		goto error;
+	      if (!send_crlf (sd))
+		goto error;
+
+	      /* receive reply from proxy */
+	      if (!recv_line (sd, buf, sizeof(buf), p->options.timeout, true, NULL, signal_received))
+		goto error;
+
+	      /* remove trailing CR, LF */
+	      chomp (buf);
+
+	      msg (D_PROXY, "HTTP proxy returned: '%s'", buf);
+
+	      /* parse return string */
+	      nparms = sscanf (buf, "%*s %d", &status);
+	      processed = true;
+	    }
+	  else
+	    {
+	      msg (D_PROXY, "HTTP proxy: digest method not supported");
+	      goto error;
+	    }
+	}
+#endif
+      else if (p->options.auth_retry)
 	{
-	  /*
-	   * Proxy needs authentication, but we don't have a user/pass.
-	   * Now we will change p->auth_method and return true so that
-	   * our caller knows to call us again on a newly opened socket.
-	   * JYFIXME: This code needs to check proxy error output and set
-	   * JYFIXME: p->auth_method = HTTP_AUTH_NTLM if necessary.
-	   */
-	  p->auth_method = HTTP_AUTH_BASIC;
-	  ret = true;
-	  goto done;
+	  /* figure out what kind of authentication the proxy needs */
+	  char *pa = NULL;
+	  const int method = get_proxy_authenticate(sd,
+						    p->options.timeout,
+						    &pa,
+						    NULL,
+						    signal_received);
+	  if (method != HTTP_AUTH_NONE)
+	    {
+	      if (pa)
+		msg (D_PROXY, "HTTP proxy authenticate '%s'", pa);
+	      if (p->options.auth_retry == PAR_NCT && method == HTTP_AUTH_BASIC)
+		{
+		  msg (D_PROXY, "HTTP proxy: support for basic auth and other cleartext proxy auth methods is disabled");
+		  goto error;
+		}
+	      p->auth_method = method;
+	      store_proxy_authenticate(p, pa);
+	      ret = true;
+	      goto done;
+	    }
+	  else
+	    {
+	      msg (D_PROXY, "HTTP proxy: do not recognize the authentication method required by proxy");
+	      free (pa);
+	      goto error;
+	    }
 	}
       else
-	goto error;
-    }
+	{
+	  if (!processed)
+	    msg (D_PROXY, "HTTP proxy: no support for proxy authentication method");
+	  goto error;
+	}
 
+      /* clear state */
+      if (p->options.auth_retry)
+	clear_user_pass_http();
+      store_proxy_authenticate(p, NULL);
+    }
 
   /* check return code, success = 200 */
   if (nparms < 1 || status != 200)
@@ -536,17 +879,13 @@
       msg (D_LINK_ERRORS, "HTTP proxy returned bad status");
 #if 0
       /* DEBUGGING -- show a multi-line HTTP error response */
-      while (true)
-	{
-	  if (!recv_line (sd, buf, sizeof (buf), p->options.timeout, true, NULL, signal_received))
-	    goto error;
-	  chomp (buf);
-	  msg (D_PROXY, "HTTP proxy returned: '%s'", buf);
-	}
+      dump_residual(sd, p->options.timeout, signal_received);
 #endif
       goto error;
     }
 
+  /* SUCCESS */
+
   /* receive line from proxy and discard */
   if (!recv_line (sd, NULL, 0, p->options.timeout, true, NULL, signal_received))
     goto error;
@@ -558,6 +897,9 @@
   while (recv_line (sd, NULL, 0, 2, false, lookahead, signal_received))
     ;
 
+  /* reset queried_creds so that we don't think that the next creds request is due to an auth error */
+  p->queried_creds = false;
+
 #if 0
   if (lookahead && BLEN (lookahead))
     msg (M_INFO, "HTTP PROXY: lookahead: %s", format_hex (BPTR (lookahead), BLEN (lookahead), 0));
diff -urN openvpn-2.1.1/proxy.h openvpn-2.1.3/proxy.h
--- openvpn-2.1.1/proxy.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/proxy.h	2010-05-25 00:49:18.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -55,29 +55,43 @@
 #ifdef ENABLE_HTTP_PROXY
 
 /* HTTP CONNECT authentication methods */
-#define HTTP_AUTH_NONE  0
-#define HTTP_AUTH_BASIC 1
-#define HTTP_AUTH_NTLM  2
-#define HTTP_AUTH_N     3
-#define HTTP_AUTH_NTLM2 4
+#define HTTP_AUTH_NONE   0
+#define HTTP_AUTH_BASIC  1
+#define HTTP_AUTH_DIGEST 2
+#define HTTP_AUTH_NTLM   3
+#define HTTP_AUTH_NTLM2  4
+#define HTTP_AUTH_N      5 /* number of HTTP_AUTH methods */
 
 struct http_proxy_options {
   const char *server;
   int port;
   bool retry;
   int timeout;
-  bool auth_retry;
+
+# define PAR_NO  0  /* don't support any auth retries */
+# define PAR_ALL 1  /* allow all proxy auth protocols */
+# define PAR_NCT 2  /* disable cleartext proxy auth protocols */
+  int auth_retry;
+
   const char *auth_method_string;
   const char *auth_file;
   const char *http_version;
   const char *user_agent;
 };
 
+struct http_proxy_options_simple {
+  const char *server;
+  int port;
+  int auth_retry;
+};
+
 struct http_proxy_info {
   bool defined;
   int auth_method;
   struct http_proxy_options options;
   struct user_pass up;
+  char *proxy_authenticate;
+  bool queried_creds;
 };
 
 struct http_proxy_info *http_proxy_new (const struct http_proxy_options *o,
diff -urN openvpn-2.1.1/ps.c openvpn-2.1.3/ps.c
--- openvpn-2.1.1/ps.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/ps.c	2010-08-27 18:08:48.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/ps.h openvpn-2.1.3/ps.h
--- openvpn-2.1.1/ps.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/ps.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/push.c openvpn-2.1.3/push.c
--- openvpn-2.1.1/push.c	2009-10-01 21:35:38.000000000 +0200
+++ openvpn-2.1.3/push.c	2010-05-31 09:05:55.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -43,6 +43,7 @@
 receive_auth_failed (struct context *c, const struct buffer *buffer)
 {
   msg (M_VERB0, "AUTH: Received AUTH_FAILED control message");
+  connection_list_set_no_advance(&c->options);
   if (c->options.pull)
     {
       switch (auth_retry_get ())
@@ -62,11 +63,11 @@
 #ifdef ENABLE_MANAGEMENT
       if (management)
 	{
-	  const char *reason = UP_TYPE_AUTH;
+	  const char *reason = NULL;
 	  struct buffer buf = *buffer;
 	  if (buf_string_compare_advance (&buf, "AUTH_FAILED,") && BLEN (&buf))
 	    reason = BSTR (&buf);
-	  management_auth_failure (management, reason);
+	  management_auth_failure (management, UP_TYPE_AUTH, reason);
 	}
 #endif
     }
@@ -101,8 +102,8 @@
   schedule_exit (c, c->options.scheduled_exit_interval, SIGTERM);
 
   len = (client_reason ? strlen(client_reason)+1 : 0) + sizeof(auth_failed);
-  if (len > TLS_CHANNEL_BUF_SIZE)
-    len = TLS_CHANNEL_BUF_SIZE;
+  if (len > PUSH_BUNDLE_SIZE)
+    len = PUSH_BUNDLE_SIZE;
 
   {
     struct buffer buf = alloc_buf_gc (len, &gc);
@@ -170,7 +171,7 @@
 send_push_reply (struct context *c)
 {
   struct gc_arena gc = gc_new ();
-  struct buffer buf = alloc_buf_gc (TLS_CHANNEL_BUF_SIZE, &gc);
+  struct buffer buf = alloc_buf_gc (PUSH_BUNDLE_SIZE, &gc);
   struct push_entry *e = c->options.push_list.head;
   bool multi_push = false;
   static char cmd[] = "PUSH_REPLY";
diff -urN openvpn-2.1.1/push.h openvpn-2.1.3/push.h
--- openvpn-2.1.1/push.h	2009-10-01 21:35:38.000000000 +0200
+++ openvpn-2.1.3/push.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/pushlist.h openvpn-2.1.3/pushlist.h
--- openvpn-2.1.1/pushlist.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/pushlist.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/reliable.c openvpn-2.1.3/reliable.c
--- openvpn-2.1.1/reliable.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/reliable.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/reliable.h openvpn-2.1.3/reliable.h
--- openvpn-2.1.1/reliable.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/reliable.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -38,7 +38,7 @@
 #include "session_id.h"
 #include "mtu.h"
 
-/* #define EXPONENTIAL_BACKOFF */
+#define EXPONENTIAL_BACKOFF
 
 #define RELIABLE_ACK_SIZE 8
 
diff -urN openvpn-2.1.1/route.c openvpn-2.1.3/route.c
--- openvpn-2.1.1/route.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/route.c	2010-07-12 03:54:09.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -219,6 +219,7 @@
 
 static bool
 init_route (struct route *r,
+	    struct resolve_list *network_list,
 	    const struct route_option *ro,
 	    const struct route_special_addr *spec)
 {
@@ -237,14 +238,15 @@
   
   if (!get_special_addr (spec, ro->network, &r->network, &status))
     {
-      r->network = getaddr (
-			    GETADDR_RESOLVE
-			    | GETADDR_HOST_ORDER
-			    | GETADDR_WARN_ON_SIGNAL,
-			    ro->network,
-			    0,
-			    &status,
-			    NULL);
+      r->network = getaddr_multi (
+				  GETADDR_RESOLVE
+				  | GETADDR_HOST_ORDER
+				  | GETADDR_WARN_ON_SIGNAL,
+				  ro->network,
+				  0,
+				  &status,
+				  NULL,
+				  network_list);
     }
 
   if (!status)
@@ -438,20 +440,45 @@
   else
     rl->spec.remote_endpoint_defined = false;
 
-  if (!(opt->n >= 0 && opt->n <= rl->capacity))
-    msg (M_FATAL, PACKAGE_NAME " ROUTE: (init) number of route options (%d) is greater than route list capacity (%d)", opt->n, rl->capacity);
-
   /* parse the routes from opt to rl */
   {
     int i, j = 0;
+    bool warned = false;
     for (i = 0; i < opt->n; ++i)
       {
-	if (!init_route (&rl->routes[j],
+	struct resolve_list netlist;
+	struct route r;
+	int k;
+
+	if (!init_route (&r,
+			 &netlist,
 			 &opt->routes[i],
 			 &rl->spec))
 	  ret = false;
 	else
-	  ++j;
+	  {
+	    if (!netlist.len)
+	      {
+		netlist.data[0] = r.network;
+		netlist.len = 1;
+	      }
+	    for (k = 0; k < netlist.len; ++k)
+	      {
+		if (j < rl->capacity)
+		  {
+		    r.network = netlist.data[k];
+		    rl->routes[j++] = r;
+		  }
+		else
+		  {
+		    if (!warned)
+		      {
+			msg (M_WARN, PACKAGE_NAME " ROUTE: routes dropped because number of expanded routes is greater than route list capacity (%d)", rl->capacity);
+			warned = true;
+		      }
+		  }
+	      }
+	  }
       }
     rl->n = j;
   }
@@ -2186,7 +2213,7 @@
 
 #endif
 
-#if AUTO_USERID
+#if AUTO_USERID || defined(ENABLE_PUSH_PEER_INFO)
 
 #if defined(TARGET_LINUX)
 
diff -urN openvpn-2.1.1/route.h openvpn-2.1.3/route.h
--- openvpn-2.1.1/route.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/route.h	2010-05-31 10:06:26.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -174,7 +174,7 @@
 #define TLA_LOCAL           2
 int test_local_addr (const in_addr_t addr);
 
-#if AUTO_USERID
+#if AUTO_USERID || defined(ENABLE_PUSH_PEER_INFO)
 bool get_default_gateway_mac_addr (unsigned char *macaddr);
 #endif
 
diff -urN openvpn-2.1.1/sample-scripts/bs openvpn-2.1.3/sample-scripts/bs
--- openvpn-2.1.1/sample-scripts/bs	2009-11-14 18:19:53.000000000 +0100
+++ openvpn-2.1.3/sample-scripts/bs	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-#!/bin/bash
-
-#################################
-# Set up Ethernet bridge on Linux
-# Requires: bridge-utils
-#################################
-
-# Define Bridge Interface
-br="br0"
-
-# Define list of TAP interfaces to be bridged,
-# for example tap="tap0 tap1 tap2".
-tap="tap7"
-
-# Define physical ethernet interface to be bridged
-# with TAP interface(s) above.
-eth="eth0"
-eth_ip="172.16.37.131"
-eth_netmask="255.255.255.0"
-eth_broadcast="172.16.37.255"
-
-for t in $tap; do
-    openvpn --mktun --dev $t --lladdr fe:ff:ff:ff:01:02
-done
-
-brctl addbr $br
-brctl addif $br $eth
-
-for t in $tap; do
-    brctl addif $br $t
-done
-
-for t in $tap; do
-    ifconfig $t 0.0.0.0 promisc up
-done
-
-ifconfig $eth 0.0.0.0 promisc up
-
-ifconfig $br $eth_ip netmask $eth_netmask broadcast $eth_broadcast
diff -urN openvpn-2.1.1/schedule.c openvpn-2.1.3/schedule.c
--- openvpn-2.1.1/schedule.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/schedule.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/schedule.h openvpn-2.1.3/schedule.h
--- openvpn-2.1.1/schedule.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/schedule.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/service-win32/Makefile.am openvpn-2.1.3/service-win32/Makefile.am
--- openvpn-2.1.1/service-win32/Makefile.am	2009-10-01 20:02:17.000000000 +0200
+++ openvpn-2.1.3/service-win32/Makefile.am	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+#  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/service-win32/Makefile.in openvpn-2.1.3/service-win32/Makefile.in
--- openvpn-2.1.1/service-win32/Makefile.in	2009-12-12 00:27:05.000000000 +0100
+++ openvpn-2.1.3/service-win32/Makefile.in	2010-08-27 18:10:02.000000000 +0200
@@ -21,7 +21,7 @@
 #             packet encryption, packet authentication, and
 #             packet compression.
 #
-#  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+#  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/service-win32/openvpnserv.c openvpn-2.1.3/service-win32/openvpnserv.c
--- openvpn-2.1.1/service-win32/openvpnserv.c	2009-10-01 20:02:17.000000000 +0200
+++ openvpn-2.1.3/service-win32/openvpnserv.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/service-win32/service.c openvpn-2.1.3/service-win32/service.c
--- openvpn-2.1.1/service-win32/service.c	2009-10-01 20:02:17.000000000 +0200
+++ openvpn-2.1.3/service-win32/service.c	2010-08-15 23:51:10.000000000 +0200
@@ -370,11 +370,13 @@
 
    int ret = 0;
 
-   if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
+   if ( GetModuleFileName( NULL, szPath+1, 510 ) == 0 )
    {
       _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
       return 1;
    }
+   szPath[0] = '\"';
+   strcat(szPath, "\"");
 
    schSCManager = OpenSCManager(
                                NULL,                   // machine (NULL == local)
diff -urN openvpn-2.1.1/session_id.c openvpn-2.1.3/session_id.c
--- openvpn-2.1.1/session_id.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/session_id.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/session_id.h openvpn-2.1.3/session_id.h
--- openvpn-2.1.1/session_id.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/session_id.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/shaper.c openvpn-2.1.3/shaper.c
--- openvpn-2.1.1/shaper.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/shaper.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/shaper.h openvpn-2.1.3/shaper.h
--- openvpn-2.1.1/shaper.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/shaper.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/sig.c openvpn-2.1.3/sig.c
--- openvpn-2.1.1/sig.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/sig.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -257,7 +257,7 @@
 
   status_reset (so);
 
-  status_printf (so, PACKAGE_NAME " STATISTICS");
+  status_printf (so, "OpenVPN STATISTICS");
   status_printf (so, "Updated,%s", time_string (0, 0, false, &gc));
   status_printf (so, "TUN/TAP read bytes," counter_format, c->c2.tun_read_bytes);
   status_printf (so, "TUN/TAP write bytes," counter_format, c->c2.tun_write_bytes);
diff -urN openvpn-2.1.1/sig.h openvpn-2.1.3/sig.h
--- openvpn-2.1.1/sig.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/sig.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/socket.c openvpn-2.1.3/socket.c
--- openvpn-2.1.1/socket.c	2009-12-11 05:59:45.000000000 +0100
+++ openvpn-2.1.3/socket.c	2010-07-26 08:15:03.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -89,12 +89,26 @@
 	 bool *succeeded,
 	 volatile int *signal_received)
 {
+  return getaddr_multi (flags, hostname, resolve_retry_seconds, succeeded, signal_received, NULL);
+}
+
+in_addr_t
+getaddr_multi (unsigned int flags,
+	 const char *hostname,
+	 int resolve_retry_seconds,
+	 bool *succeeded,
+	 volatile int *signal_received,
+	 struct resolve_list *reslist)
+{
   struct in_addr ia;
   int status;
   int sigrec = 0;
   int msglevel = (flags & GETADDR_FATAL) ? M_FATAL : D_RESOLVE_ERRORS;
   struct gc_arena gc = gc_new ();
 
+  if (reslist)
+    reslist->len = 0;
+
   if (flags & GETADDR_RANDOMIZE)
     hostname = hostname_randomize(hostname, &gc);
 
@@ -212,12 +226,28 @@
 		++n;
 	      ASSERT (n >= 2);
 
-	      msg (D_RESOLVE_ERRORS, "RESOLVE: NOTE: %s resolves to %d addresses, choosing one by random",
+	      msg (D_RESOLVE_ERRORS, "RESOLVE: NOTE: %s resolves to %d addresses",
 		   hostname,
 		   n);
 
 	      /* choose address randomly, for basic load-balancing capability */
-	      ia.s_addr = *(in_addr_t *) (h->h_addr_list[get_random () % n]);
+	      /*ia.s_addr = *(in_addr_t *) (h->h_addr_list[get_random () % n]);*/
+
+	      /* choose first address */
+	      ia.s_addr = *(in_addr_t *) (h->h_addr_list[0]);
+
+	      if (reslist)
+		{
+		  int i;
+		  for (i = 0; i < n && i < SIZE(reslist->data); ++i)
+		    {
+		      in_addr_t a = *(in_addr_t *) (h->h_addr_list[i]);
+		      if (flags & GETADDR_HOST_ORDER)
+			a = ntohl(a);
+		      reslist->data[i] = a;
+		    }
+		  reslist->len = i;
+		}
 	    }
 	}
 
@@ -486,7 +516,7 @@
 static bool
 socket_set_tcp_nodelay (int sd, int state)
 {
-#if defined(HAVE_SETSOCKOPT) && defined(IPPROTO_TCP) && defined(TCP_NODELAY)
+#if defined(WIN32) || (defined(HAVE_SETSOCKOPT) && defined(IPPROTO_TCP) && defined(TCP_NODELAY))
   if (setsockopt (sd, IPPROTO_TCP, TCP_NODELAY, (void *) &state, sizeof (state)) != 0)
     {
       msg (M_WARN, "NOTE: setsockopt TCP_NODELAY=%d failed", state);
@@ -1291,6 +1321,10 @@
   else if (mode != LS_MODE_TCP_ACCEPT_FROM)
     {
       create_socket (sock);
+
+      /* set socket buffers based on --sndbuf and --rcvbuf options */
+      socket_set_buffers (sock->sd, &sock->socket_buffer_sizes);
+
       resolve_bind_local (sock);
       resolve_remote (sock, 1, NULL, NULL);
     }
@@ -1493,9 +1527,6 @@
 	}
     }
 
-  /* set socket buffers based on --sndbuf and --rcvbuf options */
-  socket_set_buffers (sock->sd, &sock->socket_buffer_sizes);
-
   /* set misc socket parameters */
   socket_set_flags (sock->sd, sock->sockflags);
 
diff -urN openvpn-2.1.1/socket.h openvpn-2.1.3/socket.h
--- openvpn-2.1.1/socket.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/socket.h	2010-07-12 03:54:09.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -439,6 +439,11 @@
  * DNS resolution
  */
 
+struct resolve_list {
+  int len;
+  in_addr_t data[16];
+};
+
 #define GETADDR_RESOLVE               (1<<0)
 #define GETADDR_FATAL                 (1<<1)
 #define GETADDR_HOST_ORDER            (1<<2)
@@ -456,6 +461,13 @@
 		   bool *succeeded,
 		   volatile int *signal_received);
 
+in_addr_t getaddr_multi (unsigned int flags,
+			 const char *hostname,
+			 int resolve_retry_seconds,
+			 bool *succeeded,
+			 volatile int *signal_received,
+			 struct resolve_list *reslist);
+
 /*
  * Transport protocol naming and other details.
  */
diff -urN openvpn-2.1.1/socks.c openvpn-2.1.3/socks.c
--- openvpn-2.1.1/socks.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/socks.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/socks.h openvpn-2.1.3/socks.h
--- openvpn-2.1.1/socks.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/socks.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/ssl.c openvpn-2.1.3/ssl.c
--- openvpn-2.1.1/ssl.c	2009-11-12 21:30:36.000000000 +0100
+++ openvpn-2.1.3/ssl.c	2010-07-27 08:12:04.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -1228,6 +1228,10 @@
 }
 
 #ifdef MANAGEMENT_DEF_AUTH
+/*
+ * For deferred auth, this is where the management interface calls (on server)
+ * to indicate auth failure/success.
+ */
 bool
 tls_authenticate_key (struct tls_multi *multi, const unsigned int mda_key_id, const bool auth, const char *client_reason)
 {
@@ -1635,7 +1639,7 @@
 		{
 #ifdef ENABLE_MANAGEMENT
 		  if (management && (ERR_GET_REASON (ERR_peek_error()) == EVP_R_BAD_DECRYPT))
-		    management_auth_failure (management, UP_TYPE_PRIVATE_KEY);
+		    management_auth_failure (management, UP_TYPE_PRIVATE_KEY, NULL);
 #endif
 		  msg (M_WARN|M_SSL, "Cannot load private key file %s", options->priv_key_file);
 		  goto err;
@@ -2262,6 +2266,7 @@
   free_buf (&ks->plaintext_read_buf);
   free_buf (&ks->plaintext_write_buf);
   free_buf (&ks->ack_write_buf);
+  buffer_list_free(ks->paybuf);
 
   if (ks->send_reliable)
     {
@@ -2554,6 +2559,8 @@
 
 #ifdef MANAGEMENT_DEF_AUTH
   man_def_auth_set_client_reason(multi, NULL);  
+
+  free (multi->peer_info);
 #endif
 
   if (multi->locked_cn)
@@ -3058,6 +3065,17 @@
   return 1;
 }
 
+static void
+flush_payload_buffer (struct tls_multi *multi, struct key_state *ks)
+{
+  struct buffer *b;
+  while ((b = buffer_list_peek (ks->paybuf)))
+    {
+      key_state_write_plaintext_const (multi, ks, b->data, b->len);
+      buffer_list_pop (ks->paybuf);
+    }
+}
+
 /*
  * Macros for key_state_soft_reset & tls_process
  */
@@ -3102,6 +3120,14 @@
 }
 
 static bool
+write_empty_string (struct buffer *buf)
+{
+  if (!buf_write_u16 (buf, 0))
+    return false;
+  return true;
+}
+
+static bool
 read_string (struct buffer *buf, char *str, const unsigned int capacity)
 {
   const int len = buf_read_u16 (buf);
@@ -3113,6 +3139,33 @@
   return true;
 }
 
+static char *
+read_string_alloc (struct buffer *buf)
+{
+  const int len = buf_read_u16 (buf);
+  char *str;
+
+  if (len < 1)
+    return NULL;
+  str = (char *) malloc(len);
+  check_malloc_return(str);
+  if (!buf_read (buf, str, len))
+    {
+      free (str);
+      return NULL;
+    }
+  str[len-1] = '\0';
+  return str;
+}
+
+void
+read_string_discard (struct buffer *buf)
+{
+  char *data = read_string_alloc(buf);
+  if (data)
+    free (data);
+}
+
 /*
  * Authenticate a client using username/password.
  * Runs on server.
@@ -3324,6 +3377,73 @@
 }
 
 static bool
+push_peer_info(struct buffer *buf, struct tls_session *session)
+{
+  struct gc_arena gc = gc_new ();
+  bool ret = false;
+
+#ifdef ENABLE_PUSH_PEER_INFO
+  if (session->opt->push_peer_info) /* write peer info */
+    {
+      struct env_set *es = session->opt->es;
+      struct env_item *e;
+      struct buffer out = alloc_buf_gc (512*3, &gc);
+
+      /* push version */
+      buf_printf (&out, "IV_VER=%s\n", PACKAGE_VERSION);
+
+      /* push platform */
+#if defined(TARGET_LINUX)
+      buf_printf (&out, "IV_PLAT=linux\n");
+#elif defined(TARGET_SOLARIS)
+      buf_printf (&out, "IV_PLAT=solaris\n");
+#elif defined(TARGET_OPENBSD)
+      buf_printf (&out, "IV_PLAT=openbsd\n");
+#elif defined(TARGET_DARWIN)
+      buf_printf (&out, "IV_PLAT=mac\n");
+#elif defined(TARGET_NETBSD)
+      buf_printf (&out, "IV_PLAT=netbsd\n");
+#elif defined(TARGET_FREEBSD)
+      buf_printf (&out, "IV_PLAT=freebsd\n");
+#elif defined(WIN32)
+      buf_printf (&out, "IV_PLAT=win\n");
+#endif
+
+      /* push mac addr */
+      {
+	bool get_default_gateway_mac_addr (unsigned char *macaddr);
+	uint8_t macaddr[6];
+	get_default_gateway_mac_addr (macaddr);
+	buf_printf (&out, "IV_HWADDR=%s\n", format_hex_ex (macaddr, 6, 0, 1, ":", &gc));
+      }
+
+      /* push env vars that begin with UV_ */
+      for (e=es->list; e != NULL; e=e->next)
+	{
+	  if (e->string)
+	    {
+	      if (!strncmp(e->string, "UV_", 3) && buf_safe(&out, strlen(e->string)+1))
+		buf_printf (&out, "%s\n", e->string);
+	    }
+	}
+
+      if (!write_string(buf, BSTR(&out), -1))
+	goto error;
+    }
+  else
+#endif
+    {
+      if (!write_empty_string (buf)) /* no peer info */
+	goto error;
+    }
+  ret = true;
+
+ error:
+  gc_free (&gc);
+  return ret;
+}
+
+static bool
 key_method_2_write (struct buffer *buf, struct tls_session *session)
 {
   ASSERT (session->opt->key_method == 2);
@@ -3357,6 +3477,16 @@
 	goto error;
       purge_user_pass (&auth_user_pass, false);
     }
+  else
+    {
+      if (!write_empty_string (buf)) /* no username */
+	goto error;
+      if (!write_empty_string (buf)) /* no password */
+	goto error;
+    }
+
+  if (!push_peer_info (buf, session))
+    goto error;
 
   /*
    * generate tunnel keys if server
@@ -3503,11 +3633,13 @@
       int s1 = OPENVPN_PLUGIN_FUNC_SUCCESS;
       bool s2 = true;
       char *raw_username;
+      bool username_status, password_status;
 
       /* get username/password from plaintext buffer */
       ALLOC_OBJ_CLEAR_GC (up, struct user_pass, &gc);
-      if (!read_string (buf, up->username, USER_PASS_LEN)
-	  || !read_string (buf, up->password, USER_PASS_LEN))
+      username_status = read_string (buf, up->username, USER_PASS_LEN);
+      password_status = read_string (buf, up->password, USER_PASS_LEN);
+      if (!username_status || !password_status)
 	{
 	  CLEAR (*up);
 	  if (!(session->opt->ssl_flags & SSLF_AUTH_USER_PASS_OPTIONAL))
@@ -3528,6 +3660,10 @@
 
       /* call plugin(s) and/or script */
 #ifdef MANAGEMENT_DEF_AUTH
+      /* get peer info from control channel */
+      free (multi->peer_info);
+      multi->peer_info = read_string_alloc (buf);
+
       if (man_def_auth == KMDA_DEF)
 	man_def_auth = verify_user_pass_management (session, up, raw_username);
 #endif
@@ -3698,9 +3834,12 @@
 static int
 auth_deferred_expire_window (const struct tls_options *o)
 {
-  const int hw = o->handshake_window;
+  int ret = o->handshake_window;
   const int r2 = o->renegotiate_seconds / 2;
-  return min_int (hw, r2);
+
+  if (o->renegotiate_seconds && r2 < ret)
+    ret = r2;
+  return ret;
 }
 
 /*
@@ -3851,6 +3990,9 @@
 		  /* Set outgoing address for data channel packets */
 		  link_socket_set_outgoing_addr (NULL, to_link_socket_info, &ks->remote_addr, session->common_name, session->opt->es);
 
+		  /* Flush any payload packets that were buffered before our state transitioned to S_ACTIVE */
+		  flush_payload_buffer (multi, ks);
+
 #ifdef MEASURE_TLS_HANDSHAKE_STATS
 		  show_tls_performance_stats();
 #endif
@@ -4950,6 +5092,13 @@
       if (key_state_write_plaintext_const (multi, ks, data, size) == 1)
 	ret = true;
     }
+  else
+    {
+      if (!ks->paybuf)
+	ks->paybuf = buffer_list_new (0);
+      buffer_list_push_data (ks->paybuf, data, (size_t)size);
+      ret = true;
+    }
 
   ERR_clear_error ();
 
diff -urN openvpn-2.1.1/ssl.h openvpn-2.1.3/ssl.h
--- openvpn-2.1.1/ssl.h	2009-11-12 13:04:18.000000000 +0100
+++ openvpn-2.1.3/ssl.h	2010-07-27 08:13:00.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -376,6 +376,8 @@
   struct reliable *rec_reliable;  /* order incoming ciphertext packets before we pass to TLS */
   struct reliable_ack *rec_ack;	  /* buffers all packet IDs we want to ACK back to sender */
 
+  struct buffer_list *paybuf;
+
   int n_bytes;			 /* how many bytes sent/recvd since last key exchange */
   int n_packets;		 /* how many packets sent/recvd since last key exchange */
 
@@ -432,6 +434,9 @@
 #ifdef ENABLE_OCC
   bool disable_occ;
 #endif
+#ifdef ENABLE_PUSH_PEER_INFO
+  bool push_peer_info;
+#endif
   int transition_window;
   int handshake_window;
   interval_t packet_timeout;
@@ -618,6 +623,12 @@
    */
   char *client_reason;
 
+  /*
+   * A multi-line string of general-purpose info received from peer
+   * over control channel.
+   */
+  char *peer_info;
+
   /* Time of last call to tls_authentication_status */
   time_t tas_last;
 #endif
@@ -721,6 +732,12 @@
 
 #ifdef MANAGEMENT_DEF_AUTH
 bool tls_authenticate_key (struct tls_multi *multi, const unsigned int mda_key_id, const bool auth, const char *client_reason);
+
+static inline char *
+tls_get_peer_info(const struct tls_multi *multi)
+{
+  return multi->peer_info;
+}
 #endif
 
 /*
diff -urN openvpn-2.1.1/status.c openvpn-2.1.3/status.c
--- openvpn-2.1.1/status.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/status.c	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/status.h openvpn-2.1.3/status.h
--- openvpn-2.1.1/status.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/status.h	2010-04-28 18:25:39.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/syshead.h openvpn-2.1.3/syshead.h
--- openvpn-2.1.1/syshead.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/syshead.h	2010-07-27 00:06:51.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -531,11 +531,9 @@
 #endif
 
 /*
- * Don't compile the struct buffer_list code unless something needs it
+ * Compile the struct buffer_list code
  */
-#if defined(ENABLE_MANAGEMENT) || defined(ENABLE_PF)
 #define ENABLE_BUFFER_LIST
-#endif
 
 /*
  * Do we have pthread capability?
@@ -572,6 +570,15 @@
 #endif
 
 /*
+ * Should we include proxy digest auth functionality
+ */
+#if defined(USE_CRYPTO) && defined(ENABLE_HTTP_PROXY)
+#define PROXY_DIGEST_AUTH 1
+#else
+#define PROXY_DIGEST_AUTH 0
+#endif
+
+/*
  * Should we include code common to all proxy methods?
  */
 #if defined(ENABLE_HTTP_PROXY) || defined(ENABLE_SOCKS)
@@ -616,6 +623,22 @@
 #define ENABLE_INLINE_FILES 1
 
 /*
+ * Support "connection" directive
+ */
+#if ENABLE_INLINE_FILES
+#define ENABLE_CONNECTION 1
+#endif
+
+/*
+ * Should we include http proxy fallback functionality
+ */
+#if defined(ENABLE_CONNECTION) && defined(ENABLE_MANAGEMENT) && defined(ENABLE_HTTP_PROXY)
+#define HTTP_PROXY_FALLBACK 1
+#else
+#define HTTP_PROXY_FALLBACK 0
+#endif
+
+/*
  * Reduce sensitivity to system clock instability
  * and backtracks.
  */
@@ -638,10 +661,8 @@
 #endif
 
 /*
- * Support "connection" directive
+ * Do we support pushing peer info?
  */
-#if ENABLE_INLINE_FILES
-#define ENABLE_CONNECTION 1
-#endif
+#define ENABLE_PUSH_PEER_INFO
 
 #endif
diff -urN openvpn-2.1.1/tap-win32/SOURCES.in openvpn-2.1.3/tap-win32/SOURCES.in
--- openvpn-2.1.1/tap-win32/SOURCES.in	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/tap-win32/SOURCES.in	2010-04-28 18:16:46.000000000 +0200
@@ -8,7 +8,7 @@
 TARGETTYPE=DRIVER
 TARGETPATH=.
 TARGETLIBS=$(DDK_LIB_PATH)\ndis.lib $(DDK_LIB_PATH)\ntstrsafe.lib
-INCLUDES=$(DDK_INCLUDE_PATH)
+INCLUDES=$(DDK_INCLUDE_PATH) ..
 
 # The TAP version numbers here must be >=
 # TAP_WIN32_MIN_x values defined in
@@ -53,7 +53,7 @@
 !ENDIF
 
 # Generate a linker map file just in case we need one for debugging
-LINKER_FLAGS=$(LINKER_FLAGS) /MAP /MAPINFO:EXPORTS /MAPINFO:LINES
+LINKER_FLAGS=$(LINKER_FLAGS) /INCREMENTAL:NO /MAP /MAPINFO:EXPORTS
 
 # Generate a browser information file for use in IDE development
 #BROWSER_INFO=1
diff -urN openvpn-2.1.1/tap-win32/common.h openvpn-2.1.3/tap-win32/common.h
--- openvpn-2.1.1/tap-win32/common.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/common.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -28,15 +28,7 @@
 // common to both.
 //===============================================
 
-#if defined(HAVE_CONFIG_H)
-#include "config.h"
-#else
-#if defined(_MSC_VER) && !defined(TAP_DRIVER_MAJOR_VERSION)
-#include "config-win32.h"
-#else
-#include "../config.h"
-#endif
-#endif
+#include "autodefs.h"
 
 //=============
 // TAP IOCTLs
diff -urN openvpn-2.1.1/tap-win32/constants.h openvpn-2.1.3/tap-win32/constants.h
--- openvpn-2.1.1/tap-win32/constants.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/constants.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/dhcp.c openvpn-2.1.3/tap-win32/dhcp.c
--- openvpn-2.1.1/tap-win32/dhcp.c	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/dhcp.c	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/dhcp.h openvpn-2.1.3/tap-win32/dhcp.h
--- openvpn-2.1.1/tap-win32/dhcp.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/dhcp.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/endian.h openvpn-2.1.3/tap-win32/endian.h
--- openvpn-2.1.1/tap-win32/endian.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/endian.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/error.c openvpn-2.1.3/tap-win32/error.c
--- openvpn-2.1.1/tap-win32/error.c	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/error.c	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/error.h openvpn-2.1.3/tap-win32/error.h
--- openvpn-2.1.1/tap-win32/error.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/error.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/filt.py openvpn-2.1.3/tap-win32/filt.py
--- openvpn-2.1.1/tap-win32/filt.py	2009-12-11 06:04:40.000000000 +0100
+++ openvpn-2.1.3/tap-win32/filt.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,20 +0,0 @@
-import sys
-import re
-
-start_re = "(^.*released under the GPL version 2 \(see below\)).*however due"
-skip = 0
-while True:
-    line = sys.stdin.readline()
-    if not line:
-        break
-    m = re.match (start_re, line)
-    if m:
-        g = m.groups()
-        print g[0] + '.'
-        skip = 5
-    if skip > 0:
-        skip -= 1
-    else:
-        print line,
-
-sys.exit(0)
diff -urN openvpn-2.1.1/tap-win32/hexdump.c openvpn-2.1.3/tap-win32/hexdump.c
--- openvpn-2.1.1/tap-win32/hexdump.c	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/hexdump.c	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/hexdump.h openvpn-2.1.3/tap-win32/hexdump.h
--- openvpn-2.1.1/tap-win32/hexdump.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/hexdump.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/i386/OemWin2k.inf.in openvpn-2.1.3/tap-win32/i386/OemWin2k.inf.in
--- openvpn-2.1.1/tap-win32/i386/OemWin2k.inf.in	2009-10-01 20:02:17.000000000 +0200
+++ openvpn-2.1.3/tap-win32/i386/OemWin2k.inf.in	2010-04-28 18:25:39.000000000 +0200
@@ -1,5 +1,5 @@
 ; ****************************************************************************
-; * Copyright (C) 2002-2009 OpenVPN Technologies, Inc.                            *
+; * Copyright (C) 2002-2010 OpenVPN Technologies, Inc.                            *
 ; *  This program is free software; you can redistribute it and/or modify    *
 ; *  it under the terms of the GNU General Public License version 2          *
 ; *  as published by the Free Software Foundation.                           *
diff -urN openvpn-2.1.1/tap-win32/instance.c openvpn-2.1.3/tap-win32/instance.c
--- openvpn-2.1.1/tap-win32/instance.c	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/instance.c	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/lock.h openvpn-2.1.3/tap-win32/lock.h
--- openvpn-2.1.1/tap-win32/lock.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/lock.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/macinfo.c openvpn-2.1.3/tap-win32/macinfo.c
--- openvpn-2.1.1/tap-win32/macinfo.c	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/macinfo.c	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/macinfo.h openvpn-2.1.3/tap-win32/macinfo.h
--- openvpn-2.1.1/tap-win32/macinfo.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/macinfo.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/mem.c openvpn-2.1.3/tap-win32/mem.c
--- openvpn-2.1.1/tap-win32/mem.c	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/mem.c	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/proto.h openvpn-2.1.3/tap-win32/proto.h
--- openvpn-2.1.1/tap-win32/proto.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/proto.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/prototypes.h openvpn-2.1.3/tap-win32/prototypes.h
--- openvpn-2.1.1/tap-win32/prototypes.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/prototypes.h	2010-04-28 18:25:39.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/tap-win32/resource.rc openvpn-2.1.3/tap-win32/resource.rc
--- openvpn-2.1.1/tap-win32/resource.rc	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/tap-win32/resource.rc	2010-04-28 18:16:46.000000000 +0200
@@ -2,7 +2,6 @@
 #include <ntverp.h>
 
 /* get VERSION */
-#include "../config-win32.h"
 #include "common.h"
 
 /* VER_FILETYPE, VER_FILESUBTYPE, VER_FILEDESCRIPTION_STR
@@ -36,7 +35,7 @@
 #define VER_COMPANYNAME_STR         "The OpenVPN Project"
 #define VER_FILEDESCRIPTION_STR     "TAP-Win32 Virtual Network Driver"
 #define VER_ORIGINALFILENAME_STR    TAP_COMPONENT_ID ".sys"
-#define VER_LEGALCOPYRIGHT_YEARS    "2003-2009"
+#define VER_LEGALCOPYRIGHT_YEARS    "2003-2010"
 #define VER_LEGALCOPYRIGHT_STR      "OpenVPN Technologies, Inc."
 
 
@@ -46,7 +45,7 @@
 #define XSTR(s) STR(s)
 #define STR(s) #s
 
-#define VSTRING VERSION " " XSTR(TAP_DRIVER_MAJOR_VERSION) "/" XSTR(TAP_DRIVER_MINOR_VERSION)
+#define VSTRING PACKAGE_VERSION " " XSTR(TAP_DRIVER_MAJOR_VERSION) "/" XSTR(TAP_DRIVER_MINOR_VERSION)
 
 #ifdef DBG
 #define VER_PRODUCTVERSION_STR      VSTRING " (DEBUG)"
diff -urN openvpn-2.1.1/tap-win32/tapdrvr.c openvpn-2.1.3/tap-win32/tapdrvr.c
--- openvpn-2.1.1/tap-win32/tapdrvr.c	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tapdrvr.c	2010-04-28 18:25:40.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -35,7 +35,7 @@
 // TAP_IOCTL_CONFIG_TUN ioctl.
 //======================================================
 
-#include "../../autodefs/defs.h"
+#include "common.h"
 #ifndef DDKVER_MAJOR
 #error DDKVER_MAJOR must be defined as the major number of the DDK Version
 #endif
@@ -78,7 +78,6 @@
 
 #include "lock.h"
 #include "constants.h"
-#include "common.h"
 #include "proto.h"
 #include "error.h"
 #include "endian.h"
@@ -209,7 +208,7 @@
 		 TAP_DRIVER_MINOR_VERSION,
 		 __DATE__,
 		 __TIME__));
-	DEBUGP (("Registry Path: '%S'\n", p_RegistryPath->Buffer));
+	DEBUGP (("Registry Path: '%.*S'\n", p_RegistryPath->Length/2, p_RegistryPath->Buffer));
 	break;
       }
 
@@ -414,7 +413,9 @@
 	{
 	  if (parm->ParameterType == NdisParameterString)
 	    {
-	      DEBUGP (("[TAP] NdisReadConfiguration (MiniportName=%S)\n", parm->ParameterData.StringData.Buffer));
+	      DEBUGP (("[TAP] NdisReadConfiguration (MiniportName=%.*S)\n",
+		       parm->ParameterData.StringData.Length/2,
+		       parm->ParameterData.StringData.Buffer));
 
 	      if (RtlUnicodeStringToAnsiString (
 						&l_Adapter->m_NameAnsi,
diff -urN openvpn-2.1.1/tap-win32/tmp/common.h openvpn-2.1.3/tap-win32/tmp/common.h
--- openvpn-2.1.1/tap-win32/tmp/common.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/common.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,92 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-//===============================================
-// This file is included both by OpenVPN and
-// the TAP-Win32 driver and contains definitions
-// common to both.
-//===============================================
-
-#if defined(HAVE_CONFIG_H)
-#include "config.h"
-#else
-#if defined(_MSC_VER) && !defined(TAP_DRIVER_MAJOR_VERSION)
-#include "config-win32.h"
-#else
-#include "../config.h"
-#endif
-#endif
-
-//=============
-// TAP IOCTLs
-//=============
-
-#define TAP_CONTROL_CODE(request,method) \
-  CTL_CODE (FILE_DEVICE_UNKNOWN, request, method, FILE_ANY_ACCESS)
-
-// Present in 8.1
-
-#define TAP_IOCTL_GET_MAC               TAP_CONTROL_CODE (1, METHOD_BUFFERED)
-#define TAP_IOCTL_GET_VERSION           TAP_CONTROL_CODE (2, METHOD_BUFFERED)
-#define TAP_IOCTL_GET_MTU               TAP_CONTROL_CODE (3, METHOD_BUFFERED)
-#define TAP_IOCTL_GET_INFO              TAP_CONTROL_CODE (4, METHOD_BUFFERED)
-#define TAP_IOCTL_CONFIG_POINT_TO_POINT TAP_CONTROL_CODE (5, METHOD_BUFFERED)
-#define TAP_IOCTL_SET_MEDIA_STATUS      TAP_CONTROL_CODE (6, METHOD_BUFFERED)
-#define TAP_IOCTL_CONFIG_DHCP_MASQ      TAP_CONTROL_CODE (7, METHOD_BUFFERED)
-#define TAP_IOCTL_GET_LOG_LINE          TAP_CONTROL_CODE (8, METHOD_BUFFERED)
-#define TAP_IOCTL_CONFIG_DHCP_SET_OPT   TAP_CONTROL_CODE (9, METHOD_BUFFERED)
-
-// Added in 8.2
-
-/* obsoletes TAP_IOCTL_CONFIG_POINT_TO_POINT */
-#define TAP_IOCTL_CONFIG_TUN            TAP_CONTROL_CODE (10, METHOD_BUFFERED)
-
-//=================
-// Registry keys
-//=================
-
-#define ADAPTER_KEY "SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}"
-
-#define NETWORK_CONNECTIONS_KEY "SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}"
-
-//======================
-// Filesystem prefixes
-//======================
-
-#define USERMODEDEVICEDIR "\\\\.\\Global\\"
-#define SYSDEVICEDIR      "\\Device\\"
-#define USERDEVICEDIR     "\\DosDevices\\Global\\"
-#define TAPSUFFIX         ".tap"
-
-//=========================================================
-// TAP_COMPONENT_ID -- This string defines the TAP driver
-// type -- different component IDs can reside in the system
-// simultaneously.
-//=========================================================
-
-#define TAP_COMPONENT_ID TAP_ID
diff -urN openvpn-2.1.1/tap-win32/tmp/constants.h openvpn-2.1.3/tap-win32/tmp/constants.h
--- openvpn-2.1.1/tap-win32/tmp/constants.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/constants.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-//====================================================================
-//                        Product and Version public settings
-//====================================================================
-
-#define PRODUCT_STRING PRODUCT_TAP_DEVICE_DESCRIPTION
-
-#define TAP_NDIS_MAJOR_VERSION 5
-#define TAP_NDIS_MINOR_VERSION 0
-
-//===========================================================
-// Driver constants
-//===========================================================
-
-#define ETHERNET_HEADER_SIZE     (sizeof (ETH_HEADER))
-#define ETHERNET_MTU             1500
-#define ETHERNET_PACKET_SIZE     (ETHERNET_MTU + ETHERNET_HEADER_SIZE)
-#define DEFAULT_PACKET_LOOKAHEAD (ETHERNET_PACKET_SIZE)
-
-#define NIC_MAX_MCAST_LIST 32  // Max length of multicast address list
-
-#define MINIMUM_MTU 576        // USE TCP Minimum MTU
-#define MAXIMUM_MTU 65536      // IP maximum MTU
-
-#define PACKET_QUEUE_SIZE   64 // tap -> userspace queue size
-#define IRP_QUEUE_SIZE      16 // max number of simultaneous i/o operations from userspace
-#define INJECT_QUEUE_SIZE   16 // DHCP/ARP -> tap injection queue
-
-#define TAP_LITTLE_ENDIAN      // affects ntohs, htonl, etc. functions
diff -urN openvpn-2.1.1/tap-win32/tmp/dhcp.c openvpn-2.1.3/tap-win32/tmp/dhcp.c
--- openvpn-2.1.1/tap-win32/tmp/dhcp.c	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/dhcp.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,603 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-//=========================
-// Code to set DHCP options
-//=========================
-
-VOID
-SetDHCPOpt (DHCPMsg *m, void *data, unsigned int len)
-{
-  if (!m->overflow)
-    {
-      if (m->optlen + len <= DHCP_OPTIONS_BUFFER_SIZE)
-	{
-	  if (len)
-	    {
-	      NdisMoveMemory (m->msg.options + m->optlen, data, len);
-	      m->optlen += len;
-	    }
-	}
-      else
-	{
-	  m->overflow = TRUE;
-	}
-    }
-}
-
-VOID
-SetDHCPOpt0 (DHCPMsg *msg, int type)
-{
-  DHCPOPT0 opt;
-  opt.type = (UCHAR) type;
-  SetDHCPOpt (msg, &opt, sizeof (opt));
-}
-
-VOID
-SetDHCPOpt8 (DHCPMsg *msg, int type, ULONG data)
-{
-  DHCPOPT8 opt;
-  opt.type = (UCHAR) type;
-  opt.len = sizeof (opt.data);
-  opt.data = (UCHAR) data;
-  SetDHCPOpt (msg, &opt, sizeof (opt));
-}
-
-VOID
-SetDHCPOpt32 (DHCPMsg *msg, int type, ULONG data)
-{
-  DHCPOPT32 opt;
-  opt.type = (UCHAR) type;
-  opt.len = sizeof (opt.data);
-  opt.data = data;
-  SetDHCPOpt (msg, &opt, sizeof (opt));
-}
-
-//==============
-// Checksum code
-//==============
-
-USHORT
-ip_checksum (const UCHAR *buf, const int len_ip_header)
-{
-  USHORT word16;
-  ULONG sum = 0;
-  int i;
-    
-  // make 16 bit words out of every two adjacent 8 bit words in the packet
-  // and add them up
-  for (i = 0; i < len_ip_header - 1; i += 2) {
-    word16 = ((buf[i] << 8) & 0xFF00) + (buf[i+1] & 0xFF);
-    sum += (ULONG) word16;
-  }
-
-  // take only 16 bits out of the 32 bit sum and add up the carries
-  while (sum >> 16)
-    sum = (sum & 0xFFFF) + (sum >> 16);
-
-  // one's complement the result
-  return ((USHORT) ~sum);
-}
-
-USHORT
-udp_checksum (const UCHAR *buf,
-	      const int len_udp,
-	      const UCHAR *src_addr,
-	      const UCHAR *dest_addr)
-{
-  USHORT word16;
-  ULONG sum = 0;
-  int i;
-	
-  // make 16 bit words out of every two adjacent 8 bit words and 
-  // calculate the sum of all 16 bit words
-  for (i = 0; i < len_udp; i += 2){
-    word16 = ((buf[i] << 8) & 0xFF00) + ((i + 1 < len_udp) ? (buf[i+1] & 0xFF) : 0);
-    sum += word16;
-  }
-
-  // add the UDP pseudo header which contains the IP source and destination addresses
-  for (i = 0; i < 4; i += 2){
-    word16 =((src_addr[i] << 8) & 0xFF00) + (src_addr[i+1] & 0xFF);
-    sum += word16;
-  }
-  for (i = 0; i < 4; i += 2){
-    word16 =((dest_addr[i] << 8) & 0xFF00) + (dest_addr[i+1] & 0xFF);
-    sum += word16; 	
-  }
-
-  // the protocol number and the length of the UDP packet
-  sum += (USHORT) IPPROTO_UDP + (USHORT) len_udp;
-
-  // keep only the last 16 bits of the 32 bit calculated sum and add the carries
-  while (sum >> 16)
-    sum = (sum & 0xFFFF) + (sum >> 16);
-		
-  // Take the one's complement of sum
-  return ((USHORT) ~sum);
-}
-
-//================================
-// Set IP and UDP packet checksums
-//================================
-
-VOID
-SetChecksumDHCPMsg (DHCPMsg *m)
-{
-  // Set IP checksum
-  m->msg.pre.ip.check = htons (ip_checksum ((UCHAR *) &m->msg.pre.ip, sizeof (IPHDR)));
-
-  // Set UDP Checksum
-  m->msg.pre.udp.check = htons (udp_checksum ((UCHAR *) &m->msg.pre.udp, 
-					      sizeof (UDPHDR) + sizeof (DHCP) + m->optlen,
-					      (UCHAR *)&m->msg.pre.ip.saddr,
-					      (UCHAR *)&m->msg.pre.ip.daddr));
-}
-
-//===================
-// DHCP message tests
-//===================
-
-int
-GetDHCPMessageType (const DHCP *dhcp, const int optlen)
-{
-  const UCHAR *p = (UCHAR *) (dhcp + 1);
-  int i;
-
-  for (i = 0; i < optlen; ++i)
-    {
-      const UCHAR type = p[i];
-      const int room = optlen - i - 1;
-      if (type == DHCP_END)           // didn't find what we were looking for
-	return -1;
-      else if (type == DHCP_PAD)      // no-operation
-	;
-      else if (type == DHCP_MSG_TYPE) // what we are looking for
-	{
-	  if (room >= 2)
-	    {
-	      if (p[i+1] == 1)        // message length should be 1
-		return p[i+2];        // return message type
-	    }
-	  return -1;
-	}
-      else                            // some other message
-	{
-	  if (room >= 1)
-	    {
-	      const int len = p[i+1]; // get message length
-	      i += (len + 1);         // advance to next message
-	    }
-	}
-    }
-  return -1;
-}
-
-BOOLEAN
-DHCPMessageOurs (const TapAdapterPointer p_Adapter,
-		 const ETH_HEADER *eth,
-		 const IPHDR *ip,
-		 const UDPHDR *udp,
-		 const DHCP *dhcp)
-{
-  // Must be UDPv4 protocol
-  if (!(eth->proto == htons (ETH_P_IP) && ip->protocol == IPPROTO_UDP))
-    return FALSE;
-
-  // Source MAC must be our adapter
-  if (!MAC_EQUAL (eth->src, p_Adapter->m_MAC))
-    return FALSE;
-
-  // Dest MAC must be either broadcast or our virtual DHCP server
-  if (!(MAC_EQUAL (eth->dest, p_Adapter->m_MAC_Broadcast)
-	|| MAC_EQUAL (eth->dest, p_Adapter->m_dhcp_server_mac)))
-    return FALSE;
-
-  // Port numbers must be correct
-  if (!(udp->dest == htons (BOOTPS_PORT)
-	&& udp->source == htons (BOOTPC_PORT)))
-    return FALSE;
-
-  // Hardware address must be MAC addr sized
-  if (!(dhcp->hlen == sizeof (MACADDR)))
-    return FALSE;
-
-  // Hardware address must match our adapter
-  if (!MAC_EQUAL (eth->src, dhcp->chaddr))
-    return FALSE;
-
-  return TRUE;
-}
-
-
-//=====================================================
-// Build all of DHCP packet except for DHCP options.
-// Assume that *p has been zeroed before we are called.
-//=====================================================
-
-VOID
-BuildDHCPPre (const TapAdapterPointer a,
-	      DHCPPre *p,
-	      const ETH_HEADER *eth,
-	      const IPHDR *ip,
-	      const UDPHDR *udp,
-	      const DHCP *dhcp,
-	      const int optlen,
-	      const int type)
-{
-  // Should we broadcast or direct to a specific MAC / IP address?
-  const BOOLEAN broadcast = (type == DHCPNAK
-			     || MAC_EQUAL (eth->dest, a->m_MAC_Broadcast));
-  // Build ethernet header
-
-  COPY_MAC (p->eth.src, a->m_dhcp_server_mac);
-
-  if (broadcast)
-    COPY_MAC (p->eth.dest, a->m_MAC_Broadcast);
-  else
-    COPY_MAC (p->eth.dest, eth->src);
-
-  p->eth.proto = htons (ETH_P_IP);
-
-  // Build IP header
-
-  p->ip.version_len = (4 << 4) | (sizeof (IPHDR) >> 2);
-  p->ip.tos = 0;
-  p->ip.tot_len = htons (sizeof (IPHDR) + sizeof (UDPHDR) + sizeof (DHCP) + optlen);
-  p->ip.id = 0;
-  p->ip.frag_off = 0;
-  p->ip.ttl = 16;
-  p->ip.protocol = IPPROTO_UDP;
-  p->ip.check = 0;
-  p->ip.saddr = a->m_dhcp_server_ip;
-
-  if (broadcast)
-    p->ip.daddr = ~0;
-  else
-    p->ip.daddr = a->m_dhcp_addr;
-
-  // Build UDP header
-
-  p->udp.source = htons (BOOTPS_PORT);
-  p->udp.dest = htons (BOOTPC_PORT);
-  p->udp.len = htons (sizeof (UDPHDR) + sizeof (DHCP) + optlen);
-  p->udp.check = 0;
-
-  // Build DHCP response
-
-  p->dhcp.op = BOOTREPLY;
-  p->dhcp.htype = 1;
-  p->dhcp.hlen = sizeof (MACADDR);
-  p->dhcp.hops = 0;
-  p->dhcp.xid = dhcp->xid;
-  p->dhcp.secs = 0;
-  p->dhcp.flags = 0;
-  p->dhcp.ciaddr = 0;
-
-  if (type == DHCPNAK)
-    p->dhcp.yiaddr = 0;
-  else
-    p->dhcp.yiaddr = a->m_dhcp_addr;
-
-  p->dhcp.siaddr = a->m_dhcp_server_ip;
-  p->dhcp.giaddr = 0;
-  COPY_MAC (p->dhcp.chaddr, eth->src);
-  p->dhcp.magic = htonl (0x63825363);
-}
-//=============================
-// Build specific DHCP messages
-//=============================
-
-VOID
-SendDHCPMsg (const TapAdapterPointer a,
-	     const int type,
-	     const ETH_HEADER *eth,
-	     const IPHDR *ip,
-	     const UDPHDR *udp,
-	     const DHCP *dhcp)
-{
-  DHCPMsg *pkt;
-
-  if (!(type == DHCPOFFER || type == DHCPACK || type == DHCPNAK))
-    {
-      DEBUGP (("[TAP] SendDHCPMsg: Bad DHCP type: %d\n", type));
-      return;
-    }
-
-  pkt = (DHCPMsg *) MemAlloc (sizeof (DHCPMsg), TRUE);
-
-  if (pkt)
-    {
-      //-----------------------
-      // Build DHCP options
-      //-----------------------
-
-      // Message Type
-      SetDHCPOpt8 (pkt, DHCP_MSG_TYPE, type);
-
-      // Server ID
-      SetDHCPOpt32 (pkt, DHCP_SERVER_ID, a->m_dhcp_server_ip);
-
-      if (type == DHCPOFFER || type == DHCPACK)
-	{
-	  // Lease Time
-	  SetDHCPOpt32 (pkt, DHCP_LEASE_TIME, htonl (a->m_dhcp_lease_time));
-
-	  // Netmask
-	  SetDHCPOpt32 (pkt, DHCP_NETMASK, a->m_dhcp_netmask);
-
-	  // Other user-defined options
-	  SetDHCPOpt (pkt,
-		      a->m_dhcp_user_supplied_options_buffer,
-		      a->m_dhcp_user_supplied_options_buffer_len);
-	}
-
-      // End
-      SetDHCPOpt0 (pkt, DHCP_END);
-
-      if (!DHCPMSG_OVERFLOW (pkt))
-	{
-	  // The initial part of the DHCP message (not including options) gets built here
-	  BuildDHCPPre (a,
-			&pkt->msg.pre,
-			eth,
-			ip,
-			udp,
-			dhcp,
-			DHCPMSG_LEN_OPT (pkt),
-			type);
-
-	  SetChecksumDHCPMsg (pkt);
-
-	  DUMP_PACKET ("DHCPMsg",
-		       DHCPMSG_BUF (pkt),
-		       DHCPMSG_LEN_FULL (pkt));
-
-	  // Return DHCP response to kernel
-	  InjectPacketDeferred (a,
-				DHCPMSG_BUF (pkt),
-				DHCPMSG_LEN_FULL (pkt));
-	}
-      else
-	{
-	  DEBUGP (("[TAP] SendDHCPMsg: DHCP buffer overflow\n"));
-	}
-
-      MemFree (pkt, sizeof (DHCPMsg));
-    }
-}
-
-//===================================================================
-// Handle a BOOTPS packet produced by the local system to
-// resolve the address/netmask of this adapter.
-// If we are in TAP_IOCTL_CONFIG_DHCP_MASQ mode, reply
-// to the message.  Return TRUE if we processed the passed
-// message, so that downstream stages can ignore it.
-//===================================================================
-
-BOOLEAN
-ProcessDHCP (TapAdapterPointer p_Adapter,
-	     const ETH_HEADER *eth,
-	     const IPHDR *ip,
-	     const UDPHDR *udp,
-	     const DHCP *dhcp,
-	     int optlen)
-{
-  int msg_type;
-
-  // Sanity check IP header
-  if (!(ntohs (ip->tot_len) == sizeof (IPHDR) + sizeof (UDPHDR) + sizeof (DHCP) + optlen
-	&& (ntohs (ip->frag_off) & IP_OFFMASK) == 0))
-    return TRUE;
-
-  // Does this message belong to us?
-  if (!DHCPMessageOurs (p_Adapter, eth, ip, udp, dhcp))
-    return FALSE;
-
-  msg_type = GetDHCPMessageType (dhcp, optlen);
-
-  // Drop non-BOOTREQUEST messages
-  if (dhcp->op != BOOTREQUEST)
-    return TRUE;
-
-  // Drop any messages except DHCPDISCOVER or DHCPREQUEST
-  if (!(msg_type == DHCPDISCOVER || msg_type == DHCPREQUEST))
-    return TRUE;
-
-  // Should we reply with DHCPOFFER, DHCPACK, or DHCPNAK?
-  if (msg_type == DHCPREQUEST
-      && ((dhcp->ciaddr && dhcp->ciaddr != p_Adapter->m_dhcp_addr)
-	  || !p_Adapter->m_dhcp_received_discover
-	  || p_Adapter->m_dhcp_bad_requests >= BAD_DHCPREQUEST_NAK_THRESHOLD))
-    SendDHCPMsg (p_Adapter,
-		 DHCPNAK,
-		 eth, ip, udp, dhcp);
-  else
-    SendDHCPMsg (p_Adapter,
-		 (msg_type == DHCPDISCOVER ? DHCPOFFER : DHCPACK),
-		 eth, ip, udp, dhcp);
-
-  // Remember if we received a DHCPDISCOVER
-  if (msg_type == DHCPDISCOVER)
-    p_Adapter->m_dhcp_received_discover = TRUE;
-
-  // Is this a bad DHCPREQUEST?
-  if (msg_type == DHCPREQUEST && dhcp->ciaddr != p_Adapter->m_dhcp_addr)
-    ++p_Adapter->m_dhcp_bad_requests;
-
-  return TRUE;
-}
-
-#if DBG
-
-const char *
-message_op_text (int op)
-{
-  switch (op)
-    {
-    case BOOTREQUEST:
-      return "BOOTREQUEST";
-    case BOOTREPLY:
-      return "BOOTREPLY";
-    default:
-      return "???";
-    }
-}
-
-const char *
-message_type_text (int type)
-{
-  switch (type)
-    {
-    case DHCPDISCOVER:
-      return "DHCPDISCOVER";
-    case DHCPOFFER:
-      return "DHCPOFFER";
-    case DHCPREQUEST:
-      return "DHCPREQUEST";
-    case DHCPDECLINE:
-      return "DHCPDECLINE";
-    case DHCPACK:
-      return "DHCPACK";
-    case DHCPNAK:
-      return "DHCPNAK";
-    case DHCPRELEASE:
-      return "DHCPRELEASE";
-    case DHCPINFORM:
-      return "DHCPINFORM";
-    default:
-      return "???";
-    }
-}
-
-const char *
-port_name (int port)
-{
-  switch (port)
-    {
-    case BOOTPS_PORT:
-      return "BOOTPS";
-    case BOOTPC_PORT:
-      return "BOOTPC";
-    default:
-      return "unknown";
-    }
-}
-
-VOID
-DumpDHCP (const ETH_HEADER *eth,
-	  const IPHDR *ip,
-	  const UDPHDR *udp,
-	  const DHCP *dhcp,
-	  const int optlen)
-{
-  DEBUGP ((" %s", message_op_text (dhcp->op)));
-  DEBUGP ((" %s ", message_type_text (GetDHCPMessageType (dhcp, optlen))));
-  PrIP (ip->saddr);
-  DEBUGP ((":%s[", port_name (ntohs (udp->source))));
-  PrMac (eth->src);
-  DEBUGP (("] -> "));
-  PrIP (ip->daddr);
-  DEBUGP ((":%s[", port_name (ntohs (udp->dest))));
-  PrMac (eth->dest);
-  DEBUGP (("]"));
-  if (dhcp->ciaddr)
-    {
-      DEBUGP ((" ci="));
-      PrIP (dhcp->ciaddr);
-    }
-  if (dhcp->yiaddr)
-    {
-      DEBUGP ((" yi="));
-      PrIP (dhcp->yiaddr);
-    }
-  if (dhcp->siaddr)
-    {
-      DEBUGP ((" si="));
-      PrIP (dhcp->siaddr);
-    }
-  if (dhcp->hlen == sizeof (MACADDR))
-    {
-      DEBUGP ((" ch="));
-      PrMac (dhcp->chaddr);
-    }
-
-  DEBUGP ((" xid=0x%08x", ntohl (dhcp->xid)));
-
-  if (ntohl (dhcp->magic) != 0x63825363)
-    DEBUGP ((" ma=0x%08x", ntohl (dhcp->magic)));
-  if (dhcp->htype != 1)
-    DEBUGP ((" htype=%d", dhcp->htype));
-  if (dhcp->hops)
-    DEBUGP ((" hops=%d", dhcp->hops));
-  if (ntohs (dhcp->secs))
-    DEBUGP ((" secs=%d", ntohs (dhcp->secs)));
-  if (ntohs (dhcp->flags))
-    DEBUGP ((" flags=0x%04x", ntohs (dhcp->flags)));
-
-  // extra stuff
-  
-  if (ip->version_len != 0x45)
-    DEBUGP ((" vl=0x%02x", ip->version_len));
-  if (ntohs (ip->tot_len) != sizeof (IPHDR) + sizeof (UDPHDR) + sizeof (DHCP) + optlen)
-    DEBUGP ((" tl=%d", ntohs (ip->tot_len)));
-  if (ntohs (udp->len) != sizeof (UDPHDR) + sizeof (DHCP) + optlen)
-    DEBUGP ((" ul=%d", ntohs (udp->len)));
-
-  if (ip->tos)
-    DEBUGP ((" tos=0x%02x", ip->tos));
-  if (ntohs (ip->id))
-    DEBUGP ((" id=0x%04x", ntohs (ip->id)));
-  if (ntohs (ip->frag_off))
-    DEBUGP ((" frag_off=0x%04x", ntohs (ip->frag_off)));
-  
-  DEBUGP ((" ttl=%d", ip->ttl));
-  DEBUGP ((" ic=0x%04x [0x%04x]", ntohs (ip->check),
-	    ip_checksum ((UCHAR*)ip, sizeof (IPHDR))));
-  DEBUGP ((" uc=0x%04x [0x%04x/%d]", ntohs (udp->check),
-	    udp_checksum ((UCHAR *) udp,
-			  sizeof (UDPHDR) + sizeof (DHCP) + optlen,
-			  (UCHAR *) &ip->saddr,
-			  (UCHAR *) &ip->daddr),
-	    optlen));
-
-  // Options
-  {
-    const UCHAR *opt = (UCHAR *) (dhcp + 1);
-    int i;
-
-    DEBUGP ((" OPT"));
-    for (i = 0; i < optlen; ++i)
-      {
-	const UCHAR data = opt[i];
-	DEBUGP ((".%d", data));
-      }
-  }
-}
-
-#endif /* DBG */
diff -urN openvpn-2.1.1/tap-win32/tmp/dhcp.h openvpn-2.1.3/tap-win32/tmp/dhcp.h
--- openvpn-2.1.1/tap-win32/tmp/dhcp.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/dhcp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,168 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#pragma pack(1)
-
-//===================================================
-// How many bad DHCPREQUESTs do we receive before we
-// return a NAK?
-//
-// A bad DHCPREQUEST is defined to be one where the
-// requestor doesn't know its IP address.
-//===================================================
-
-#define BAD_DHCPREQUEST_NAK_THRESHOLD 3
-
-//==============================================
-// Maximum number of DHCP options bytes supplied
-//==============================================
-
-#define DHCP_USER_SUPPLIED_OPTIONS_BUFFER_SIZE 256
-#define DHCP_OPTIONS_BUFFER_SIZE               256
-
-//===================================
-// UDP port numbers of DHCP messages.
-//===================================
-
-#define BOOTPS_PORT 67
-#define BOOTPC_PORT 68
-
-//===========================
-// The DHCP message structure
-//===========================
-
-typedef struct {
-# define BOOTREQUEST 1
-# define BOOTREPLY   2
-  UCHAR op;          /* message op */
-
-  UCHAR  htype;      /* hardware address type (e.g. '1' = 10Mb Ethernet) */
-  UCHAR  hlen;       /* hardware address length (e.g. '6' for 10Mb Ethernet) */
-  UCHAR  hops;       /* client sets to 0, may be used by relay agents */
-  ULONG  xid;        /* transaction ID, chosen by client */
-  USHORT secs;       /* seconds since request process began, set by client */
-  USHORT flags;
-  ULONG  ciaddr;     /* client IP address, client sets if known */
-  ULONG  yiaddr;     /* 'your' IP address -- server's response to client */
-  ULONG  siaddr;     /* server IP address */
-  ULONG  giaddr;     /* relay agent IP address */
-  UCHAR  chaddr[16]; /* client hardware address */
-  UCHAR  sname[64];  /* optional server host name */
-  UCHAR  file[128];  /* boot file name */
-  ULONG  magic;      /* must be 0x63825363 (network order) */
-} DHCP;
-
-typedef struct {
-  ETH_HEADER eth;
-  IPHDR ip;
-  UDPHDR udp;
-  DHCP dhcp;
-} DHCPPre;
-
-typedef struct {
-  DHCPPre pre;
-  UCHAR options[DHCP_OPTIONS_BUFFER_SIZE];
-} DHCPFull;
-
-typedef struct {
-  unsigned int optlen;
-  BOOLEAN overflow;
-  DHCPFull msg;
-} DHCPMsg;
-
-//===================
-// Macros for DHCPMSG
-//===================
-
-#define DHCPMSG_LEN_BASE(p) (sizeof (DHCPPre))
-#define DHCPMSG_LEN_OPT(p)  ((p)->optlen)
-#define DHCPMSG_LEN_FULL(p) (DHCPMSG_LEN_BASE(p) + DHCPMSG_LEN_OPT(p))
-#define DHCPMSG_BUF(p)      ((UCHAR*) &(p)->msg)
-#define DHCPMSG_OVERFLOW(p) ((p)->overflow)
-
-//========================================
-// structs to hold individual DHCP options
-//========================================
-
-typedef struct {
-  UCHAR type;
-} DHCPOPT0;
-
-typedef struct {
-  UCHAR type;
-  UCHAR len;
-  UCHAR data;
-} DHCPOPT8;
-
-typedef struct {
-  UCHAR type;
-  UCHAR len;
-  ULONG data;
-} DHCPOPT32;
-
-#pragma pack()
-
-//==================
-// DHCP Option types
-//==================
-
-#define DHCP_MSG_TYPE    53  /* message type (u8) */
-#define DHCP_PARM_REQ    55  /* parameter request list: c1 (u8), ... */
-#define DHCP_CLIENT_ID   61  /* client ID: type (u8), i1 (u8), ... */
-#define DHCP_IP          50  /* requested IP addr (u32) */
-#define DHCP_NETMASK      1  /* subnet mask (u32) */
-#define DHCP_LEASE_TIME  51  /* lease time sec (u32) */
-#define DHCP_RENEW_TIME  58  /* renewal time sec (u32) */
-#define DHCP_REBIND_TIME 59  /* rebind time sec (u32) */
-#define DHCP_SERVER_ID   54  /* server ID: IP addr (u32) */
-#define DHCP_PAD          0
-#define DHCP_END        255
-
-//====================
-// DHCP Messages types
-//====================
-
-#define DHCPDISCOVER 1
-#define DHCPOFFER    2
-#define DHCPREQUEST  3
-#define DHCPDECLINE  4
-#define DHCPACK      5
-#define DHCPNAK      6
-#define DHCPRELEASE  7
-#define DHCPINFORM   8
-
-#if DBG
-
-VOID
-DumpDHCP (const ETH_HEADER *eth,
-	  const IPHDR *ip,
-	  const UDPHDR *udp,
-	  const DHCP *dhcp,
-	  const int optlen);
-
-#endif
diff -urN openvpn-2.1.1/tap-win32/tmp/endian.h openvpn-2.1.3/tap-win32/tmp/endian.h
--- openvpn-2.1.1/tap-win32/tmp/endian.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/endian.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifdef TAP_LITTLE_ENDIAN
-#define ntohs(x) RtlUshortByteSwap(x)
-#define htons(x) RtlUshortByteSwap(x)
-#define ntohl(x) RtlUlongByteSwap(x)
-#define htonl(x) RtlUlongByteSwap(x)
-#else
-#define ntohs(x) ((USHORT)(x))
-#define htons(x) ((USHORT)(x))
-#define ntohl(x) ((ULONG)(x))
-#define htonl(x) ((ULONG)(x))
-#endif
diff -urN openvpn-2.1.1/tap-win32/tmp/error.c openvpn-2.1.3/tap-win32/tmp/error.c
--- openvpn-2.1.1/tap-win32/tmp/error.c	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/error.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,382 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-//-----------------
-// DEBUGGING OUTPUT
-//-----------------
-
-const char *g_LastErrorFilename;
-int g_LastErrorLineNumber;
-
-#if DBG
-
-DebugOutput g_Debug;
-
-BOOLEAN
-NewlineExists (const char *str, int len)
-{
-  while (len-- > 0)
-    {
-      const char c = *str++;
-      if (c == '\n')
-	return TRUE;
-      else if (c == '\0')
-	break;
-    }
-  return FALSE;
-}
-
-VOID
-MyDebugInit (unsigned int bufsiz)
-{
-  NdisZeroMemory (&g_Debug, sizeof (g_Debug));
-  g_Debug.text = (char *) MemAlloc (bufsiz, FALSE);
-  if (g_Debug.text)
-    g_Debug.capacity = bufsiz;
-}
-
-VOID
-MyDebugFree ()
-{
-  if (g_Debug.text)
-    MemFree (g_Debug.text, g_Debug.capacity);
-  NdisZeroMemory (&g_Debug, sizeof (g_Debug));
-}
-
-VOID
-MyDebugPrint (const unsigned char* format, ...)
-{
-  if (g_Debug.text && g_Debug.capacity > 0 && CAN_WE_PRINT)
-    {
-      BOOLEAN owned;
-      ACQUIRE_MUTEX_ADAPTIVE (&g_Debug.lock, owned);
-      if (owned)
-	{
-	  const int remaining = (int)g_Debug.capacity - (int)g_Debug.out;
-
-	  if (remaining > 0)
-	    {
-	      va_list args;
-	      NTSTATUS status;
-	      char *end;
-
-	      va_start (args, format);
-	      status = RtlStringCchVPrintfExA (g_Debug.text + g_Debug.out,
-					       remaining,
-					       &end,
-					       NULL,
-					       STRSAFE_NO_TRUNCATION | STRSAFE_IGNORE_NULLS,
-					       format,
-					       args);
-	      va_end (args);
-
-	      if (status == STATUS_SUCCESS)
-		g_Debug.out = (unsigned int) (end - g_Debug.text);
-	      else
-		g_Debug.error = TRUE;
-	    }
-	  else
-	    g_Debug.error = TRUE;
-
-	  RELEASE_MUTEX (&g_Debug.lock);
-	}
-      else
-	g_Debug.error = TRUE;
-    }
-}
-
-BOOLEAN
-GetDebugLine (char *buf, const int len)
-{
-  static const char *truncated = "[OUTPUT TRUNCATED]\n";
-  BOOLEAN ret = FALSE;
-
-  NdisZeroMemory (buf, len);
-
-  if (g_Debug.text && g_Debug.capacity > 0)
-    {
-      BOOLEAN owned;
-      ACQUIRE_MUTEX_ADAPTIVE (&g_Debug.lock, owned);
-      if (owned)
-	{
-	  int i = 0;
-
-	  if (g_Debug.error || NewlineExists (g_Debug.text + g_Debug.in, (int)g_Debug.out - (int)g_Debug.in))
-	    {
-	      while (i < (len - 1) && g_Debug.in < g_Debug.out)
-		{
-		  const char c = g_Debug.text[g_Debug.in++];
-		  if (c == '\n')
-		    break;
-		  buf[i++] = c;
-		}
-	      if (i < len)
-		buf[i] = '\0';
-	    }
-
-	  if (!i)
-	    {
-	      if (g_Debug.in == g_Debug.out)
-		{
-		  g_Debug.in = g_Debug.out = 0;
-		  if (g_Debug.error)
-		    {
-		      const unsigned int tlen = strlen (truncated);
-		      if (tlen < g_Debug.capacity)
-			{
-			  NdisMoveMemory (g_Debug.text, truncated, tlen+1);
-			  g_Debug.out = tlen;
-			}
-		      g_Debug.error = FALSE;
-		    }
-		}
-	    }
-	  else
-	    ret = TRUE;
-
-	  RELEASE_MUTEX (&g_Debug.lock);
-	}      
-    }
-  return ret;
-}
-
-VOID
-MyAssert (const unsigned char *file, int line)
-{
-      DEBUGP (("MYASSERT failed %s/%d\n", file, line));
-      KeBugCheckEx (0x0F00BABA,
-		    (ULONG_PTR) line,
-		    (ULONG_PTR) 0,
-		    (ULONG_PTR) 0,
-		    (ULONG_PTR) 0);
-}
-
-VOID
-PrMac (const MACADDR mac)
-{
-  DEBUGP (("%x:%x:%x:%x:%x:%x",
-	    mac[0], mac[1], mac[2],
-	    mac[3], mac[4], mac[5]));
-}
-
-VOID
-PrIP (IPADDR ip_addr)
-{
-  const unsigned char *ip = (const unsigned char *) &ip_addr;
-
-  DEBUGP (("%d.%d.%d.%d",
-	    ip[0], ip[1], ip[2], ip[3]));
-}
-
-const char *
-PrIPProto (int proto)
-{
-  switch (proto)
-    {
-    case IPPROTO_UDP:
-      return "UDP";
-    case IPPROTO_TCP:
-      return "TCP";
-    case IPPROTO_ICMP:
-      return "ICMP";
-    case IPPROTO_IGMP:
-      return "IGMP";
-    default:
-      return "???";
-    }
-}
-
-VOID
-DumpARP (const char *prefix, const ARP_PACKET *arp)
-{
-  DEBUGP (("%s ARP src=", prefix));
-  PrMac (arp->m_MAC_Source);
-  DEBUGP ((" dest="));
-  PrMac (arp->m_MAC_Destination);
-  DEBUGP ((" OP=0x%04x",
-	    (int)ntohs(arp->m_ARP_Operation)));
-  DEBUGP ((" M=0x%04x(%d)",
-	    (int)ntohs(arp->m_MAC_AddressType),
-	    (int)arp->m_MAC_AddressSize));
-  DEBUGP ((" P=0x%04x(%d)",
-	    (int)ntohs(arp->m_PROTO_AddressType),
-	    (int)arp->m_PROTO_AddressSize));
-
-  DEBUGP ((" MacSrc="));
-  PrMac (arp->m_ARP_MAC_Source);
-  DEBUGP ((" MacDest="));
-  PrMac (arp->m_ARP_MAC_Destination);
-
-  DEBUGP ((" IPSrc="));
-  PrIP (arp->m_ARP_IP_Source);
-  DEBUGP ((" IPDest="));
-  PrIP (arp->m_ARP_IP_Destination);
-
-  DEBUGP (("\n"));
-}
-
-struct ethpayload {
-  ETH_HEADER eth;
-  UCHAR payload[DEFAULT_PACKET_LOOKAHEAD];
-};
-
-VOID
-DumpPacket2 (const char *prefix,
-	     const ETH_HEADER *eth,
-	     const unsigned char *data,
-	     unsigned int len)
-{
-  struct ethpayload *ep = (struct ethpayload *) MemAlloc (sizeof (struct ethpayload), TRUE);
-  if (ep)
-    {
-      if (len > DEFAULT_PACKET_LOOKAHEAD)
-	len = DEFAULT_PACKET_LOOKAHEAD;
-      ep->eth = *eth;
-      NdisMoveMemory (ep->payload, data, len);
-      DumpPacket (prefix, (unsigned char *) ep, sizeof (ETH_HEADER) + len);
-      MemFree (ep, sizeof (struct ethpayload));
-    }
-}
-
-VOID
-DumpPacket (const char *prefix,
-	    const unsigned char *data,
-	    unsigned int len)
-{
-  const ETH_HEADER *eth = (const ETH_HEADER *) data;
-  const IPHDR *ip = (const IPHDR *) (data + sizeof (ETH_HEADER));
-
-  if (len < sizeof (ETH_HEADER))
-    {
-      DEBUGP (("%s TRUNCATED PACKET LEN=%d\n", prefix, len));
-      return;
-    }
-
-  // ARP Packet?
-  if (len >= sizeof (ARP_PACKET) && eth->proto == htons (ETH_P_ARP))
-    {
-      DumpARP (prefix, (const ARP_PACKET *) data);
-      return;
-    }
-
-  // IPv4 packet?
-  if (len >= (sizeof (IPHDR) + sizeof (ETH_HEADER))
-      && eth->proto == htons (ETH_P_IP)
-      && IPH_GET_VER (ip->version_len) == 4)
-    {
-      const int hlen = IPH_GET_LEN (ip->version_len);
-      const int blen = len - sizeof (ETH_HEADER);
-      BOOLEAN did = FALSE;
-
-      DEBUGP (("%s IPv4 %s[%d]", prefix, PrIPProto (ip->protocol), len));
-
-      if (!(ntohs (ip->tot_len) == blen && hlen <= blen))
-	{
-	  DEBUGP ((" XXX"));
-	  return;
-	}
-      
-      // TCP packet?
-      if (ip->protocol == IPPROTO_TCP
-	  && blen - hlen >= (sizeof (TCPHDR)))
-	{
-	  const TCPHDR *tcp = (TCPHDR *) (data + sizeof (ETH_HEADER) + hlen);
-	  DEBUGP ((" "));
-	  PrIP (ip->saddr);
-	  DEBUGP ((":%d", ntohs (tcp->source)));
-	  DEBUGP ((" -> "));
-	  PrIP (ip->daddr);
-	  DEBUGP ((":%d", ntohs (tcp->dest)));
-	  did = TRUE;
-	}
-
-      // UDP packet?
-      else if ((ntohs (ip->frag_off) & IP_OFFMASK) == 0
-	       && ip->protocol == IPPROTO_UDP
-	       && blen - hlen >= (sizeof (UDPHDR)))
-	{
-	  const UDPHDR *udp = (UDPHDR *) (data + sizeof (ETH_HEADER) + hlen);
-	  
-	  // DHCP packet?
-	  if ((udp->dest == htons (BOOTPC_PORT) || udp->dest == htons (BOOTPS_PORT))
-	      && blen - hlen >= (sizeof (UDPHDR) + sizeof (DHCP)))
-	    {
-	      const DHCP *dhcp = (DHCP *) (data
-					   + hlen
-					   + sizeof (ETH_HEADER)
-					   + sizeof (UDPHDR));
-	      
-	      int optlen = len
-		- sizeof (ETH_HEADER)
-		- hlen
-		- sizeof (UDPHDR)
-		- sizeof (DHCP);
-
-	      if (optlen < 0)
-		optlen = 0;
-
-	      DumpDHCP (eth, ip, udp, dhcp, optlen);
-	      did = TRUE;
-	    }
-
-	  if (!did)
-	    {
-	      DEBUGP ((" "));
-	      PrIP (ip->saddr);
-	      DEBUGP ((":%d", ntohs (udp->source)));
-	      DEBUGP ((" -> "));
-	      PrIP (ip->daddr);
-	      DEBUGP ((":%d", ntohs (udp->dest)));
-	      did = TRUE;
-	    }
-	}
-
-      if (!did)
-	{
-	  DEBUGP ((" ipproto=%d ", ip->protocol));
-	  PrIP (ip->saddr);
-	  DEBUGP ((" -> "));
-	  PrIP (ip->daddr);
-	}
-
-      DEBUGP (("\n"));
-      return;
-    }
-
-  {
-    DEBUGP (("%s ??? src=", prefix));
-    PrMac (eth->src);
-    DEBUGP ((" dest="));
-    PrMac (eth->dest);
-    DEBUGP ((" proto=0x%04x len=%d\n",
-	      (int) ntohs(eth->proto),
-	      len));
-  }
-}
-
-#endif
diff -urN openvpn-2.1.1/tap-win32/tmp/error.h openvpn-2.1.3/tap-win32/tmp/error.h
--- openvpn-2.1.1/tap-win32/tmp/error.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/error.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,92 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-//-----------------
-// DEBUGGING OUTPUT
-//-----------------
-
-#define NOTE_ERROR() \
-{ \
-  g_LastErrorFilename = __FILE__; \
-  g_LastErrorLineNumber = __LINE__; \
-}
-
-#if DBG
-
-typedef struct {
-  unsigned int in;
-  unsigned int out;
-  unsigned int capacity;
-  char *text;
-  BOOLEAN error;
-  MUTEX lock;
-} DebugOutput;
-
-VOID MyDebugPrint (const unsigned char* format, ...);
-
-VOID MyAssert (const unsigned char *file, int line);
-
-VOID DumpPacket (const char *prefix,
-		 const unsigned char *data,
-		 unsigned int len);
-
-VOID DumpPacket2 (const char *prefix,
-		  const ETH_HEADER *eth,
-		  const unsigned char *data,
-		  unsigned int len);
-
-#define CAN_WE_PRINT (DEBUGP_AT_DISPATCH || KeGetCurrentIrql () < DISPATCH_LEVEL)
-
-#if ALSO_DBGPRINT
-#define DEBUGP(fmt) { MyDebugPrint fmt; if (CAN_WE_PRINT) DbgPrint fmt; }
-#else
-#define DEBUGP(fmt) { MyDebugPrint fmt; }
-#endif
-
-#define MYASSERT(exp) \
-{ \
-  if (!(exp)) \
-    { \
-      MyAssert(__FILE__, __LINE__); \
-    } \
-}
-
-#define DUMP_PACKET(prefix, data, len) \
-  DumpPacket (prefix, data, len)
-
-#define DUMP_PACKET2(prefix, eth, data, len) \
-  DumpPacket2 (prefix, eth, data, len)
-
-#else 
-
-#define DEBUGP(fmt)
-#define MYASSERT(exp)
-#define DUMP_PACKET(prefix, data, len)
-#define DUMP_PACKET2(prefix, eth, data, len)
-
-#endif
diff -urN openvpn-2.1.1/tap-win32/tmp/hexdump.c openvpn-2.1.3/tap-win32/tmp/hexdump.c
--- openvpn-2.1.1/tap-win32/tmp/hexdump.c	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/hexdump.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "hexdump.h"
-
-#ifndef NDIS_MINIPORT_DRIVER
-
-VOID (*DbgMessage)(char *p_Format, ...) = DisplayDebugString;
-
-VOID DisplayDebugString (char *p_Format, ...)
-   {
-    static char l_Buffer [4096];
-
-    va_list l_ArgumentList; 
-    va_start (l_ArgumentList, p_Format); 
-    vsprintf (l_Buffer, p_Format, l_ArgumentList); 
-    va_end (l_ArgumentList); 
-
-    OutputDebugStringA (l_Buffer);
-   }
-
-#endif
-
-VOID HexDump (unsigned char *p_Buffer, unsigned long p_Size)
-   {
-    unsigned long l_Index, l_Idx;
-    unsigned char l_Row [17];
-
-    for (l_Index = l_Row [16] = 0; l_Index < p_Size || l_Index % 16; ++l_Index)
-       {
-        if (l_Index % 16 == 0)
-	  DEBUGP (("%05x   ", l_Index));
-        DEBUGP (("%02x ", l_Row [l_Index % 16] = (l_Index < p_Size ? p_Buffer [l_Index] : 0)));
-        l_Row [l_Index % 16] = IfPrint (l_Row [l_Index % 16]);
-        if ((l_Index + 1) % 16 == 0)
-	  DEBUGP (("   %s\n", l_Row));
-       }
-
-    DEBUGP (("\n"));
-   }
-
-#ifdef __cplusplus
-}
-#endif
diff -urN openvpn-2.1.1/tap-win32/tmp/hexdump.h openvpn-2.1.3/tap-win32/tmp/hexdump.h
--- openvpn-2.1.1/tap-win32/tmp/hexdump.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/hexdump.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef HEXDUMP_DEFINED
-#define HEXDUMP_DEFINED
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-//=====================================================================================
-//                                   Debug Routines
-//=====================================================================================
-
-#ifndef NDIS_MINIPORT_DRIVER
-#   include <stdio.h>
-#   include <ctype.h>
-#   include <windows.h>
-#   include <winnt.h>
-#   include <memory.h>
-
-#   ifndef DEBUGP
-#      define DEBUGP(fmt) { DbgMessage fmt; }
-#   endif
-
-    extern VOID (*DbgMessage)(char *p_Format, ...);
-
-    VOID DisplayDebugString (char *p_Format, ...);
-#endif
-
-//===================================================================================
-//                              Reporting / Debugging
-//===================================================================================
-#define IfPrint(c) (c >= 32 && c < 127 ? c : '.')
-
-VOID HexDump (unsigned char *p_Buffer, unsigned long p_Size);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -urN openvpn-2.1.1/tap-win32/tmp/instance.c openvpn-2.1.3/tap-win32/tmp/instance.c
--- openvpn-2.1.1/tap-win32/tmp/instance.c	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/instance.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,245 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#define INSTANCE_KEY(a) ((PVOID)((a)->m_Extension.m_TapDevice))
-
-#define N_INSTANCE_BUCKETS 256
-
-typedef struct _INSTANCE {
-  struct _INSTANCE *next;
-  TapAdapterPointer m_Adapter;
-} INSTANCE;
-
-typedef struct {
-  INSTANCE *list;
-  MUTEX lock;
-} INSTANCE_BUCKET;
-
-typedef struct {
-  INSTANCE_BUCKET buckets[N_INSTANCE_BUCKETS];
-} INSTANCE_HASH;
-
-INSTANCE_HASH *g_InstanceHash = NULL;
-
-// must return a hash >= 0 and < N_INSTANCE_BUCKETS
-int
-InstanceHashValue (PVOID addr)
-{
-  UCHAR *p = (UCHAR *) &addr;
-
-  if (sizeof (addr) == 4)
-    return p[0] ^ p[1] ^ p[2] ^ p[3];
-  else if (sizeof (addr) == 8)
-    return p[0] ^ p[1] ^ p[2] ^ p[3] ^ p[4] ^ p[5] ^ p[6] ^ p[7];
-  else
-    {
-      MYASSERT (0);
-    }
-}
-
-BOOLEAN
-InitInstanceList (VOID)
-{
-  MYASSERT (g_InstanceHash == NULL);
-  g_InstanceHash = MemAlloc (sizeof (INSTANCE_HASH), TRUE);
-  if (g_InstanceHash)
-    {
-      int i;
-      for (i = 0; i < N_INSTANCE_BUCKETS; ++i)
-	INIT_MUTEX (&g_InstanceHash->buckets[i].lock);
-      return TRUE;
-    }
-  else
-    return FALSE;
-}
-
-int
-NInstances (VOID)
-{
-  int i, n = 0;
-
-  if (g_InstanceHash)
-    {
-      for (i = 0; i < N_INSTANCE_BUCKETS; ++i)
-	{
-	  BOOLEAN got_lock;
-	  INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[i];
-	  ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);
-
-	  if (got_lock)
-	    {
-	      INSTANCE *current;
-	      for (current = ib->list; current != NULL; current = current->next)
-		++n;
-	      RELEASE_MUTEX (&ib->lock);
-	    }
-	  else
-	    return -1;
-	}
-    }
-
-  return n;
-}
-
-int
-InstanceMaxBucketSize (VOID)
-{
-  int i, n = 0;
-
-  if (g_InstanceHash)
-    {
-      for (i = 0; i < N_INSTANCE_BUCKETS; ++i)
-	{
-	  BOOLEAN got_lock;
-	  int bucket_size = 0;
-	  INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[i];
-	  ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);
-
-	  if (got_lock)
-	    {
-	      INSTANCE *current;
-	      for (current = ib->list; current != NULL; current = current->next)
-		  ++bucket_size;
-	      if (bucket_size > n)
-		n = bucket_size;
-	      RELEASE_MUTEX (&ib->lock);
-	    }
-	  else
-	    return -1;
-	}
-    }
-
-  return n;
-}
-
-VOID
-FreeInstanceList (VOID)
-{
-  if (g_InstanceHash)
-    {
-      MYASSERT (NInstances() == 0);
-      MemFree (g_InstanceHash, sizeof (INSTANCE_HASH));
-      g_InstanceHash = NULL;
-    }
-}
-
-BOOLEAN
-AddAdapterToInstanceList (TapAdapterPointer p_Adapter)
-{
-  BOOLEAN got_lock;
-  BOOLEAN ret = FALSE;
-  const int hash = InstanceHashValue(INSTANCE_KEY(p_Adapter));
-  INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[hash];
-
-  DEBUGP (("[TAP] AddAdapterToInstanceList hash=%d\n", hash));
-
-  ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);
-
-  if (got_lock)
-    {
-      INSTANCE *i = MemAlloc (sizeof (INSTANCE), FALSE);
-      if (i)
-	{
-	  MYASSERT (p_Adapter);
-	  i->m_Adapter = p_Adapter;
-	  i->next = ib->list;
-	  ib->list = i;
-	  ret = TRUE;
-	}
-      RELEASE_MUTEX (&ib->lock);
-    }
-
-  return ret;
-}
-
-BOOLEAN
-RemoveAdapterFromInstanceList (TapAdapterPointer p_Adapter)
-{
-  BOOLEAN got_lock;
-  BOOLEAN ret = FALSE;
-  INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[InstanceHashValue(INSTANCE_KEY(p_Adapter))];
-
-  ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);
-
-  if (got_lock)
-    {
-      INSTANCE *current, *prev=NULL;
-      for (current = ib->list; current != NULL; current = current->next)
-	{
-	  if (current->m_Adapter == p_Adapter) // found match
-	    {
-	      if (prev)
-		prev->next = current->next;
-	      else
-		ib->list = current->next;
-	      MemFree (current->m_Adapter, sizeof (TapAdapter));
-	      MemFree (current, sizeof (INSTANCE));
-	      ret = TRUE;
-	      break;
-	    }
-	  prev = current;
-	}
-      RELEASE_MUTEX (&ib->lock);
-    }
-
-  return ret;
-}
-
-TapAdapterPointer
-LookupAdapterInInstanceList (PDEVICE_OBJECT p_DeviceObject)
-{
-  BOOLEAN got_lock;
-  TapAdapterPointer ret = NULL;
-  INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[InstanceHashValue((PVOID)p_DeviceObject)];
-
-  ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);
-
-  if (got_lock)
-    {
-      INSTANCE *current, *prev=NULL;
-      for (current = ib->list; current != NULL; current = current->next)
-	{
-	  if (p_DeviceObject == INSTANCE_KEY (current->m_Adapter)) // found match
-	    {
-	      // move it to head of list
-	      if (prev)
-		{
-		  prev->next = current->next;
-		  current->next = ib->list;
-		  ib->list = current;
-		}
-	      ret = ib->list->m_Adapter;
-	      break;
-	    }
-	  prev = current;
-	}
-      RELEASE_MUTEX (&ib->lock);
-    }
-
-  return ret;
-}
diff -urN openvpn-2.1.1/tap-win32/tmp/lock.h openvpn-2.1.3/tap-win32/tmp/lock.h
--- openvpn-2.1.1/tap-win32/tmp/lock.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/lock.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,79 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-typedef struct
-{
-  volatile long count;
-} MUTEX;
-
-#define MUTEX_SLEEP_TIME  10000 // microseconds
-
-#define INIT_MUTEX(m) { (m)->count = 0; }
-
-#define ACQUIRE_MUTEX_BLOCKING(m)                         \
-{                                                         \
-    while (NdisInterlockedIncrement (&((m)->count)) != 1) \
-    {                                                     \
-        NdisInterlockedDecrement(&((m)->count));          \
-        NdisMSleep(MUTEX_SLEEP_TIME);                     \
-    }                                                     \
-}
-
-#define RELEASE_MUTEX(m)                                  \
-{                                                         \
-        NdisInterlockedDecrement(&((m)->count));          \
-}
-
-#define ACQUIRE_MUTEX_NONBLOCKING(m, result)              \
-{                                                         \
-    if (NdisInterlockedIncrement (&((m)->count)) != 1)    \
-    {                                                     \
-        NdisInterlockedDecrement(&((m)->count));          \
-        result = FALSE;                                   \
-    }                                                     \
-    else                                                  \
-    {                                                     \
-	result = TRUE;                                    \
-    }                                                     \
-}
-
-#define ACQUIRE_MUTEX_ADAPTIVE(m, result)                 \
-{                                                         \
-    result = TRUE;                                        \
-    while (NdisInterlockedIncrement (&((m)->count)) != 1) \
-    {                                                     \
-        NdisInterlockedDecrement(&((m)->count));          \
-        if (KeGetCurrentIrql () < DISPATCH_LEVEL)         \
-            NdisMSleep(MUTEX_SLEEP_TIME);                 \
-        else                                              \
-        {                                                 \
-	    result = FALSE;                               \
-	    break;                                        \
-        }                                                 \
-    }                                                     \
-}
diff -urN openvpn-2.1.1/tap-win32/tmp/macinfo.c openvpn-2.1.3/tap-win32/tmp/macinfo.c
--- openvpn-2.1.1/tap-win32/tmp/macinfo.c	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/macinfo.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,158 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "macinfo.h"
-
-int
-HexStringToDecimalInt (const int p_Character)
-{
-  int l_Value = 0;
-
-  if (p_Character >= 'A' && p_Character <= 'F')
-    l_Value = (p_Character - 'A') + 10;
-  else if (p_Character >= 'a' && p_Character <= 'f')
-    l_Value = (p_Character - 'a') + 10;
-  else if (p_Character >= '0' && p_Character <= '9')
-    l_Value = p_Character - '0';
-
-  return l_Value;
-}
-
-BOOLEAN
-ParseMAC (MACADDR dest, const char *src)
-{
-  int c;
-  int mac_index = 0;
-  BOOLEAN high_digit = FALSE;
-  int delim_action = 1;
-
-  MYASSERT (src);
-  MYASSERT (dest);
-
-  CLEAR_MAC (dest);
-
-  while (c = *src++)
-    {
-      if (IsMacDelimiter (c))
-	{
-	  mac_index += delim_action;
-	  high_digit = FALSE;
-	  delim_action = 1;
-	}
-      else if (IsHexDigit (c))
-	{
-	  const int digit = HexStringToDecimalInt (c);
-	  if (mac_index < sizeof (MACADDR))
-	    {
-	      if (!high_digit)
-		{
-		  dest[mac_index] = (char)(digit);
-		  high_digit = TRUE;
-		  delim_action = 1;
-		}
-	      else
-		{
-		  dest[mac_index] = (char)(dest[mac_index] * 16 + digit);
-		  ++mac_index;
-		  high_digit = FALSE;
-		  delim_action = 0;
-		}
-	    }
-	  else
-	    return FALSE;
-	}
-      else
-	return FALSE;
-    }
-
-  return (mac_index + delim_action) >= sizeof (MACADDR);
-}
-
-/*
- * Generate a MAC using the GUID in the adapter name.
- *
- * The mac is constructed as 00:FF:xx:xx:xx:xx where
- * the Xs are taken from the first 32 bits of the GUID in the
- * adapter name.  This is similar to the Linux 2.4 tap MAC
- * generator, except linux uses 32 random bits for the Xs.
- *
- * In general, this solution is reasonable for most
- * applications except for very large bridged TAP networks,
- * where the probability of address collisions becomes more
- * than infintesimal.
- *
- * Using the well-known "birthday paradox", on a 1000 node
- * network the probability of collision would be
- * 0.000116292153.  On a 10,000 node network, the probability
- * of collision would be 0.01157288998621678766.
- */
-
-VOID GenerateRandomMac (MACADDR mac, const unsigned char *adapter_name)
-{
-  unsigned const char *cp = adapter_name;
-  unsigned char c;
-  unsigned int i = 2;
-  unsigned int byte = 0;
-  int brace = 0;
-  int state = 0;
-
-  CLEAR_MAC (mac);
-
-  mac[0] = 0x00;
-  mac[1] = 0xFF;
-
-  while (c = *cp++)
-    {
-      if (i >= sizeof (MACADDR))
-	break;
-      if (c == '{')
-	brace = 1;
-      if (IsHexDigit (c) && brace)
-	{
-	  const unsigned int digit = HexStringToDecimalInt (c);
-	  if (state)
-	    {
-	      byte <<= 4;
-	      byte |= digit;
-	      mac[i++] = (unsigned char) byte;
-	      state = 0;
-	    }
-	  else
-	    {
-	      byte = digit;
-	      state = 1;
-	    }
-	}
-    }
-}
-
-VOID GenerateRelatedMAC (MACADDR dest, const MACADDR src, const int delta)
-{
-  COPY_MAC (dest, src);
-  dest[2] += (UCHAR) delta;
-}
diff -urN openvpn-2.1.1/tap-win32/tmp/macinfo.h openvpn-2.1.3/tap-win32/tmp/macinfo.h
--- openvpn-2.1.1/tap-win32/tmp/macinfo.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/macinfo.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef MacInfoDefined
-#define MacInfoDefined
-
-//===================================================================================
-//                                      Macros
-//===================================================================================
-#define IsMacDelimiter(a) (a == ':' || a == '-' || a == '.')
-#define IsHexDigit(c) ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))
-
-#define COPY_MAC(dest, src) NdisMoveMemory ((dest), (src), sizeof (MACADDR))
-#define CLEAR_MAC(dest)     NdisZeroMemory ((dest), sizeof (MACADDR))
-#define MAC_EQUAL(a,b)      (memcmp ((a), (b), sizeof (MACADDR)) == 0)
-
-#endif
diff -urN openvpn-2.1.1/tap-win32/tmp/mem.c openvpn-2.1.3/tap-win32/tmp/mem.c
--- openvpn-2.1.1/tap-win32/tmp/mem.c	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/mem.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,190 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-//------------------
-// Memory Management
-//------------------
-
-PVOID
-MemAlloc (ULONG p_Size, BOOLEAN zero)
-{
-  PVOID l_Return = NULL;
-
-  if (p_Size)
-    {
-      __try
-      {
-	if (NdisAllocateMemoryWithTag (&l_Return, p_Size, 'APAT')
-	    == NDIS_STATUS_SUCCESS)
-	  {
-	    if (zero)
-	      NdisZeroMemory (l_Return, p_Size);
-	  }
-	else
-	  l_Return = NULL;
-      }
-      __except (EXCEPTION_EXECUTE_HANDLER)
-      {
-	l_Return = NULL;
-      }
-    }
-
-  return l_Return;
-}
-
-VOID
-MemFree (PVOID p_Addr, ULONG p_Size)
-{
-  if (p_Addr && p_Size)
-    {
-      __try
-      {
-#if DBG
-	NdisZeroMemory (p_Addr, p_Size);
-#endif
-	NdisFreeMemory (p_Addr, p_Size, 0);
-      }
-      __except (EXCEPTION_EXECUTE_HANDLER)
-      {
-      }
-    }
-}
-
-/*
- * Circular queue management routines.
- */
-
-#define QUEUE_BYTE_ALLOCATION(size) \
-  (sizeof (Queue) + (size * sizeof (PVOID)))
-
-#define QUEUE_ADD_INDEX(var, inc) \
-{ \
-  var += inc; \
-  if (var >= q->capacity) \
-    var -= q->capacity; \
-  MYASSERT (var < q->capacity); \
-}
-
-#define QUEUE_SANITY_CHECK() \
-  MYASSERT (q != NULL && q->base < q->capacity && q->size <= q->capacity)
-
-#define QueueCount(q) (q->size)
-
-#define UPDATE_MAX_SIZE() \
-{ \
-  if (q->size > q->max_size) \
-    q->max_size = q->size; \
-}
-
-Queue *
-QueueInit (ULONG capacity)
-{
-  Queue *q;
-
-  MYASSERT (capacity > 0);
-  q = (Queue *) MemAlloc (QUEUE_BYTE_ALLOCATION (capacity), TRUE);
-  if (!q)
-    return NULL;
-
-  q->base = q->size = 0;
-  q->capacity = capacity;
-  q->max_size = 0;
-  return q;
-}
-
-VOID
-QueueFree (Queue *q)
-{
-  if (q)
-    {
-      QUEUE_SANITY_CHECK ();
-      MemFree (q, QUEUE_BYTE_ALLOCATION (q->capacity));
-    }
-}
-
-PVOID
-QueuePush (Queue *q, PVOID item)
-{
-  ULONG dest;
-  QUEUE_SANITY_CHECK ();
-  if (q->size == q->capacity)
-    return NULL;
-  dest = q->base;
-  QUEUE_ADD_INDEX (dest, q->size);
-  q->data[dest] = item;
-  ++q->size;
-  UPDATE_MAX_SIZE();
-  return item;
-}
-
-PVOID
-QueuePop (Queue *q)
-{
-  ULONG oldbase;
-  QUEUE_SANITY_CHECK ();
-  if (!q->size)
-    return NULL;
-  oldbase = q->base;
-  QUEUE_ADD_INDEX (q->base, 1);
-  --q->size;
-  UPDATE_MAX_SIZE();
-  return q->data[oldbase];
-}
-
-PVOID
-QueueExtract (Queue *q, PVOID item)
-{
-  ULONG src, dest, count, n;
-  QUEUE_SANITY_CHECK ();
-  n = 0;
-  src = dest = q->base;
-  count = q->size;
-  while (count--)
-    {
-      if (item == q->data[src])
-	{
-	  ++n;
-	  --q->size;
-	}
-      else
-	{
-	  q->data[dest] = q->data[src];
-	  QUEUE_ADD_INDEX (dest, 1);	  
-	}
-      QUEUE_ADD_INDEX (src, 1);
-    }
-  if (n)
-    return item;
-  else
-    return NULL;
-}
-
-#undef QUEUE_BYTE_ALLOCATION
-#undef QUEUE_ADD_INDEX
-#undef QUEUE_SANITY_CHECK
-#undef UPDATE_MAX_SIZE
diff -urN openvpn-2.1.1/tap-win32/tmp/proto.h openvpn-2.1.3/tap-win32/tmp/proto.h
--- openvpn-2.1.1/tap-win32/tmp/proto.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/proto.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,168 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-//============================================================
-// MAC address, Ethernet header, and ARP
-//============================================================
-
-#pragma pack(1)
-
-#define IP_HEADER_SIZE 20
-
-typedef unsigned char MACADDR [6];
-typedef unsigned long IPADDR;
-
-//-----------------
-// Ethernet address
-//-----------------
-
-typedef struct {
-  MACADDR addr;
-} ETH_ADDR;
-
-typedef struct {
-  ETH_ADDR list[NIC_MAX_MCAST_LIST];
-} MC_LIST;
-
-//----------------
-// Ethernet header
-//----------------
-
-typedef struct
-{
-  MACADDR dest;               /* destination eth addr	*/
-  MACADDR src;                /* source ether addr	*/
-
-# define ETH_P_IP   0x0800    /* IPv4 protocol */
-# define ETH_P_ARP  0x0806    /* ARP protocol */
-  USHORT proto;               /* packet type ID field	*/
-} ETH_HEADER, *PETH_HEADER;
-
-//----------------
-// ARP packet
-//----------------
-
-typedef struct
-   {
-    MACADDR        m_MAC_Destination;        // Reverse these two
-    MACADDR        m_MAC_Source;             // to answer ARP requests
-    USHORT         m_Proto;                  // 0x0806
-
-#   define MAC_ADDR_TYPE 0x0001
-    USHORT         m_MAC_AddressType;        // 0x0001
-
-    USHORT         m_PROTO_AddressType;      // 0x0800
-    UCHAR          m_MAC_AddressSize;        // 0x06
-    UCHAR          m_PROTO_AddressSize;      // 0x04
-
-#   define ARP_REQUEST 0x0001
-#   define ARP_REPLY   0x0002
-    USHORT         m_ARP_Operation;          // 0x0001 for ARP request, 0x0002 for ARP reply
-
-    MACADDR        m_ARP_MAC_Source;
-    IPADDR         m_ARP_IP_Source;
-    MACADDR        m_ARP_MAC_Destination;
-    IPADDR         m_ARP_IP_Destination;
-   }
-ARP_PACKET, *PARP_PACKET;
-
-//----------
-// IP Header
-//----------
-
-typedef struct {
-# define IPH_GET_VER(v) (((v) >> 4) & 0x0F)
-# define IPH_GET_LEN(v) (((v) & 0x0F) << 2)
-  UCHAR    version_len;
-
-  UCHAR    tos;
-  USHORT   tot_len;
-  USHORT   id;
-
-# define IP_OFFMASK 0x1fff
-  USHORT   frag_off;
-
-  UCHAR    ttl;
-
-# define IPPROTO_UDP  17  /* UDP protocol */
-# define IPPROTO_TCP   6  /* TCP protocol */
-# define IPPROTO_ICMP  1  /* ICMP protocol */
-# define IPPROTO_IGMP  2  /* IGMP protocol */
-  UCHAR    protocol;
-
-  USHORT   check;
-  ULONG    saddr;
-  ULONG    daddr;
-  /* The options start here. */
-} IPHDR;
-
-//-----------
-// UDP header
-//-----------
-
-typedef struct {
-  USHORT   source;
-  USHORT   dest;
-  USHORT   len;
-  USHORT   check;
-} UDPHDR;
-
-//--------------------------
-// TCP header, per RFC 793.
-//--------------------------
-
-typedef struct {
-  USHORT      source;    /* source port */
-  USHORT      dest;      /* destination port */
-  ULONG       seq;       /* sequence number */
-  ULONG       ack_seq;   /* acknowledgement number */
-
-# define TCPH_GET_DOFF(d) (((d) & 0xF0) >> 2)
-  UCHAR       doff_res;
-
-# define TCPH_FIN_MASK (1<<0)
-# define TCPH_SYN_MASK (1<<1)
-# define TCPH_RST_MASK (1<<2)
-# define TCPH_PSH_MASK (1<<3)
-# define TCPH_ACK_MASK (1<<4)
-# define TCPH_URG_MASK (1<<5)
-# define TCPH_ECE_MASK (1<<6)
-# define TCPH_CWR_MASK (1<<7)
-  UCHAR       flags;
-
-  USHORT      window;
-  USHORT      check;
-  USHORT      urg_ptr;
-} TCPHDR;
-
-#define	TCPOPT_EOL     0
-#define	TCPOPT_NOP     1
-#define	TCPOPT_MAXSEG  2
-#define TCPOLEN_MAXSEG 4
-
-#pragma pack()
diff -urN openvpn-2.1.1/tap-win32/tmp/prototypes.h openvpn-2.1.3/tap-win32/tmp/prototypes.h
--- openvpn-2.1.1/tap-win32/tmp/prototypes.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/prototypes.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,264 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef TAP_PROTOTYPES_DEFINED
-#define TAP_PROTOTYPES_DEFINED
-
-NTSTATUS DriverEntry
-   (
-    IN PDRIVER_OBJECT p_DriverObject,
-    IN PUNICODE_STRING p_RegistryPath
-   );
-
-VOID TapDriverUnload
-   (
-    IN PDRIVER_OBJECT p_DriverObject
-   );
-
-NDIS_STATUS AdapterCreate
-   (
-    OUT PNDIS_STATUS p_ErrorStatus,
-    OUT PUINT p_MediaIndex,
-    IN PNDIS_MEDIUM p_Media,
-    IN UINT p_MediaCount,
-    IN NDIS_HANDLE p_AdapterHandle,
-    IN NDIS_HANDLE p_ConfigurationHandle
-   );
-
-VOID AdapterHalt
-   (
-    IN NDIS_HANDLE p_AdapterContext
-   );
-
-VOID AdapterFreeResources
-   (
-    TapAdapterPointer p_Adapter
-   );
-
-NDIS_STATUS AdapterReset
-   (
-    OUT PBOOLEAN p_AddressingReset,
-    IN NDIS_HANDLE p_AdapterContext
-   );
-
-NDIS_STATUS AdapterQuery
-   (
-    IN NDIS_HANDLE p_AdapterContext,
-    IN NDIS_OID p_OID,
-    IN PVOID p_Buffer,
-    IN ULONG p_BufferLength,
-    OUT PULONG p_BytesWritten,
-    OUT PULONG p_BytesNeeded
-   );
-
-NDIS_STATUS AdapterModify
-   (
-    IN NDIS_HANDLE p_AdapterContext,
-    IN NDIS_OID p_OID,
-    IN PVOID p_Buffer,
-    IN ULONG p_BufferLength,
-    OUT PULONG p_BytesRead,
-    OUT PULONG p_BytesNeeded
-   );
-
-NDIS_STATUS AdapterTransmit
-   (
-    IN NDIS_HANDLE p_AdapterContext,
-    IN PNDIS_PACKET p_Packet,
-    IN UINT p_Flags
-   );
-
-NDIS_STATUS AdapterReceive
-   (
-    OUT PNDIS_PACKET p_Packet,
-    OUT PUINT p_Transferred,
-    IN NDIS_HANDLE p_AdapterContext,
-    IN NDIS_HANDLE p_ReceiveContext,
-    IN UINT p_Offset,
-    IN UINT p_ToTransfer
-   );
-
-NTSTATUS TapDeviceHook
-   (
-    IN PDEVICE_OBJECT p_DeviceObject,
-    IN PIRP p_IRP
-   );
-
-NDIS_STATUS CreateTapDevice
-   (
-    TapExtensionPointer p_Extension,
-    const char *p_Name
-   );
-
-VOID DestroyTapDevice
-   (
-    TapExtensionPointer p_Extension
-   );
-
-VOID TapDeviceFreeResources
-   (
-    TapExtensionPointer p_Extension
-    );
-
-NTSTATUS CompleteIRP
-   (
-    IN PIRP p_IRP,
-    IN TapPacketPointer p_PacketBuffer,
-    IN CCHAR PriorityBoost
-   );
-
-VOID CancelIRPCallback
-   (
-    IN PDEVICE_OBJECT p_DeviceObject,
-    IN PIRP p_IRP
-   );
-
-VOID CancelIRP
-   (
-    TapExtensionPointer p_Extension,
-    IN PIRP p_IRP,
-    BOOLEAN callback
-   );
-
-VOID FlushQueues
-   (
-    TapExtensionPointer p_Extension
-   );
-
-VOID ResetTapAdapterState
-   (
-    TapAdapterPointer p_Adapter
-   );
-
-BOOLEAN ProcessARP
-   (
-    TapAdapterPointer p_Adapter,
-    const PARP_PACKET src,
-    const IPADDR adapter_ip,
-    const IPADDR ip_network,
-    const IPADDR ip_netmask,
-    const MACADDR mac
-   );
-
-VOID SetMediaStatus
-   (
-    TapAdapterPointer p_Adapter,
-    BOOLEAN state
-   );
-
-VOID InjectPacketDeferred
-   (
-    TapAdapterPointer p_Adapter,
-    UCHAR *packet,
-    const unsigned int len
-   );
-
-VOID InjectPacketNow
-   (
-    TapAdapterPointer p_Adapter,
-    UCHAR *packet,
-    const unsigned int len
-   );
-
-// for KDEFERRED_ROUTINE and Static Driver Verifier
-//#include <wdm.h>
-//KDEFERRED_ROUTINE InjectPacketDpc;
-
-VOID InjectPacketDpc
-   (
-    KDPC *Dpc,
-    PVOID DeferredContext,
-    PVOID SystemArgument1,
-    PVOID SystemArgument2
-    );
-
-VOID CheckIfDhcpAndTunMode
-   (
-    TapAdapterPointer p_Adapter
-   );
-
-VOID HookDispatchFunctions();
-
-#if ENABLE_NONADMIN
-
-#if DDKVER_MAJOR < 5600
-/*
- * Better solution for use on Vista DDK, but possibly not compatible with
- * earlier DDKs:
- *
- * Eliminate the definition of SECURITY_DESCRIPTOR (and even ZwSetSecurityObject),
- * and at the top of tapdrv.c change:
- *
- * #include <ndis.h>
- * #include <ntstrsafe.h>
- * #include <ntddk.h>
- *
- * To
- *
- * #include <ntifs.h>
- * #include <ndis.h>
- * #include <ntstrsafe.h>
- */
-typedef struct _SECURITY_DESCRIPTOR {
-  unsigned char opaque[64];
-} SECURITY_DESCRIPTOR;
-
-NTSYSAPI
-NTSTATUS
-NTAPI
-ZwSetSecurityObject (
-  IN HANDLE  Handle,
-  IN SECURITY_INFORMATION  SecurityInformation,
-  IN PSECURITY_DESCRIPTOR  SecurityDescriptor);
-
-#endif
-
-VOID AllowNonAdmin (TapExtensionPointer p_Extension);
-
-#endif
-
-struct WIN2K_NDIS_MINIPORT_BLOCK
-{
-  unsigned char  opaque[16];
-  UNICODE_STRING MiniportName;       // how mini-port refers to us
-};
-
-#if PACKET_TRUNCATION_CHECK
-
-VOID IPv4PacketSizeVerify
-   (
-    const UCHAR *data,
-    ULONG length,
-    BOOLEAN tun,
-    const char *prefix,
-    LONG *counter
-   );
-
-#endif
-
-#endif
diff -urN openvpn-2.1.1/tap-win32/tmp/tapdrvr.c openvpn-2.1.3/tap-win32/tmp/tapdrvr.c
--- openvpn-2.1.1/tap-win32/tmp/tapdrvr.c	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/tapdrvr.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2959 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-//======================================================
-// This driver is designed to work on Win 2000 or higher
-// versions of Windows.
-//
-// It is SMP-safe and handles NDIS 5 power management.
-//
-// By default we operate as a "tap" virtual ethernet
-// 802.3 interface, but we can emulate a "tun"
-// interface (point-to-point IPv4) through the
-// TAP_IOCTL_CONFIG_POINT_TO_POINT or
-// TAP_IOCTL_CONFIG_TUN ioctl.
-//======================================================
-
-#include "../../autodefs/defs.h"
-#ifndef DDKVER_MAJOR
-#error DDKVER_MAJOR must be defined as the major number of the DDK Version
-#endif
-
-#define NDIS_MINIPORT_DRIVER
-#define BINARY_COMPATIBLE 0
-#define NDIS50_MINIPORT 1
-#define NDIS_WDM 0
-#define NDIS50 1
-#define NTSTRSAFE_LIB
-
-// Debug info output
-#define ALSO_DBGPRINT           1
-#define DEBUGP_AT_DISPATCH      0
-
-//========================================================
-// Check for truncated IPv4 packets, log errors if found.
-//========================================================
-#define PACKET_TRUNCATION_CHECK 0
-
-//========================================================
-// EXPERIMENTAL -- Configure TAP device object to be
-// accessible from non-administrative accounts, based
-// on an advanced properties setting.
-//
-// Duplicates the functionality of OpenVPN's
-// --allow-nonadmin directive.
-//========================================================
-#define ENABLE_NONADMIN 1
-
-#if DDKVER_MAJOR < 5600
-#include <ndis.h>
-#include <ntstrsafe.h>
-#include <ntddk.h>
-#else
-#include <ntifs.h>
-#include <ndis.h>
-#include <ntstrsafe.h>
-#endif
-
-#include "lock.h"
-#include "constants.h"
-#include "common.h"
-#include "proto.h"
-#include "error.h"
-#include "endian.h"
-#include "dhcp.h"
-#include "types.h"
-#include "prototypes.h"
-
-#include "mem.c"
-#include "macinfo.c"
-#include "error.c"
-#include "dhcp.c"
-#include "instance.c"
-
-#define IS_UP(ta) \
-  ((ta)->m_InterfaceIsRunning && (ta)->m_Extension.m_TapIsRunning)
-
-#define INCREMENT_STAT(s) ++(s)
-
-#define NAME_BUFFER_SIZE 80
-
-//========================================================
-//                            Globals
-//========================================================
-
-NDIS_HANDLE g_NdisWrapperHandle;
-
-const UINT g_SupportedOIDList[] = {
-  OID_GEN_HARDWARE_STATUS,
-  OID_GEN_MEDIA_SUPPORTED,
-  OID_GEN_MEDIA_IN_USE,
-  OID_GEN_MAXIMUM_LOOKAHEAD,
-  OID_GEN_MAC_OPTIONS,
-  OID_GEN_LINK_SPEED,
-  OID_GEN_TRANSMIT_BLOCK_SIZE,
-  OID_GEN_RECEIVE_BLOCK_SIZE,
-  OID_GEN_VENDOR_DESCRIPTION,
-  OID_GEN_DRIVER_VERSION,
-  OID_GEN_XMIT_OK,
-  OID_GEN_RCV_OK,
-  OID_GEN_XMIT_ERROR,
-  OID_GEN_RCV_ERROR,
-  OID_802_3_PERMANENT_ADDRESS,
-  OID_802_3_CURRENT_ADDRESS,
-  OID_GEN_RCV_NO_BUFFER,
-  OID_802_3_RCV_ERROR_ALIGNMENT,
-  OID_802_3_XMIT_ONE_COLLISION,
-  OID_802_3_XMIT_MORE_COLLISIONS,
-  OID_802_3_MULTICAST_LIST,
-  OID_802_3_MAXIMUM_LIST_SIZE,
-  OID_GEN_VENDOR_ID,
-  OID_GEN_CURRENT_LOOKAHEAD,
-  OID_GEN_CURRENT_PACKET_FILTER,
-  OID_GEN_PROTOCOL_OPTIONS,
-  OID_GEN_MAXIMUM_TOTAL_SIZE,
-  OID_GEN_TRANSMIT_BUFFER_SPACE,
-  OID_GEN_RECEIVE_BUFFER_SPACE,
-  OID_GEN_MAXIMUM_FRAME_SIZE,
-  OID_GEN_VENDOR_DRIVER_VERSION,
-  OID_GEN_MAXIMUM_SEND_PACKETS,
-  OID_GEN_MEDIA_CONNECT_STATUS,
-  OID_GEN_SUPPORTED_LIST
-};
-
-//============================================================
-//                         Driver Entry
-//============================================================
-#pragma NDIS_INIT_FUNCTION (DriverEntry)
-
-NTSTATUS
-DriverEntry (IN PDRIVER_OBJECT p_DriverObject,
-	     IN PUNICODE_STRING p_RegistryPath)
-{
-  NDIS_STATUS l_Status = NDIS_STATUS_FAILURE;
-  NDIS_MINIPORT_CHARACTERISTICS *l_Properties = NULL;
-
-  //========================================================
-  // Notify NDIS that a new miniport driver is initializing.
-  //========================================================
-
-  NdisMInitializeWrapper (&g_NdisWrapperHandle,
-			  p_DriverObject,
-			  p_RegistryPath, NULL);
-
-  //======================
-  // Global initialization
-  //======================
-
-#if DBG
-  MyDebugInit (10000); // Allocate debugging text space
-#endif
-
-  if (!InitInstanceList ())
-    {
-      DEBUGP (("[TAP] Allocation failed for adapter instance list\n"));
-      goto cleanup;
-    }
-
-  //=======================================
-  // Set and register miniport entry points
-  //=======================================
-
-  l_Properties = MemAlloc (sizeof (NDIS_MINIPORT_CHARACTERISTICS), TRUE);
-
-  if (l_Properties == NULL)
-    {
-      DEBUGP (("[TAP] Allocation failed for miniport entry points\n"));
-      goto cleanup;
-    }
-
-  l_Properties->MajorNdisVersion = TAP_NDIS_MAJOR_VERSION;
-  l_Properties->MinorNdisVersion = TAP_NDIS_MINOR_VERSION;
-  l_Properties->InitializeHandler = AdapterCreate;
-  l_Properties->HaltHandler = AdapterHalt;
-  l_Properties->ResetHandler = AdapterReset;               /* DISPATCH_LEVEL */
-  l_Properties->TransferDataHandler = AdapterReceive;      /* DISPATCH_LEVEL */
-  l_Properties->SendHandler = AdapterTransmit;             /* DISPATCH_LEVEL */
-  l_Properties->QueryInformationHandler = AdapterQuery;    /* DISPATCH_LEVEL */
-  l_Properties->SetInformationHandler = AdapterModify;     /* DISPATCH_LEVEL */
-
-  switch (l_Status =
-	  NdisMRegisterMiniport (g_NdisWrapperHandle, l_Properties,
-				 sizeof (NDIS_MINIPORT_CHARACTERISTICS)))
-    {
-    case NDIS_STATUS_SUCCESS:
-      {
-	DEBUGP (("[TAP] version [%d.%d] %s %s registered miniport successfully\n",
-		 TAP_DRIVER_MAJOR_VERSION,
-		 TAP_DRIVER_MINOR_VERSION,
-		 __DATE__,
-		 __TIME__));
-	DEBUGP (("Registry Path: '%S'\n", p_RegistryPath->Buffer));
-	break;
-      }
-
-    case NDIS_STATUS_BAD_CHARACTERISTICS:
-      {
-	DEBUGP (("[TAP] Miniport characteristics were badly defined\n"));
-	NdisTerminateWrapper (g_NdisWrapperHandle, NULL);
-	break;
-      }
-
-    case NDIS_STATUS_BAD_VERSION:
-      {
-	DEBUGP
-	  (("[TAP] NDIS Version is wrong for the given characteristics\n"));
-	NdisTerminateWrapper (g_NdisWrapperHandle, NULL);
-	break;
-      }
-
-    case NDIS_STATUS_RESOURCES:
-      {
-	DEBUGP (("[TAP] Insufficient resources\n"));
-	NdisTerminateWrapper (g_NdisWrapperHandle, NULL);
-	break;
-      }
-
-    default:
-    case NDIS_STATUS_FAILURE:
-      {
-	DEBUGP (("[TAP] Unknown fatal registration error\n"));
-	NdisTerminateWrapper (g_NdisWrapperHandle, NULL);
-	break;
-      }
-    }
-
- cleanup:
-  if (l_Properties)
-    MemFree (l_Properties, sizeof (NDIS_MINIPORT_CHARACTERISTICS));
-
-  if (l_Status == NDIS_STATUS_SUCCESS)
-    NdisMRegisterUnloadHandler (g_NdisWrapperHandle, TapDriverUnload);
-  else
-    TapDriverUnload (p_DriverObject);
-
-  return l_Status;
-}
-
-//============================================================
-//                         Driver Unload
-//============================================================
-VOID 
-TapDriverUnload (IN PDRIVER_OBJECT p_DriverObject)
-{
-  DEBUGP (("[TAP] version [%d.%d] %s %s unloaded, instances=%d, imbs=%d\n",
-	   TAP_DRIVER_MAJOR_VERSION,
-	   TAP_DRIVER_MINOR_VERSION,
-	   __DATE__,
-	   __TIME__,
-	   NInstances(),
-	   InstanceMaxBucketSize()));
-
-  FreeInstanceList ();
-
-  //==============================
-  // Free debugging text space
-  //==============================
-#if DBG
-  MyDebugFree ();
-#endif
-}
-
-//==========================================================
-//                            Adapter Initialization
-//==========================================================
-NDIS_STATUS AdapterCreate
-(OUT PNDIS_STATUS p_ErrorStatus,
- OUT PUINT p_MediaIndex,
- IN PNDIS_MEDIUM p_Media,
- IN UINT p_MediaCount,
- IN NDIS_HANDLE p_AdapterHandle,
- IN NDIS_HANDLE p_ConfigurationHandle)
-{
-  TapAdapterPointer l_Adapter = NULL;
-
-  NDIS_MEDIUM l_PreferredMedium = NdisMedium802_3; // Ethernet
-  BOOLEAN l_MacFromRegistry = FALSE;
-  UINT l_Index;
-  NDIS_STATUS status;
-
-#if ENABLE_NONADMIN
-  BOOLEAN enable_non_admin = FALSE;
-#endif
-
-  DEBUGP (("[TAP] AdapterCreate called\n"));
-
-  //====================================
-  // Make sure adapter type is supported
-  //====================================
-
-  for (l_Index = 0;
-       l_Index < p_MediaCount && p_Media[l_Index] != l_PreferredMedium;
-       ++l_Index);
-
-  if (l_Index == p_MediaCount)
-    {
-      DEBUGP (("[TAP] Unsupported adapter type [wanted: %d]\n",
-	       l_PreferredMedium));
-      return NDIS_STATUS_UNSUPPORTED_MEDIA;
-    }
-
-  *p_MediaIndex = l_Index;
-
-  //=========================================
-  // Allocate memory for TapAdapter structure
-  //=========================================
-
-  l_Adapter = MemAlloc (sizeof (TapAdapter), TRUE);
-
-  if (l_Adapter == NULL)
-    {
-      DEBUGP (("[TAP] Couldn't allocate adapter memory\n"));
-      return NDIS_STATUS_RESOURCES;
-    }
-
-  //==========================================
-  // Inform the NDIS library about significant
-  // features of our virtual NIC.
-  //==========================================
-
-  NdisMSetAttributesEx
-    (p_AdapterHandle,
-     (NDIS_HANDLE) l_Adapter,
-     16,
-     NDIS_ATTRIBUTE_DESERIALIZE
-     | NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT
-     | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT
-     | NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
-     NdisInterfaceInternal);
-
-  //=====================================
-  // Initialize simple Adapter parameters
-  //=====================================
-
-  l_Adapter->m_Lookahead = DEFAULT_PACKET_LOOKAHEAD;
-  l_Adapter->m_Medium = l_PreferredMedium;
-  l_Adapter->m_DeviceState = '?';
-  l_Adapter->m_MiniportAdapterHandle = p_AdapterHandle;
-
-  //==================================
-  // Allocate spinlock for controlling
-  // access to multicast address list.
-  //==================================
-  NdisAllocateSpinLock (&l_Adapter->m_MCLock);
-  l_Adapter->m_MCLockAllocated = TRUE;
-
-  //====================================================
-  // Register a shutdown handler which will be called
-  // on system restart/shutdown to halt our virtual NIC.
-  //====================================================
-
-  NdisMRegisterAdapterShutdownHandler (p_AdapterHandle, l_Adapter,
-				       AdapterHalt);
-  l_Adapter->m_RegisteredAdapterShutdownHandler = TRUE;
-
-  //============================================
-  // Get parameters from registry which were set
-  // in the adapter advanced properties dialog.
-  //============================================
-  {
-    NDIS_STATUS status;
-    NDIS_HANDLE configHandle;
-    NDIS_CONFIGURATION_PARAMETER *parm;
-
-    // set defaults in case our registry query fails
-    l_Adapter->m_MTU = ETHERNET_MTU;
-    l_Adapter->m_MediaStateAlwaysConnected = FALSE;
-    l_Adapter->m_MediaState = FALSE;
-
-    NdisOpenConfiguration (&status, &configHandle, p_ConfigurationHandle);
-    if (status != NDIS_STATUS_SUCCESS)
-      {
-	DEBUGP (("[TAP] Couldn't open adapter registry\n"));
-	AdapterFreeResources (l_Adapter);
-	return status;
-      }
-
-    //====================================
-    // Allocate and construct adapter name
-    //====================================
-    {
-      
-      NDIS_STRING mkey = NDIS_STRING_CONST("MiniportName");
-      NDIS_STRING vkey = NDIS_STRING_CONST("NdisVersion");
-      NDIS_STATUS vstatus;
-      NDIS_CONFIGURATION_PARAMETER *vparm;
-
-      NdisReadConfiguration (&vstatus, &vparm, configHandle, &vkey, NdisParameterInteger);
-      if (vstatus == NDIS_STATUS_SUCCESS)
-	DEBUGP (("[TAP] NdisReadConfiguration NdisVersion=%X\n", vparm->ParameterData.IntegerData));
-
-      NdisReadConfiguration (&status, &parm, configHandle, &mkey, NdisParameterString);
-      if (status == NDIS_STATUS_SUCCESS)
-	{
-	  if (parm->ParameterType == NdisParameterString)
-	    {
-	      DEBUGP (("[TAP] NdisReadConfiguration (MiniportName=%S)\n", parm->ParameterData.StringData.Buffer));
-
-	      if (RtlUnicodeStringToAnsiString (
-						&l_Adapter->m_NameAnsi,
-						&parm->ParameterData.StringData,
-						TRUE) != STATUS_SUCCESS)
-		{
-		  DEBUGP (("[TAP] MiniportName failed\n"));
-		  status = NDIS_STATUS_RESOURCES;
-		}
-	    }
-	}
-      else
-	{
-	  /* "MiniportName" is available only XP and above.  Not on Windows 2000. */
-	  if (vstatus == NDIS_STATUS_SUCCESS && vparm->ParameterData.IntegerData == 0x50000)
-	    {
-	      /* Fallback for Windows 2000 with NDIS version 5.00.00
-		 Don't use this on Vista, 'NDIS_MINIPORT_BLOCK' was changed! */
-	      if (RtlUnicodeStringToAnsiString (&l_Adapter->m_NameAnsi,
-						&((struct WIN2K_NDIS_MINIPORT_BLOCK *) p_AdapterHandle)->MiniportName,
-						TRUE) != STATUS_SUCCESS)
-		{
-		  DEBUGP (("[TAP] MiniportName (W2K) failed\n"));
-		  status = NDIS_STATUS_RESOURCES;
-		}
-	      else
-		{
-		  DEBUGP (("[TAP] MiniportName (W2K) succeeded: %s\n", l_Adapter->m_NameAnsi.Buffer));
-		  status = NDIS_STATUS_SUCCESS;
-		}
-	    }
-	}
-    }
-
-    /* Can't continue without name (see macro 'NAME') */
-    if (status != NDIS_STATUS_SUCCESS || !l_Adapter->m_NameAnsi.Buffer)
-      {
-	NdisCloseConfiguration (configHandle);
-	AdapterFreeResources (l_Adapter);
-	DEBUGP (("[TAP] failed to get miniport name\n"));
-	return NDIS_STATUS_RESOURCES;
-      }
-
-    /* Read MTU setting from registry */
-    {
-      NDIS_STRING key = NDIS_STRING_CONST("MTU");
-      NdisReadConfiguration (&status, &parm, configHandle,
-			     &key, NdisParameterInteger);
-      if (status == NDIS_STATUS_SUCCESS)
-	{
-	  if (parm->ParameterType == NdisParameterInteger)
-	    {
-	      int mtu = parm->ParameterData.IntegerData;
-	      if (mtu < MINIMUM_MTU)
-		mtu = MINIMUM_MTU;
-	      if (mtu > MAXIMUM_MTU)
-		mtu = MAXIMUM_MTU;
-	      l_Adapter->m_MTU = mtu;
-	    }
-	}
-    }
-
-    /* Read Media Status setting from registry */
-    {
-      NDIS_STRING key = NDIS_STRING_CONST("MediaStatus");
-      NdisReadConfiguration (&status, &parm, configHandle,
-			     &key, NdisParameterInteger);
-      if (status == NDIS_STATUS_SUCCESS)
-	{
-	  if (parm->ParameterType == NdisParameterInteger)
-	    {
-	      if (parm->ParameterData.IntegerData)
-		{
-		  l_Adapter->m_MediaStateAlwaysConnected = TRUE;
-		  l_Adapter->m_MediaState = TRUE;
-		}
-	    }
-	}
-    }
-
-#if ENABLE_NONADMIN
-    /* Read AllowNonAdmin setting from registry */
-    {
-      NDIS_STRING key = NDIS_STRING_CONST("AllowNonAdmin");
-      NdisReadConfiguration (&status, &parm, configHandle,
-			     &key, NdisParameterInteger);
-      if (status == NDIS_STATUS_SUCCESS)
-	{
-	  if (parm->ParameterType == NdisParameterInteger)
-	    {
-	      if (parm->ParameterData.IntegerData)
-		{
-		  enable_non_admin = TRUE;
-		}
-	    }
-	}
-    }
-#endif
-
-    /* Read optional MAC setting from registry */
-    {
-      NDIS_STRING key = NDIS_STRING_CONST("MAC");
-      ANSI_STRING mac_string;
-      NdisReadConfiguration (&status, &parm, configHandle,
-			     &key, NdisParameterString);
-      if (status == NDIS_STATUS_SUCCESS)
-	{
-	  if (parm->ParameterType == NdisParameterString)
-	    {
-	      if (RtlUnicodeStringToAnsiString (&mac_string, &parm->ParameterData.StringData, TRUE) == STATUS_SUCCESS)
-		{
-		  l_MacFromRegistry = ParseMAC (l_Adapter->m_MAC, mac_string.Buffer);
-		  RtlFreeAnsiString (&mac_string);
-		}
-	    }
-	}
-    }
-
-    NdisCloseConfiguration (configHandle);
-
-    DEBUGP (("[%s] MTU=%d\n", NAME (l_Adapter), l_Adapter->m_MTU));
-  }
-
-  //==================================
-  // Store and update MAC address info
-  //==================================
-
-  if (!l_MacFromRegistry)
-    GenerateRandomMac (l_Adapter->m_MAC, NAME (l_Adapter));
-
-  DEBUGP (("[%s] Using MAC %x:%x:%x:%x:%x:%x\n",
-	   NAME (l_Adapter),
-	   l_Adapter->m_MAC[0], l_Adapter->m_MAC[1], l_Adapter->m_MAC[2],
-	   l_Adapter->m_MAC[3], l_Adapter->m_MAC[4], l_Adapter->m_MAC[5]));
-
-  //==================
-  // Set broadcast MAC
-  //==================
-  {
-    int i;
-    for (i = 0; i < sizeof (MACADDR); ++i)
-      l_Adapter->m_MAC_Broadcast[i] = 0xFF;
-  }
-
-  //====================================
-  // Initialize TAP device
-  //====================================
-  {
-    NDIS_STATUS tap_status;
-    tap_status = CreateTapDevice (&l_Adapter->m_Extension, NAME (l_Adapter));
-    if (tap_status != NDIS_STATUS_SUCCESS)
-      {
-	AdapterFreeResources (l_Adapter);
-	DEBUGP (("[TAP] CreateTapDevice failed\n"));
-	return tap_status;
-      }
-  }
-
-  if (!AddAdapterToInstanceList (l_Adapter))
-    {
-      NOTE_ERROR ();
-      TapDeviceFreeResources (&l_Adapter->m_Extension);
-      AdapterFreeResources (l_Adapter);
-      DEBUGP (("[TAP] AddAdapterToInstanceList failed\n"));
-      return NDIS_STATUS_RESOURCES;
-    }
-
-  l_Adapter->m_InterfaceIsRunning = TRUE;
-
-#if ENABLE_NONADMIN
-  if (enable_non_admin)
-    AllowNonAdmin (&l_Adapter->m_Extension);
-#endif
-
-  return NDIS_STATUS_SUCCESS;
-}
-
-VOID
-AdapterHalt (IN NDIS_HANDLE p_AdapterContext)
-{
-  BOOLEAN status;
-
-  TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
-
-  NOTE_ERROR ();
-
-  l_Adapter->m_InterfaceIsRunning = FALSE;
-
-  DEBUGP (("[%s] is being halted\n", NAME (l_Adapter)));
-  
-  DestroyTapDevice (&l_Adapter->m_Extension);
-
-  // Free resources
-  DEBUGP (("[%s] Freeing Resources\n", NAME (l_Adapter)));
-  AdapterFreeResources (l_Adapter);
-
-  status = RemoveAdapterFromInstanceList (l_Adapter);
-  DEBUGP (("[TAP] RemoveAdapterFromInstanceList returned %d\n", (int) status));
-
-  DEBUGP (("[TAP] version [%d.%d] %s %s AdapterHalt returning\n",
-	   TAP_DRIVER_MAJOR_VERSION,
-	   TAP_DRIVER_MINOR_VERSION,
-	   __DATE__,
-	   __TIME__));
-}
-
-VOID
-AdapterFreeResources (TapAdapterPointer p_Adapter)
-{
-  MYASSERT (!p_Adapter->m_CalledAdapterFreeResources);
-  p_Adapter->m_CalledAdapterFreeResources = TRUE;
-
-  if (p_Adapter->m_NameAnsi.Buffer)
-    RtlFreeAnsiString (&p_Adapter->m_NameAnsi);
-  
-  if (p_Adapter->m_RegisteredAdapterShutdownHandler)
-    NdisMDeregisterAdapterShutdownHandler (p_Adapter->m_MiniportAdapterHandle);
-
-  if (p_Adapter->m_MCLockAllocated)
-    NdisFreeSpinLock (&p_Adapter->m_MCLock);
-}
-
-VOID
-DestroyTapDevice (TapExtensionPointer p_Extension)
-{
-  DEBUGP (("[%s] Destroying tap device\n", p_Extension->m_TapName));
-
-  //======================================
-  // Let clients know we are shutting down
-  //======================================
-  p_Extension->m_TapIsRunning = FALSE;
-  p_Extension->m_TapOpens = 0;
-  p_Extension->m_Halt = TRUE;
-
-  //=====================================
-  // If we are concurrently executing in
-  // TapDeviceHook or AdapterTransmit,
-  // give those calls time to finish.
-  // Note that we must be running at IRQL
-  // < DISPATCH_LEVEL in order to call
-  // NdisMSleep.
-  //=====================================
-  NdisMSleep (500000);
-
-  //===========================================================
-  // Exhaust IRP and packet queues.  Any pending IRPs will
-  // be cancelled, causing user-space to get this error
-  // on overlapped reads:
-  //   The I/O operation has been aborted because of either a
-  //   thread exit or an application request.   (code=995)
-  // It's important that user-space close the device handle
-  // when this code is returned, so that when we finally
-  // do a NdisMDeregisterDevice, the device reference count
-  // is 0.  Otherwise the driver will not unload even if the
-  // the last adapter has been halted.
-  //===========================================================
-  FlushQueues (p_Extension);
-  NdisMSleep (500000); // give user space time to respond to IRP cancel
-
-  TapDeviceFreeResources (p_Extension);
-}
-
-VOID
-TapDeviceFreeResources (TapExtensionPointer p_Extension)
-{
-  MYASSERT (p_Extension);
-  MYASSERT (!p_Extension->m_CalledTapDeviceFreeResources);
-  p_Extension->m_CalledTapDeviceFreeResources = TRUE;
-
-  if (p_Extension->m_PacketQueue)
-    QueueFree (p_Extension->m_PacketQueue);
-  if (p_Extension->m_IrpQueue)
-    QueueFree (p_Extension->m_IrpQueue);
-  if (p_Extension->m_InjectQueue)
-    QueueFree (p_Extension->m_InjectQueue);
-
-  if (p_Extension->m_CreatedUnicodeLinkName)
-    RtlFreeUnicodeString (&p_Extension->m_UnicodeLinkName);
-
-  //==========================================================
-  // According to DDK docs, the device is not actually deleted
-  // until its reference count falls to zero.  That means we
-  // still need to gracefully fail TapDeviceHook requests
-  // after this point, otherwise ugly things would happen if
-  // the device was disabled (e.g. in the network connections
-  // control panel) while a userspace app still held an open
-  // file handle to it.
-  //==========================================================
-  
-  if (p_Extension->m_TapDevice)
-    {
-      BOOLEAN status;
-      status = (NdisMDeregisterDevice (p_Extension->m_TapDeviceHandle)
-		== NDIS_STATUS_SUCCESS);
-      DEBUGP (("[TAP] Deregistering TAP device, status=%d\n", (int)status));
-    }
-
-  if (p_Extension->m_TapName)
-    MemFree (p_Extension->m_TapName, NAME_BUFFER_SIZE);
-  
-  if (p_Extension->m_InjectDpcInitialized)
-    KeRemoveQueueDpc (&p_Extension->m_InjectDpc);
-
-  if (p_Extension->m_AllocatedSpinlocks)
-    {
-      NdisFreeSpinLock (&p_Extension->m_QueueLock);
-      NdisFreeSpinLock (&p_Extension->m_InjectLock);
-    }
-}
-
-//========================================================================
-//                             Tap Device Initialization
-//========================================================================
-
-NDIS_STATUS
-CreateTapDevice (TapExtensionPointer p_Extension, const char *p_Name)
-{
-# define SIZEOF_DISPATCH (sizeof(PDRIVER_DISPATCH) * (IRP_MJ_MAXIMUM_FUNCTION + 1))
-  PDRIVER_DISPATCH *l_Dispatch = NULL;
-  ANSI_STRING l_TapString, l_LinkString;
-  UNICODE_STRING l_TapUnicode;
-  BOOLEAN l_FreeTapUnicode = FALSE;
-  NTSTATUS l_Status, l_Return = NDIS_STATUS_SUCCESS;
-  const char *l_UsableName;
-
-  DEBUGP (("[TAP] version [%d.%d] creating tap device: %s\n",
-	   TAP_DRIVER_MAJOR_VERSION,
-	   TAP_DRIVER_MINOR_VERSION,
-	   p_Name));
-
-  NdisZeroMemory (p_Extension, sizeof (TapExtension));
-
-  INIT_MUTEX (&p_Extension->m_OpenCloseMutex);
-
-  l_LinkString.Buffer = NULL;
-  l_TapString.Buffer = NULL;
-
-  l_TapString.MaximumLength = l_LinkString.MaximumLength = NAME_BUFFER_SIZE;
-
-  //=======================================
-  // Set TAP device entry points
-  //=======================================
-
-  if ((l_Dispatch = MemAlloc (SIZEOF_DISPATCH, TRUE)) == NULL)
-    {
-      DEBUGP (("[%s] couldn't alloc TAP dispatch table\n", p_Name));
-      l_Return = NDIS_STATUS_RESOURCES;
-      goto cleanup;
-    }
-
-  l_Dispatch[IRP_MJ_DEVICE_CONTROL] = TapDeviceHook;
-  l_Dispatch[IRP_MJ_READ] = TapDeviceHook;
-  l_Dispatch[IRP_MJ_WRITE] = TapDeviceHook;
-  l_Dispatch[IRP_MJ_CREATE] = TapDeviceHook;
-  l_Dispatch[IRP_MJ_CLOSE] = TapDeviceHook;
-
-  //==================================
-  // Find the beginning of the GUID
-  //==================================
-  l_UsableName = p_Name;
-  while (*l_UsableName != '{')
-    {
-      if (*l_UsableName == '\0')
-	{
-	  DEBUGP (("[%s] couldn't find leading '{' in name\n", p_Name));
-	  l_Return = NDIS_STATUS_RESOURCES;
-	  goto cleanup;
-	}
-      ++l_UsableName;
-    }
-
-  //==================================
-  // Allocate pool for TAP device name
-  //==================================
-
-  if ((p_Extension->m_TapName = l_TapString.Buffer =
-       MemAlloc (NAME_BUFFER_SIZE, TRUE)) == NULL)
-    {
-      DEBUGP (("[%s] couldn't alloc TAP name buffer\n", p_Name));
-      l_Return = NDIS_STATUS_RESOURCES;
-      goto cleanup;
-    }
-
-  //================================================
-  // Allocate pool for TAP symbolic link name buffer
-  //================================================
-
-  if ((l_LinkString.Buffer =
-       MemAlloc (NAME_BUFFER_SIZE, TRUE)) == NULL)
-    {
-      DEBUGP (("[%s] couldn't alloc TAP symbolic link name buffer\n",
-	       p_Name));
-      l_Return = NDIS_STATUS_RESOURCES;
-      goto cleanup;
-    }
-
-  //=======================================================
-  // Set TAP device name
-  //=======================================================
-
-  l_Status = RtlStringCchPrintfExA
-    (l_TapString.Buffer,
-     l_TapString.MaximumLength,
-     NULL,
-     NULL,
-     STRSAFE_FILL_BEHIND_NULL | STRSAFE_IGNORE_NULLS,
-     "%s%s%s",
-     SYSDEVICEDIR,
-     l_UsableName,
-     TAPSUFFIX);
-
-  if (l_Status != STATUS_SUCCESS)
-    {
-      DEBUGP (("[%s] couldn't format TAP device name\n",
-	       p_Name));
-      l_Return = NDIS_STATUS_RESOURCES;
-      goto cleanup;
-    }
-  l_TapString.Length = (USHORT) strlen (l_TapString.Buffer);
-
-  DEBUGP (("TAP DEV NAME: '%s'\n", l_TapString.Buffer));
-
-  //=======================================================
-  // Set TAP link name
-  //=======================================================
-
-  l_Status = RtlStringCchPrintfExA
-    (l_LinkString.Buffer,
-     l_LinkString.MaximumLength,
-     NULL,
-     NULL,
-     STRSAFE_FILL_BEHIND_NULL | STRSAFE_IGNORE_NULLS,
-     "%s%s%s",
-     USERDEVICEDIR,
-     l_UsableName,
-     TAPSUFFIX);
-
-  if (l_Status != STATUS_SUCCESS)
-    {
-      DEBUGP (("[%s] couldn't format TAP device symbolic link\n",
-	       p_Name));
-      l_Return = NDIS_STATUS_RESOURCES;
-      goto cleanup;
-    }
-  l_LinkString.Length = (USHORT) strlen (l_LinkString.Buffer);
-
-  DEBUGP (("TAP LINK NAME: '%s'\n", l_LinkString.Buffer));
-
-  //==================================================
-  // Convert strings to unicode
-  //==================================================
-  if (RtlAnsiStringToUnicodeString (&l_TapUnicode, &l_TapString, TRUE) !=
-      STATUS_SUCCESS)
-    {
-      DEBUGP (("[%s] couldn't alloc TAP unicode name buffer\n",
-		p_Name));
-      l_Return = NDIS_STATUS_RESOURCES;
-      goto cleanup;
-    }
-  l_FreeTapUnicode = TRUE;
-
-  if (RtlAnsiStringToUnicodeString
-      (&p_Extension->m_UnicodeLinkName, &l_LinkString, TRUE)
-      != STATUS_SUCCESS)
-    {
-      DEBUGP
-	(("[%s] Couldn't allocate unicode string for symbolic link name\n",
-	 p_Name));
-      l_Return = NDIS_STATUS_RESOURCES;
-      goto cleanup;
-    }
-  p_Extension->m_CreatedUnicodeLinkName = TRUE;
-
-  //==================================================
-  // Create new TAP device with symbolic
-  // link and associate with adapter.
-  //==================================================
-
-  l_Status = NdisMRegisterDevice
-    (g_NdisWrapperHandle,
-     &l_TapUnicode,
-     &p_Extension->m_UnicodeLinkName,
-     l_Dispatch,
-     &p_Extension->m_TapDevice,
-     &p_Extension->m_TapDeviceHandle
-     );
-
-  if (l_Status != STATUS_SUCCESS)
-    {
-      DEBUGP (("[%s] couldn't be created\n", p_Name));
-      l_Return = NDIS_STATUS_RESOURCES;
-      goto cleanup;
-    }
-
-  /* Set TAP device flags */
-  p_Extension->m_TapDevice->Flags |= DO_DIRECT_IO;
-
-  //========================================================
-  // Initialize Packet and IRP queues.
-  //
-  // The packet queue is used to buffer data which has been
-  // "transmitted" by the virtual NIC, before user space
-  // has had a chance to read it.
-  //
-  // The IRP queue is used to buffer pending I/O requests
-  // from userspace, i.e. read requests on the TAP device
-  // waiting for the system to "transmit" something through
-  // the virtual NIC.
-  //
-  // Basically, packets in the packet queue are used
-  // to satisfy IRP requests in the IRP queue.
-  //
-  // QueueLock is used to lock the packet queue used
-  // for the TAP-Win32 NIC -> User Space packet flow direction.
-  //
-  // All accesses to packet or IRP queues should be
-  // bracketed by the QueueLock spinlock,
-  // in order to be SMP-safe.
-  //========================================================
-
-  NdisAllocateSpinLock (&p_Extension->m_QueueLock);
-  NdisAllocateSpinLock (&p_Extension->m_InjectLock);
-  p_Extension->m_AllocatedSpinlocks = TRUE;
-
-  p_Extension->m_PacketQueue = QueueInit (PACKET_QUEUE_SIZE);
-  p_Extension->m_IrpQueue = QueueInit (IRP_QUEUE_SIZE);
-  p_Extension->m_InjectQueue = QueueInit (INJECT_QUEUE_SIZE);
-  if (!p_Extension->m_PacketQueue
-      || !p_Extension->m_IrpQueue
-      || !p_Extension->m_InjectQueue)
-    {
-      DEBUGP (("[%s] couldn't alloc TAP queues\n", p_Name));
-      l_Return = NDIS_STATUS_RESOURCES;
-      goto cleanup;
-    }
-
-  //=================================================================
-  // Initialize deferred procedure call for DHCP/ARP packet injection
-  //=================================================================
-
-  KeInitializeDpc (&p_Extension->m_InjectDpc, InjectPacketDpc, NULL);
-  p_Extension->m_InjectDpcInitialized = TRUE;
-
-  //========================
-  // Finalize initialization
-  //========================
-
-  p_Extension->m_TapIsRunning = TRUE;
-
-  DEBUGP (("[%s] successfully created TAP device [%s]\n", p_Name,
-	    p_Extension->m_TapName));
-
- cleanup:
-  if (l_FreeTapUnicode)
-    RtlFreeUnicodeString (&l_TapUnicode);
-  if (l_LinkString.Buffer)
-    MemFree (l_LinkString.Buffer, NAME_BUFFER_SIZE);
-  if (l_Dispatch)
-    MemFree (l_Dispatch, SIZEOF_DISPATCH);
-
-  if (l_Return != NDIS_STATUS_SUCCESS)
-    TapDeviceFreeResources (p_Extension);
-
-  return l_Return;
-}
-#undef SIZEOF_DISPATCH
-
-//========================================================
-//                      Adapter Control
-//========================================================
-NDIS_STATUS
-AdapterReset (OUT PBOOLEAN p_AddressingReset, IN NDIS_HANDLE p_AdapterContext)
-{
-  TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
-  DEBUGP (("[%s] is resetting\n", NAME (l_Adapter)));
-  return NDIS_STATUS_SUCCESS;
-}
-
-NDIS_STATUS AdapterReceive
-  (OUT PNDIS_PACKET p_Packet,
-   OUT PUINT p_Transferred,
-   IN NDIS_HANDLE p_AdapterContext,
-   IN NDIS_HANDLE p_ReceiveContext,
-   IN UINT p_Offset,
-   IN UINT p_ToTransfer)
-{
-  return NDIS_STATUS_SUCCESS;
-}
-
-//==============================================================
-//                  Adapter Option Query/Modification
-//==============================================================
-NDIS_STATUS AdapterQuery
-(IN NDIS_HANDLE p_AdapterContext,
- IN NDIS_OID p_OID,
- IN PVOID p_Buffer,
- IN ULONG p_BufferLength,
- OUT PULONG p_BytesWritten, OUT PULONG p_BytesNeeded)
-{
-  TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
-  TapAdapterQuery l_Query, *l_QueryPtr = &l_Query;
-  NDIS_STATUS l_Status = NDIS_STATUS_SUCCESS;
-  UINT l_QueryLength = 4;
-  BOOLEAN lock_succeeded;
-
-  NdisZeroMemory (&l_Query, sizeof (l_Query));
-
-  switch (p_OID)
-    {
-      //===================================================================
-      //                       Vendor & Driver version Info
-      //===================================================================
-    case OID_GEN_VENDOR_DESCRIPTION:
-      l_QueryPtr = (TapAdapterQueryPointer) PRODUCT_STRING;
-      l_QueryLength = strlen (PRODUCT_STRING) + 1;
-      break;
-
-    case OID_GEN_VENDOR_ID:
-      l_Query.m_Long = 0xffffff;
-      break;
-
-    case OID_GEN_DRIVER_VERSION:
-      l_Query.m_Short =
-	(((USHORT) TAP_NDIS_MAJOR_VERSION) << 8 | (USHORT)
-	 TAP_NDIS_MINOR_VERSION);
-      l_QueryLength = sizeof (unsigned short);
-      break;
-
-    case OID_GEN_VENDOR_DRIVER_VERSION:
-      l_Query.m_Long =
-	(((USHORT) TAP_DRIVER_MAJOR_VERSION) << 8 | (USHORT)
-	 TAP_DRIVER_MINOR_VERSION);
-      break;
-
-      //=================================================================
-      //                             Statistics
-      //=================================================================
-    case OID_GEN_RCV_NO_BUFFER:
-      l_Query.m_Long = 0;
-      break;
-
-    case OID_802_3_RCV_ERROR_ALIGNMENT:
-      l_Query.m_Long = 0;
-      break;
-
-    case OID_802_3_XMIT_ONE_COLLISION:
-      l_Query.m_Long = 0;
-      break;
-
-    case OID_802_3_XMIT_MORE_COLLISIONS:
-      l_Query.m_Long = 0;
-      break;
-
-    case OID_GEN_XMIT_OK:
-      l_Query.m_Long = l_Adapter->m_Tx;
-      break;
-
-    case OID_GEN_RCV_OK:
-      l_Query.m_Long = l_Adapter->m_Rx;
-      break;
-
-    case OID_GEN_XMIT_ERROR:
-      l_Query.m_Long = l_Adapter->m_TxErr;
-      break;
-
-    case OID_GEN_RCV_ERROR:
-      l_Query.m_Long = l_Adapter->m_RxErr;
-      break;
-
-      //===================================================================
-      //                       Device & Protocol Options
-      //===================================================================
-    case OID_GEN_SUPPORTED_LIST:
-      l_QueryPtr = (TapAdapterQueryPointer) g_SupportedOIDList;
-      l_QueryLength = sizeof (g_SupportedOIDList);
-      break;
-
-    case OID_GEN_MAC_OPTIONS:
-      // This MUST be here !!!
-      l_Query.m_Long = (NDIS_MAC_OPTION_RECEIVE_SERIALIZED
-			| NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA
-			| NDIS_MAC_OPTION_NO_LOOPBACK
-			| NDIS_MAC_OPTION_TRANSFERS_NOT_PEND);
-
-      break;
-
-    case OID_GEN_CURRENT_PACKET_FILTER:
-      l_Query.m_Long =
-	(NDIS_PACKET_TYPE_ALL_LOCAL |
-	 NDIS_PACKET_TYPE_BROADCAST |
-	 NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_ALL_FUNCTIONAL);
-
-      break;
-
-    case OID_GEN_PROTOCOL_OPTIONS:
-      l_Query.m_Long = 0;
-      break;
-
-      //==================================================================
-      //                            Device Info
-      //==================================================================
-    case OID_GEN_MEDIA_CONNECT_STATUS:
-      l_Query.m_Long = l_Adapter->m_MediaState
-	? NdisMediaStateConnected : NdisMediaStateDisconnected;
-      break;
-
-    case OID_GEN_HARDWARE_STATUS:
-      l_Query.m_HardwareStatus = NdisHardwareStatusReady;
-      l_QueryLength = sizeof (NDIS_HARDWARE_STATUS);
-      break;
-
-    case OID_GEN_MEDIA_SUPPORTED:
-    case OID_GEN_MEDIA_IN_USE:
-      l_Query.m_Medium = l_Adapter->m_Medium;
-      l_QueryLength = sizeof (NDIS_MEDIUM);
-      break;
-
-    case OID_GEN_PHYSICAL_MEDIUM:
-      l_Query.m_PhysicalMedium = NdisPhysicalMediumUnspecified;
-      l_QueryLength = sizeof (NDIS_PHYSICAL_MEDIUM);
-      break;
-      
-    case OID_GEN_LINK_SPEED:
-      l_Query.m_Long = 100000; // rate / 100 bps
-      break;
-
-    case OID_802_3_PERMANENT_ADDRESS:
-    case OID_802_3_CURRENT_ADDRESS:
-      COPY_MAC (l_Query.m_MacAddress, l_Adapter->m_MAC);
-      l_QueryLength = sizeof (MACADDR);
-      break;
-
-      //==================================================================
-      //                             Limits
-      //==================================================================
-
-    case OID_GEN_MAXIMUM_SEND_PACKETS:
-      l_Query.m_Long = 1;
-      break;
-
-    case OID_802_3_MAXIMUM_LIST_SIZE:
-      l_Query.m_Long = NIC_MAX_MCAST_LIST;
-      break;
-
-    case OID_GEN_CURRENT_LOOKAHEAD:
-      l_Query.m_Long = l_Adapter->m_Lookahead;
-      break;
-
-    case OID_GEN_MAXIMUM_LOOKAHEAD:
-    case OID_GEN_MAXIMUM_TOTAL_SIZE:
-    case OID_GEN_RECEIVE_BUFFER_SPACE:
-    case OID_GEN_RECEIVE_BLOCK_SIZE:
-      l_Query.m_Long = DEFAULT_PACKET_LOOKAHEAD;
-      break;
-
-    case OID_GEN_MAXIMUM_FRAME_SIZE:
-    case OID_GEN_TRANSMIT_BLOCK_SIZE:
-    case OID_GEN_TRANSMIT_BUFFER_SPACE:
-      l_Query.m_Long = l_Adapter->m_MTU;
-      break;
-
-    case OID_PNP_CAPABILITIES:
-      do
-	{
-	  PNDIS_PNP_CAPABILITIES pPNPCapabilities;
-	  PNDIS_PM_WAKE_UP_CAPABILITIES pPMstruct;
-
-	  if (p_BufferLength >= sizeof (NDIS_PNP_CAPABILITIES))
-	    {
-	      pPNPCapabilities = (PNDIS_PNP_CAPABILITIES) (p_Buffer);
-
-	      //
-	      // Setting up the buffer to be returned
-	      // to the Protocol above the Passthru miniport
-	      //
-	      pPMstruct = &pPNPCapabilities->WakeUpCapabilities;
-	      pPMstruct->MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
-	      pPMstruct->MinPatternWakeUp = NdisDeviceStateUnspecified;
-	      pPMstruct->MinLinkChangeWakeUp = NdisDeviceStateUnspecified;
-	    }
-	  l_QueryLength = sizeof (NDIS_PNP_CAPABILITIES);
-	}
-      while (FALSE);
-      break;
-    case OID_PNP_QUERY_POWER:
-      break;
-
-      // Required OIDs that we don't support
-
-    case OID_GEN_SUPPORTED_GUIDS:
-    case OID_GEN_MEDIA_CAPABILITIES:
-    case OID_TCP_TASK_OFFLOAD:
-    case OID_FFP_SUPPORT:
-      l_Status = NDIS_STATUS_INVALID_OID;
-      break;
-
-      // Optional stats OIDs
-
-    case OID_GEN_DIRECTED_BYTES_XMIT:
-    case OID_GEN_DIRECTED_FRAMES_XMIT:
-    case OID_GEN_MULTICAST_BYTES_XMIT:
-    case OID_GEN_MULTICAST_FRAMES_XMIT:
-    case OID_GEN_BROADCAST_BYTES_XMIT:
-    case OID_GEN_BROADCAST_FRAMES_XMIT:
-    case OID_GEN_DIRECTED_BYTES_RCV:
-    case OID_GEN_DIRECTED_FRAMES_RCV:
-    case OID_GEN_MULTICAST_BYTES_RCV:
-    case OID_GEN_MULTICAST_FRAMES_RCV:
-    case OID_GEN_BROADCAST_BYTES_RCV:
-    case OID_GEN_BROADCAST_FRAMES_RCV:
-      l_Status = NDIS_STATUS_INVALID_OID;
-      break;
-
-      //===================================================================
-      //                          Not Handled
-      //===================================================================
-    default:
-      DEBUGP (("[%s] Unhandled OID %lx\n", NAME (l_Adapter), p_OID));
-      l_Status = NDIS_STATUS_INVALID_OID;
-      break;
-    }
-
-  if (l_Status != NDIS_STATUS_SUCCESS)
-    ;
-  else if (l_QueryLength > p_BufferLength)
-    {
-      l_Status = NDIS_STATUS_INVALID_LENGTH;
-      *p_BytesNeeded = l_QueryLength;
-    }
-  else
-    NdisMoveMemory (p_Buffer, (PVOID) l_QueryPtr,
-		    (*p_BytesWritten = l_QueryLength));
-
-  return l_Status;
-}
-
-NDIS_STATUS AdapterModify
-(IN NDIS_HANDLE p_AdapterContext,
- IN NDIS_OID p_OID,
- IN PVOID p_Buffer,
- IN ULONG p_BufferLength,
- OUT PULONG p_BytesRead,
- OUT PULONG p_BytesNeeded)
-{
-  TapAdapterQueryPointer l_Query = (TapAdapterQueryPointer) p_Buffer;
-  TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
-  NDIS_STATUS l_Status = NDIS_STATUS_INVALID_OID;
-  ULONG l_Long;
-
-  switch (p_OID)
-    {
-      //==================================================================
-      //                            Device Info
-      //==================================================================
-    case OID_802_3_MULTICAST_LIST:
-      DEBUGP (("[%s] Setting [OID_802_3_MULTICAST_LIST]\n",
-	       NAME (l_Adapter)));
-
-      *p_BytesNeeded = sizeof (ETH_ADDR);
-      *p_BytesRead = p_BufferLength;
-
-      if (p_BufferLength % sizeof (ETH_ADDR))
-	l_Status = NDIS_STATUS_INVALID_LENGTH;
-      else if (p_BufferLength > sizeof (MC_LIST))
-	{
-	  l_Status = NDIS_STATUS_MULTICAST_FULL;
-	  *p_BytesNeeded = sizeof (MC_LIST);
-	}
-      else
-	{
-	  NdisAcquireSpinLock (&l_Adapter->m_MCLock);
-
-	  NdisZeroMemory(&l_Adapter->m_MCList, sizeof (MC_LIST));
-        
-	  NdisMoveMemory(&l_Adapter->m_MCList,
-			 p_Buffer,
-			 p_BufferLength);
-
-	  l_Adapter->m_MCListSize = p_BufferLength / sizeof (ETH_ADDR);
-        
-	  NdisReleaseSpinLock (&l_Adapter->m_MCLock);
-
-	  l_Status = NDIS_STATUS_SUCCESS;
-	}
-      break;
-
-    case OID_GEN_CURRENT_PACKET_FILTER:
-      l_Status = NDIS_STATUS_INVALID_LENGTH;
-      *p_BytesNeeded = 4;
-
-      if (p_BufferLength >= sizeof (ULONG))
-	{
-	  DEBUGP
-	    (("[%s] Setting [OID_GEN_CURRENT_PACKET_FILTER] to [0x%02lx]\n",
-	      NAME (l_Adapter), l_Query->m_Long));
-	  l_Status = NDIS_STATUS_SUCCESS;
-	  *p_BytesRead = sizeof (ULONG);
-	}
-      break;
-
-    case OID_GEN_CURRENT_LOOKAHEAD:
-      if (p_BufferLength < sizeof (ULONG))
-	{
-	  l_Status = NDIS_STATUS_INVALID_LENGTH;
-	  *p_BytesNeeded = 4;
-	}
-      else if (l_Query->m_Long > DEFAULT_PACKET_LOOKAHEAD
-	       || l_Query->m_Long <= 0)
-	{
-	  l_Status = NDIS_STATUS_INVALID_DATA;
-	}
-      else
-	{
-	  DEBUGP (("[%s] Setting [OID_GEN_CURRENT_LOOKAHEAD] to [%d]\n",
-		   NAME (l_Adapter), l_Query->m_Long));
-	  l_Adapter->m_Lookahead = l_Query->m_Long;
-	  l_Status = NDIS_STATUS_SUCCESS;
-	  *p_BytesRead = sizeof (ULONG);
-	}
-      break;
-
-    case OID_GEN_NETWORK_LAYER_ADDRESSES:
-      l_Status = NDIS_STATUS_SUCCESS;
-      *p_BytesRead = *p_BytesNeeded = 0;
-      break;
-
-    case OID_GEN_TRANSPORT_HEADER_OFFSET:
-      l_Status = NDIS_STATUS_SUCCESS;
-      *p_BytesRead = *p_BytesNeeded = 0;
-      break;
-
-    case OID_PNP_SET_POWER:
-      do
-	{
-	  NDIS_DEVICE_POWER_STATE NewDeviceState;
-
-	  NewDeviceState = (*(PNDIS_DEVICE_POWER_STATE) p_Buffer);
-
-	  switch (NewDeviceState)
-	    {
-	    case NdisDeviceStateD0:
-	      l_Adapter->m_DeviceState = '0';
-	      break;
-	    case NdisDeviceStateD1:
-	      l_Adapter->m_DeviceState = '1';
-	      break;
-	    case NdisDeviceStateD2:
-	      l_Adapter->m_DeviceState = '2';
-	      break;
-	    case NdisDeviceStateD3:
-	      l_Adapter->m_DeviceState = '3';
-	      break;
-	    default:
-	      l_Adapter->m_DeviceState = '?';
-	      break;
-	    }
-
-	  l_Status = NDIS_STATUS_FAILURE;
-
-	  //
-	  // Check for invalid length
-	  //
-	  if (p_BufferLength < sizeof (NDIS_DEVICE_POWER_STATE))
-	    {
-	      l_Status = NDIS_STATUS_INVALID_LENGTH;
-	      break;
-	    }
-
-	  if (NewDeviceState > NdisDeviceStateD0)
-	    {
-	      l_Adapter->m_InterfaceIsRunning = FALSE;
-	      DEBUGP (("[%s] Power management device state OFF\n",
-		       NAME (l_Adapter)));
-	    }
-	  else
-	    {
-	      l_Adapter->m_InterfaceIsRunning = TRUE;
-	      DEBUGP (("[%s] Power management device state ON\n",
-		       NAME (l_Adapter)));
-	    }
-
-	  l_Status = NDIS_STATUS_SUCCESS;
-	}
-      while (FALSE);
-
-      if (l_Status == NDIS_STATUS_SUCCESS)
-	{
-	  *p_BytesRead = sizeof (NDIS_DEVICE_POWER_STATE);
-	  *p_BytesNeeded = 0;
-	}
-      else
-	{
-	  *p_BytesRead = 0;
-	  *p_BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE);
-	}
-      break;
-
-    case OID_PNP_REMOVE_WAKE_UP_PATTERN:
-    case OID_PNP_ADD_WAKE_UP_PATTERN:
-      l_Status = NDIS_STATUS_SUCCESS;
-      *p_BytesRead = *p_BytesNeeded = 0;
-      break;
-
-    default:
-      DEBUGP (("[%s] Can't set value for OID %lx\n", NAME (l_Adapter),
-	       p_OID));
-      l_Status = NDIS_STATUS_INVALID_OID;
-      *p_BytesRead = *p_BytesNeeded = 0;
-      break;
-    }
-
-  return l_Status;
-}
-
-//====================================================================
-//                               Adapter Transmission
-//====================================================================
-NDIS_STATUS
-AdapterTransmit (IN NDIS_HANDLE p_AdapterContext,
-		 IN PNDIS_PACKET p_Packet,
-		 IN UINT p_Flags)
-{
-  TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
-  ULONG l_Index = 0, l_PacketLength = 0;
-  UINT l_BufferLength = 0;
-  PIRP l_IRP;
-  TapPacketPointer l_PacketBuffer;
-  PNDIS_BUFFER l_NDIS_Buffer;
-  PUCHAR l_Buffer;
-  PVOID result;
-
-  NdisQueryPacket (p_Packet, NULL, NULL, &l_NDIS_Buffer, &l_PacketLength);
-
-  //====================================================
-  // Here we abandon the transmission attempt if any of
-  // the parameters is wrong or memory allocation fails
-  // but we do not indicate failure. The packet is
-  // silently dropped.
-  //====================================================
-
-  if (l_PacketLength < ETHERNET_HEADER_SIZE || l_PacketLength > 65535)
-    goto exit_fail;
-  else if (!l_Adapter->m_Extension.m_TapOpens || !l_Adapter->m_MediaState)
-    goto exit_success;              // Nothing is bound to the TAP device
-
-  if (NdisAllocateMemoryWithTag (&l_PacketBuffer,
-				 TAP_PACKET_SIZE (l_PacketLength),
-				 '5PAT') != NDIS_STATUS_SUCCESS)
-    goto exit_no_resources;
-
-  if (l_PacketBuffer == NULL)
-    goto exit_no_resources;
-
-  l_PacketBuffer->m_SizeFlags = (l_PacketLength & TP_SIZE_MASK);
-
-  //===========================
-  // Reassemble packet contents
-  //===========================
-
-  __try
-  {
-    l_Index = 0;
-    while (l_NDIS_Buffer && l_Index < l_PacketLength)
-      {
-	ULONG newlen;
-	NdisQueryBuffer (l_NDIS_Buffer, (PVOID *) & l_Buffer,
-			 &l_BufferLength);
-	newlen = l_Index + l_BufferLength;
-	if (newlen > l_PacketLength)
-	  {
-	    NOTE_ERROR ();
-	    goto no_queue; /* overflow */
-	  }
-	NdisMoveMemory (l_PacketBuffer->m_Data + l_Index, l_Buffer,
-			l_BufferLength);
-	l_Index = newlen;
-	NdisGetNextBuffer (l_NDIS_Buffer, &l_NDIS_Buffer);
-      }
-    if (l_Index != l_PacketLength)
-      {
-	NOTE_ERROR ();
-	goto no_queue; /* underflow */
-      }
-
-    DUMP_PACKET ("AdapterTransmit", l_PacketBuffer->m_Data, l_PacketLength);
-
-    //=====================================================
-    // If IPv4 packet, check whether or not packet
-    // was truncated.
-    //=====================================================
-#if PACKET_TRUNCATION_CHECK
-    IPv4PacketSizeVerify (l_PacketBuffer->m_Data, l_PacketLength, FALSE, "TX", &l_Adapter->m_TxTrunc);
-#endif
-
-    //=====================================================
-    // Are we running in DHCP server masquerade mode?
-    //
-    // If so, catch both DHCP requests and ARP queries
-    // to resolve the address of our virtual DHCP server.
-    //=====================================================
-    if (l_Adapter->m_dhcp_enabled)
-      {
-	const ETH_HEADER *eth = (ETH_HEADER *) l_PacketBuffer->m_Data;
-	const IPHDR *ip = (IPHDR *) (l_PacketBuffer->m_Data + sizeof (ETH_HEADER));
-	const UDPHDR *udp = (UDPHDR *) (l_PacketBuffer->m_Data + sizeof (ETH_HEADER) + sizeof (IPHDR));
-
-	// ARP packet?
-	if (l_PacketLength == sizeof (ARP_PACKET)
-	    && eth->proto == htons (ETH_P_ARP)
-	    && l_Adapter->m_dhcp_server_arp)
-	  {
-	    if (ProcessARP (l_Adapter,
-			    (PARP_PACKET) l_PacketBuffer->m_Data,
-			    l_Adapter->m_dhcp_addr,
-			    l_Adapter->m_dhcp_server_ip,
-			    ~0,
-			    l_Adapter->m_dhcp_server_mac))
-	      goto no_queue;
-	  }
-
-	// DHCP packet?
-	else if (l_PacketLength >= sizeof (ETH_HEADER) + sizeof (IPHDR) + sizeof (UDPHDR) + sizeof (DHCP)
-		 && eth->proto == htons (ETH_P_IP)
-		 && ip->version_len == 0x45 // IPv4, 20 byte header
-		 && ip->protocol == IPPROTO_UDP
-		 && udp->dest == htons (BOOTPS_PORT))
-	  {
-	    const DHCP *dhcp = (DHCP *) (l_PacketBuffer->m_Data
-					 + sizeof (ETH_HEADER)
-					 + sizeof (IPHDR)
-					 + sizeof (UDPHDR));
-
-	    const int optlen = l_PacketLength
-	      - sizeof (ETH_HEADER)
-	      - sizeof (IPHDR)
-	      - sizeof (UDPHDR)
-	      - sizeof (DHCP);
-
-	    if (optlen > 0) // we must have at least one DHCP option
-	      {
-		if (ProcessDHCP (l_Adapter, eth, ip, udp, dhcp, optlen))
-		  goto no_queue;
-	      }
-	    else
-	      goto no_queue;
-	  }
-      }
-
-    //===============================================
-    // In Point-To-Point mode, check to see whether
-    // packet is ARP or IPv4 (if neither, then drop).
-    //===============================================
-    if (l_Adapter->m_tun)
-      {
-	ETH_HEADER *e;
-
-	if (l_PacketLength < ETHERNET_HEADER_SIZE)
-	  goto no_queue;
-
-	e = (ETH_HEADER *) l_PacketBuffer->m_Data;
-
-	switch (ntohs (e->proto))
-	  {
-	  case ETH_P_ARP:
-
-	    // Make sure that packet is the
-	    // right size for ARP.
-	    if (l_PacketLength != sizeof (ARP_PACKET))
-	      goto no_queue;
-
-	    ProcessARP (l_Adapter,
-			(PARP_PACKET) l_PacketBuffer->m_Data,
-			l_Adapter->m_localIP,
-			l_Adapter->m_remoteNetwork,
-			l_Adapter->m_remoteNetmask,
-			l_Adapter->m_TapToUser.dest);
-
-	  default:
-	    goto no_queue;
-
-	  case ETH_P_IP:
-
-	    // Make sure that packet is large
-	    // enough to be IPv4.
-	    if (l_PacketLength
-		< ETHERNET_HEADER_SIZE + IP_HEADER_SIZE)
-	      goto no_queue;
-
-	    // Only accept directed packets,
-	    // not broadcasts.
-	    if (memcmp (e, &l_Adapter->m_TapToUser, ETHERNET_HEADER_SIZE))
-	      goto no_queue;
-
-	    // Packet looks like IPv4, queue it.
-	    l_PacketBuffer->m_SizeFlags |= TP_TUN;
-	  }
-      }
-
-    //===============================================
-    // Push packet onto queue to wait for read from
-    // userspace.
-    //===============================================
-
-    NdisAcquireSpinLock (&l_Adapter->m_Extension.m_QueueLock);
-
-    result = NULL;
-    if (IS_UP (l_Adapter))
-      result = QueuePush (l_Adapter->m_Extension.m_PacketQueue, l_PacketBuffer);
-
-    NdisReleaseSpinLock (&l_Adapter->m_Extension.m_QueueLock);
-
-    if ((TapPacketPointer) result != l_PacketBuffer)
-      {
-	// adapter receive overrun
-	INCREMENT_STAT (l_Adapter->m_TxErr);
-	goto no_queue;
-      }
-    else
-      {
-	INCREMENT_STAT (l_Adapter->m_Tx);
-      }
-
-    //============================================================
-    // Cycle through IRPs and packets, try to satisfy each pending
-    // IRP with a queued packet.
-    //============================================================
-    while (TRUE)
-      {
-	l_IRP = NULL;
-	l_PacketBuffer = NULL;
-
-	NdisAcquireSpinLock (&l_Adapter->m_Extension.m_QueueLock);
-
-	if (IS_UP (l_Adapter)
-	    && QueueCount (l_Adapter->m_Extension.m_PacketQueue)
-	    && QueueCount (l_Adapter->m_Extension.m_IrpQueue))
-	  {
-	    l_IRP = (PIRP) QueuePop (l_Adapter->m_Extension.m_IrpQueue);
-	    l_PacketBuffer = (TapPacketPointer)
-	      QueuePop (l_Adapter->m_Extension.m_PacketQueue);
-	  }
-
-	NdisReleaseSpinLock (&l_Adapter->m_Extension.m_QueueLock);
-
-	MYASSERT ((l_IRP != NULL) + (l_PacketBuffer != NULL) != 1);
-
-	if (l_IRP && l_PacketBuffer)
-	  {
-	    CompleteIRP (l_IRP,
-			 l_PacketBuffer, 
-			 IO_NETWORK_INCREMENT);
-	  }
-	else
-	  break;
-      }
-  }
-  __except (EXCEPTION_EXECUTE_HANDLER)
-    {
-    }
-
-  return NDIS_STATUS_SUCCESS;
-
- no_queue:
-  NdisFreeMemory (l_PacketBuffer,
-		  TAP_PACKET_SIZE (l_PacketLength),
-		  0);
-  
- exit_success:
-  return NDIS_STATUS_SUCCESS;
-    
- exit_fail:
-  return NDIS_STATUS_FAILURE;
-
- exit_no_resources:
-  return NDIS_STATUS_RESOURCES;
-}
-
-//======================================================================
-// Hooks for catching TAP device IRP's.
-//======================================================================
-
-NTSTATUS
-TapDeviceHook (IN PDEVICE_OBJECT p_DeviceObject, IN PIRP p_IRP)
-{
-  TapAdapterPointer l_Adapter = LookupAdapterInInstanceList (p_DeviceObject);
-  PIO_STACK_LOCATION l_IrpSp;
-  NTSTATUS l_Status = STATUS_SUCCESS;
-  BOOLEAN accessible;
-
-  l_IrpSp = IoGetCurrentIrpStackLocation (p_IRP);
-
-  p_IRP->IoStatus.Status = STATUS_SUCCESS;
-  p_IRP->IoStatus.Information = 0;
-
-  if (!l_Adapter || l_Adapter->m_Extension.m_Halt)
-    {
-      DEBUGP (("TapDeviceHook called when TAP device is halted, MajorFunction=%d\n",
-	       (int)l_IrpSp->MajorFunction));
-
-      if (l_IrpSp->MajorFunction == IRP_MJ_CLOSE)
-	{
-	  IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	  return STATUS_SUCCESS;
-	}
-      else
-	{
-	  p_IRP->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
-	  IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	  return STATUS_NO_SUCH_DEVICE;
-	}
-    }
-
-  switch (l_IrpSp->MajorFunction)
-    {
-      //===========================================================
-      //                 Ioctl call handlers
-      //===========================================================
-    case IRP_MJ_DEVICE_CONTROL:
-      {
-	switch (l_IrpSp->Parameters.DeviceIoControl.IoControlCode)
-	  {
-	  case TAP_IOCTL_GET_MAC:
-	    {
-	      if (l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength
-		  >= sizeof (MACADDR))
-		{
-		  COPY_MAC (p_IRP->AssociatedIrp.SystemBuffer,
-			    l_Adapter->m_MAC);
-		  p_IRP->IoStatus.Information = sizeof (MACADDR);
-		}
-	      else
-		{
-		  NOTE_ERROR ();
-		  p_IRP->IoStatus.Status = l_Status = STATUS_BUFFER_TOO_SMALL;
-		}
-	      break;
-	    }
-	  case TAP_IOCTL_GET_VERSION:
-	    {
-	      const ULONG size = sizeof (ULONG) * 3;
-	      if (l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength
-		  >= size)
-		{
-		  ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[0]
-		    = TAP_DRIVER_MAJOR_VERSION;
-		  ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[1]
-		    = TAP_DRIVER_MINOR_VERSION;
-		  ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[2]
-#if DBG
-		    = 1;
-#else
-		  = 0;
-#endif
-		  p_IRP->IoStatus.Information = size;
-		}
-	      else
-		{
-		  NOTE_ERROR ();
-		  p_IRP->IoStatus.Status = l_Status = STATUS_BUFFER_TOO_SMALL;
-		}
-
-	      break;
-	    }
-	  case TAP_IOCTL_GET_MTU:
-	    {
-	      const ULONG size = sizeof (ULONG) * 1;
-	      if (l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength
-		  >= size)
-		{
-		  ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[0]
-		    = l_Adapter->m_MTU;
-		  p_IRP->IoStatus.Information = size;
-		}
-	      else
-		{
-		  NOTE_ERROR ();
-		  p_IRP->IoStatus.Status = l_Status = STATUS_BUFFER_TOO_SMALL;
-		}
-
-	      break;
-	    }
-	  case TAP_IOCTL_GET_INFO:
-	    {
-	      char state[16];
-	      if (l_Adapter->m_InterfaceIsRunning)
-		state[0] = 'A';
-	      else
-		state[0] = 'a';
-	      if (l_Adapter->m_Extension.m_TapIsRunning)
-		state[1] = 'T';
-	      else
-		state[1] = 't';
-	      state[2] = l_Adapter->m_DeviceState;
-	      if (l_Adapter->m_MediaStateAlwaysConnected)
-		state[3] = 'C';
-	      else
-		state[3] = 'c';
-	      state[4] = '\0';
-
-	      p_IRP->IoStatus.Status = l_Status = RtlStringCchPrintfExA (
-	        ((LPTSTR) (p_IRP->AssociatedIrp.SystemBuffer)),
-		l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
-		NULL,
-		NULL,
-		STRSAFE_FILL_BEHIND_NULL | STRSAFE_IGNORE_NULLS,
-#if PACKET_TRUNCATION_CHECK
-		"State=%s Err=[%s/%d] #O=%d Tx=[%d,%d,%d] Rx=[%d,%d,%d] IrpQ=[%d,%d,%d] PktQ=[%d,%d,%d] InjQ=[%d,%d,%d]",
-#else
-		"State=%s Err=[%s/%d] #O=%d Tx=[%d,%d] Rx=[%d,%d] IrpQ=[%d,%d,%d] PktQ=[%d,%d,%d] InjQ=[%d,%d,%d]",
-#endif
-		state,
-		g_LastErrorFilename,
-		g_LastErrorLineNumber,
-		(int)l_Adapter->m_Extension.m_NumTapOpens,
-		(int)l_Adapter->m_Tx,
-		(int)l_Adapter->m_TxErr,
-#if PACKET_TRUNCATION_CHECK
-		(int)l_Adapter->m_TxTrunc,
-#endif
-		(int)l_Adapter->m_Rx,
-		(int)l_Adapter->m_RxErr,
-#if PACKET_TRUNCATION_CHECK
-		(int)l_Adapter->m_RxTrunc,
-#endif
-		(int)l_Adapter->m_Extension.m_IrpQueue->size,
-		(int)l_Adapter->m_Extension.m_IrpQueue->max_size,
-		(int)IRP_QUEUE_SIZE,
-		(int)l_Adapter->m_Extension.m_PacketQueue->size,
-		(int)l_Adapter->m_Extension.m_PacketQueue->max_size,
-		(int)PACKET_QUEUE_SIZE,
-		(int)l_Adapter->m_Extension.m_InjectQueue->size,
-		(int)l_Adapter->m_Extension.m_InjectQueue->max_size,
-		(int)INJECT_QUEUE_SIZE
-		);
-
-	      p_IRP->IoStatus.Information
-		= l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
-
-	      break;
-	    }
-
-#if DBG
-	  case TAP_IOCTL_GET_LOG_LINE:
-	    {
-	      if (GetDebugLine ((LPTSTR)p_IRP->AssociatedIrp.SystemBuffer,
-				l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength))
-		p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;
-	      else
-		p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-
-	      p_IRP->IoStatus.Information
-		= l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
-
-	      break;
-	    }
-#endif
-
-	  case TAP_IOCTL_CONFIG_TUN:
-	    {
-	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
-		  (sizeof (IPADDR) * 3))
-		{
-		  MACADDR dest;
-
-		  l_Adapter->m_tun = FALSE;
-
-		  GenerateRelatedMAC (dest, l_Adapter->m_MAC, 1);
-
-		  l_Adapter->m_localIP =       ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[0];
-		  l_Adapter->m_remoteNetwork = ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[1];
-		  l_Adapter->m_remoteNetmask = ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[2];
-
-		  // sanity check on network/netmask
-		  if ((l_Adapter->m_remoteNetwork & l_Adapter->m_remoteNetmask) != l_Adapter->m_remoteNetwork)
-		    {
-		      NOTE_ERROR ();
-		      p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;
-		      break;
-		    }
-
-		  COPY_MAC (l_Adapter->m_TapToUser.src, l_Adapter->m_MAC);
-		  COPY_MAC (l_Adapter->m_TapToUser.dest, dest);
-		  COPY_MAC (l_Adapter->m_UserToTap.src, dest);
-		  COPY_MAC (l_Adapter->m_UserToTap.dest, l_Adapter->m_MAC);
-
-		  l_Adapter->m_TapToUser.proto = l_Adapter->m_UserToTap.proto = htons (ETH_P_IP);
-
-		  l_Adapter->m_tun = TRUE;
-
-		  CheckIfDhcpAndTunMode (l_Adapter);
-
-		  p_IRP->IoStatus.Information = 1; // Simple boolean value
-		}
-	      else
-		{
-		  NOTE_ERROR ();
-		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;
-		}
-	      
-	      break;
-	    }
-
-	  case TAP_IOCTL_CONFIG_POINT_TO_POINT: // Obsoleted by TAP_IOCTL_CONFIG_TUN
-	    {
-	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
-		  (sizeof (IPADDR) * 2))
-		{
-		  MACADDR dest;
-
-		  l_Adapter->m_tun = FALSE;
-
-		  GenerateRelatedMAC (dest, l_Adapter->m_MAC, 1);
-
-		  l_Adapter->m_localIP =       ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[0];
-		  l_Adapter->m_remoteNetwork = ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[1];
-		  l_Adapter->m_remoteNetmask = ~0;
-
-		  COPY_MAC (l_Adapter->m_TapToUser.src, l_Adapter->m_MAC);
-		  COPY_MAC (l_Adapter->m_TapToUser.dest, dest);
-		  COPY_MAC (l_Adapter->m_UserToTap.src, dest);
-		  COPY_MAC (l_Adapter->m_UserToTap.dest, l_Adapter->m_MAC);
-
-		  l_Adapter->m_TapToUser.proto = l_Adapter->m_UserToTap.proto = htons (ETH_P_IP);
-
-		  l_Adapter->m_tun = TRUE;
-
-		  CheckIfDhcpAndTunMode (l_Adapter);
-
-		  p_IRP->IoStatus.Information = 1; // Simple boolean value
-		}
-	      else
-		{
-		  NOTE_ERROR ();
-		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;
-		}
-	      
-	      break;
-	    }
-
-	  case TAP_IOCTL_SET_MEDIA_STATUS:
-	    {
-	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
-		  (sizeof (ULONG) * 1))
-		{
-		  ULONG parm = ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[0];
-		  SetMediaStatus (l_Adapter, (BOOLEAN) parm);
-		  p_IRP->IoStatus.Information = 1;
-		}
-	      else
-		{
-		  NOTE_ERROR ();
-		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;
-		}
-	      break;
-	    }
-
-	  case TAP_IOCTL_CONFIG_DHCP_MASQ:
-	    {
-	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
-		  (sizeof (IPADDR) * 4))
-		{
-		  l_Adapter->m_dhcp_enabled = FALSE;
-		  l_Adapter->m_dhcp_server_arp = FALSE;
-		  l_Adapter->m_dhcp_user_supplied_options_buffer_len = 0;
-
-		  // Adapter IP addr / netmask
-		  l_Adapter->m_dhcp_addr =
-		    ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[0];
-		  l_Adapter->m_dhcp_netmask =
-		    ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[1];
-
-		  // IP addr of DHCP masq server
-		  l_Adapter->m_dhcp_server_ip =
-		    ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[2];
-
-		  // Lease time in seconds
-		  l_Adapter->m_dhcp_lease_time =
-		    ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[3];
-
-		  GenerateRelatedMAC (l_Adapter->m_dhcp_server_mac, l_Adapter->m_MAC, 2);
-
-		  l_Adapter->m_dhcp_enabled = TRUE;
-		  l_Adapter->m_dhcp_server_arp = TRUE;
-
-		  CheckIfDhcpAndTunMode (l_Adapter);
-
-		  p_IRP->IoStatus.Information = 1; // Simple boolean value
-		}
-	      else
-		{
-		  NOTE_ERROR ();
-		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;
-		}
-	      
-	      break;
-	    }
-
-	  case TAP_IOCTL_CONFIG_DHCP_SET_OPT:
-	    {
-	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength <=
-		  DHCP_USER_SUPPLIED_OPTIONS_BUFFER_SIZE
-		  && l_Adapter->m_dhcp_enabled)
-		{
-		  l_Adapter->m_dhcp_user_supplied_options_buffer_len = 0;
-
-		  NdisMoveMemory (l_Adapter->m_dhcp_user_supplied_options_buffer,
-				  p_IRP->AssociatedIrp.SystemBuffer,
-				  l_IrpSp->Parameters.DeviceIoControl.InputBufferLength);
-		  
-		  l_Adapter->m_dhcp_user_supplied_options_buffer_len = 
-		    l_IrpSp->Parameters.DeviceIoControl.InputBufferLength;
-
-		  p_IRP->IoStatus.Information = 1; // Simple boolean value
-		}
-	      else
-		{
-		  NOTE_ERROR ();
-		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;
-		}
-	      
-	      break;
-	    }
-
-	  default:
-	    {
-	      NOTE_ERROR ();
-	      p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;
-	      break;
-	    }
-	  }
-
-	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	break;
-      }
-
-      //===========================================================
-      // User mode thread issued a read request on the tap device
-      // If there are packets waiting to be read, then the request
-      // will be satisfied here. If not, then the request will be
-      // queued and satisfied by any packet that is not used to
-      // satisfy requests ahead of it.
-      //===========================================================
-    case IRP_MJ_READ:
-      {
-	TapPacketPointer l_PacketBuffer;
-	BOOLEAN pending = FALSE;
-
-	// Save IRP-accessible copy of buffer length
-	p_IRP->IoStatus.Information = l_IrpSp->Parameters.Read.Length;
-
-	if (p_IRP->MdlAddress == NULL)
-	  {
-	    DEBUGP (("[%s] MdlAddress is NULL for IRP_MJ_READ\n",
-		     NAME (l_Adapter)));
-	    NOTE_ERROR ();
-	    p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;
-	    p_IRP->IoStatus.Information = 0;
-	    IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	    break;
-	  }
-	else if ((p_IRP->AssociatedIrp.SystemBuffer =
-		  MmGetSystemAddressForMdlSafe
-		  (p_IRP->MdlAddress, NormalPagePriority)) == NULL)
-	  {
-	    DEBUGP (("[%s] Could not map address in IRP_MJ_READ\n",
-		     NAME (l_Adapter)));
-	    NOTE_ERROR ();
-	    p_IRP->IoStatus.Status = l_Status = STATUS_INSUFFICIENT_RESOURCES;
-	    p_IRP->IoStatus.Information = 0;
-	    IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	    break;
-	  }
-	else if (!l_Adapter->m_InterfaceIsRunning)
-	  {
-	    DEBUGP (("[%s] Interface is down in IRP_MJ_READ\n",
-		     NAME (l_Adapter)));
-	    NOTE_ERROR ();
-	    p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-	    p_IRP->IoStatus.Information = 0;
-	    IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	    break;
-	  }
-
-	//==================================
-	// Can we provide immediate service?
-	//==================================
-
-	l_PacketBuffer = NULL;
-
-	NdisAcquireSpinLock (&l_Adapter->m_Extension.m_QueueLock);
-
-	if (IS_UP (l_Adapter)
-	    && QueueCount (l_Adapter->m_Extension.m_PacketQueue)
-	    && QueueCount (l_Adapter->m_Extension.m_IrpQueue) == 0)
-	  {
-	    l_PacketBuffer = (TapPacketPointer)
-	      QueuePop (l_Adapter->m_Extension.m_PacketQueue);
-	  }
-
-	NdisReleaseSpinLock (&l_Adapter->m_Extension.m_QueueLock);
-
-	if (l_PacketBuffer)
-	  {
-	    l_Status = CompleteIRP (p_IRP,
-				    l_PacketBuffer,
-				    IO_NO_INCREMENT);
-	    break;
-	  }
-
-	//=============================
-	// Attempt to pend read request
-	//=============================
-
-	NdisAcquireSpinLock (&l_Adapter->m_Extension.m_QueueLock);
-
-	if (IS_UP (l_Adapter)
-	    && QueuePush (l_Adapter->m_Extension.m_IrpQueue, p_IRP) == (PIRP) p_IRP)
-	  {
-	    IoSetCancelRoutine (p_IRP, CancelIRPCallback);
-	    l_Status = STATUS_PENDING;
-	    IoMarkIrpPending (p_IRP);
-	    pending = TRUE;
-	  }
-
-	NdisReleaseSpinLock (&l_Adapter->m_Extension.m_QueueLock);
-
-	if (pending)
-	  break;
-
-	// Can't queue anymore IRP's
-	DEBUGP (("[%s] TAP [%s] read IRP overrun\n",
-		 NAME (l_Adapter), l_Adapter->m_Extension.m_TapName));
-	NOTE_ERROR ();
-	p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-	p_IRP->IoStatus.Information = 0;
-	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	break;
-      }
-
-      //==============================================================
-      // User mode issued a WriteFile request on the TAP file handle.
-      // The request will always get satisfied here.  The call may
-      // fail if there are too many pending packets (queue full).
-      //==============================================================
-    case IRP_MJ_WRITE:
-      {
-	if (p_IRP->MdlAddress == NULL)
-	  {
-	    DEBUGP (("[%s] MdlAddress is NULL for IRP_MJ_WRITE\n",
-		     NAME (l_Adapter)));
-	    NOTE_ERROR ();
-	    p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;
-	    p_IRP->IoStatus.Information = 0;
-	  }
-	else if ((p_IRP->AssociatedIrp.SystemBuffer =
-		  MmGetSystemAddressForMdlSafe
-		  (p_IRP->MdlAddress, NormalPagePriority)) == NULL)
-	  {
-	    DEBUGP (("[%s] Could not map address in IRP_MJ_WRITE\n",
-		     NAME (l_Adapter)));
-	    NOTE_ERROR ();
-	    p_IRP->IoStatus.Status = l_Status = STATUS_INSUFFICIENT_RESOURCES;
-	    p_IRP->IoStatus.Information = 0;
-	  }
-	else if (!l_Adapter->m_InterfaceIsRunning)
-	  {
-	    DEBUGP (("[%s] Interface is down in IRP_MJ_WRITE\n",
-		     NAME (l_Adapter)));
-	    NOTE_ERROR ();
-	    p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-	    p_IRP->IoStatus.Information = 0;
-	  }
-	else if (!l_Adapter->m_tun && ((l_IrpSp->Parameters.Write.Length) >= ETHERNET_HEADER_SIZE))
-	  {
-	    __try
-	      {
-		p_IRP->IoStatus.Information = l_IrpSp->Parameters.Write.Length;
-
-		DUMP_PACKET ("IRP_MJ_WRITE ETH",
-			     (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
-			     l_IrpSp->Parameters.Write.Length);
-
-    //=====================================================
-    // If IPv4 packet, check whether or not packet
-    // was truncated.
-    //=====================================================
-#if PACKET_TRUNCATION_CHECK
-		IPv4PacketSizeVerify ((unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
-				      l_IrpSp->Parameters.Write.Length,
-				      FALSE,
-				      "RX",
-				      &l_Adapter->m_RxTrunc);
-#endif
-
-		NdisMEthIndicateReceive
-		  (l_Adapter->m_MiniportAdapterHandle,
-		   (NDIS_HANDLE) l_Adapter,
-		   (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
-		   ETHERNET_HEADER_SIZE,
-		   (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer + ETHERNET_HEADER_SIZE,
-		   l_IrpSp->Parameters.Write.Length - ETHERNET_HEADER_SIZE,
-		   l_IrpSp->Parameters.Write.Length - ETHERNET_HEADER_SIZE);
-		
-		NdisMEthIndicateReceiveComplete (l_Adapter->m_MiniportAdapterHandle);
-
-		p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;
-	      }
-	    __except (EXCEPTION_EXECUTE_HANDLER)
-	      {
-		DEBUGP (("[%s] NdisMEthIndicateReceive failed in IRP_MJ_WRITE\n",
-			 NAME (l_Adapter)));
-		NOTE_ERROR ();
-		p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-		p_IRP->IoStatus.Information = 0;
-	      }
-	  }
-	else if (l_Adapter->m_tun && ((l_IrpSp->Parameters.Write.Length) >= IP_HEADER_SIZE))
-	  {
-	    __try
-	      {
-		p_IRP->IoStatus.Information = l_IrpSp->Parameters.Write.Length;
-
-		DUMP_PACKET2 ("IRP_MJ_WRITE P2P",
-			      &l_Adapter->m_UserToTap,
-			      (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
-			      l_IrpSp->Parameters.Write.Length);
-
-    //=====================================================
-    // If IPv4 packet, check whether or not packet
-    // was truncated.
-    //=====================================================
-#if PACKET_TRUNCATION_CHECK
-		IPv4PacketSizeVerify ((unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
-				      l_IrpSp->Parameters.Write.Length,
-				      TRUE,
-				      "RX",
-				      &l_Adapter->m_RxTrunc);
-#endif
-
-		NdisMEthIndicateReceive
-		  (l_Adapter->m_MiniportAdapterHandle,
-		   (NDIS_HANDLE) l_Adapter,
-		   (unsigned char *) &l_Adapter->m_UserToTap,
-		   sizeof (l_Adapter->m_UserToTap),
-		   (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
-		   l_IrpSp->Parameters.Write.Length,
-		   l_IrpSp->Parameters.Write.Length);
-
-		NdisMEthIndicateReceiveComplete (l_Adapter->m_MiniportAdapterHandle);
-
-		p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;
-	      }
-	    __except (EXCEPTION_EXECUTE_HANDLER)
-	      {
-		DEBUGP (("[%s] NdisMEthIndicateReceive failed in IRP_MJ_WRITE (P2P)\n",
-			 NAME (l_Adapter)));
-		NOTE_ERROR ();
-		p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-		p_IRP->IoStatus.Information = 0;
-	      }
-	  }
-	else
-	  {
-	    DEBUGP (("[%s] Bad buffer size in IRP_MJ_WRITE, len=%d\n",
-		     NAME (l_Adapter),
-		     l_IrpSp->Parameters.Write.Length));
-	    NOTE_ERROR ();
-	    p_IRP->IoStatus.Information = 0;	// ETHERNET_HEADER_SIZE;
-	    p_IRP->IoStatus.Status = l_Status = STATUS_BUFFER_TOO_SMALL;
-	  }
-
-	if (l_Status == STATUS_SUCCESS)
-	  INCREMENT_STAT (l_Adapter->m_Rx);
-	else
-	  INCREMENT_STAT (l_Adapter->m_RxErr);
-
-	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	break;
-      }
-
-      //--------------------------------------------------------------
-      //   User mode thread has called CreateFile() on the tap device
-      //--------------------------------------------------------------
-    case IRP_MJ_CREATE:
-      {
-	BOOLEAN succeeded = FALSE;
-	BOOLEAN mutex_succeeded;
-
-	DEBUGP
-	  (("[%s] [TAP] release [%d.%d] open request (m_TapOpens=%d)\n",
-	    NAME (l_Adapter), TAP_DRIVER_MAJOR_VERSION,
-	    TAP_DRIVER_MINOR_VERSION, l_Adapter->m_Extension.m_TapOpens));
-
-	ACQUIRE_MUTEX_ADAPTIVE (&l_Adapter->m_Extension.m_OpenCloseMutex, mutex_succeeded);
-	if (mutex_succeeded)
-	  {
-	    if (l_Adapter->m_Extension.m_TapIsRunning && !l_Adapter->m_Extension.m_TapOpens)
-	      {
-		ResetTapAdapterState (l_Adapter);
-		l_Adapter->m_Extension.m_TapOpens = 1;
-		succeeded = TRUE;
-	      }
-
-	    if (succeeded)
-	      {
-		INCREMENT_STAT (l_Adapter->m_Extension.m_NumTapOpens);
-		p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;
-		p_IRP->IoStatus.Information = 0;
-	      }
-	    else
-	      {
-		DEBUGP (("[%s] TAP is presently unavailable (m_TapOpens=%d)\n",
-			 NAME (l_Adapter), l_Adapter->m_Extension.m_TapOpens));
-		NOTE_ERROR ();
-		p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-		p_IRP->IoStatus.Information = 0;
-	      }
-
-	    RELEASE_MUTEX (&l_Adapter->m_Extension.m_OpenCloseMutex);
-	  }
-	else
-	  {
-	    DEBUGP (("[%s] TAP is presently locked (m_TapOpens=%d)\n",
-		     NAME (l_Adapter), l_Adapter->m_Extension.m_TapOpens));
-	    NOTE_ERROR ();
-	    p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-	    p_IRP->IoStatus.Information = 0;
-	  }
-	
-	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	break;
-      }
-      
-      //-----------------------------------------------------------
-      //  User mode thread called CloseHandle() on the tap device
-      //-----------------------------------------------------------
-    case IRP_MJ_CLOSE:
-      {
-	BOOLEAN mutex_succeeded;
-
-	DEBUGP (("[%s] [TAP] release [%d.%d] close/cleanup request\n",
-		 NAME (l_Adapter), TAP_DRIVER_MAJOR_VERSION,
-		 TAP_DRIVER_MINOR_VERSION));
-
-	ACQUIRE_MUTEX_ADAPTIVE (&l_Adapter->m_Extension.m_OpenCloseMutex, mutex_succeeded);
-	if (mutex_succeeded)
-	  {
-	    l_Adapter->m_Extension.m_TapOpens = 0;
-	    ResetTapAdapterState (l_Adapter);
-	    FlushQueues (&l_Adapter->m_Extension);
-	    SetMediaStatus (l_Adapter, FALSE);
-	    RELEASE_MUTEX (&l_Adapter->m_Extension.m_OpenCloseMutex);
-	  }
-	else
-	  {
-	    DEBUGP (("[%s] TAP is presently locked (m_TapOpens=%d)\n",
-		     NAME (l_Adapter), l_Adapter->m_Extension.m_TapOpens));
-	    NOTE_ERROR ();
-	    p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-	    p_IRP->IoStatus.Information = 0;
-	  }
-	
-	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	break;
-      }
-
-      //------------------
-      // Strange Request
-      //------------------
-    default:
-      {
-	//NOTE_ERROR ();
-	p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
-	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-	break;
-      }
-    }
-
-  return l_Status;
-}
-
-//=============================================================
-// CompleteIRP is normally called with an adapter -> userspace
-// network packet and an IRP (Pending I/O request) from userspace.
-//
-// The IRP will normally represent a queued overlapped read
-// operation from userspace that is in a wait state.
-//
-// Use the ethernet packet to satisfy the IRP.
-//=============================================================
-
-NTSTATUS
-CompleteIRP (IN PIRP p_IRP,
-	     IN TapPacketPointer p_PacketBuffer,
-	     IN CCHAR PriorityBoost)
-{
-  NTSTATUS l_Status = STATUS_UNSUCCESSFUL;
-
-  int offset;
-  int len;
-
-  MYASSERT (p_IRP);
-  MYASSERT (p_PacketBuffer);
-
-  IoSetCancelRoutine (p_IRP, NULL);  // Disable cancel routine
-
-  //-------------------------------------------
-  // While p_PacketBuffer always contains a
-  // full ethernet packet, including the
-  // ethernet header, in point-to-point mode,
-  // we only want to return the IPv4
-  // component.
-  //-------------------------------------------
-
-  if (p_PacketBuffer->m_SizeFlags & TP_TUN)
-    {
-      offset = ETHERNET_HEADER_SIZE;
-      len = (int) (p_PacketBuffer->m_SizeFlags & TP_SIZE_MASK) - ETHERNET_HEADER_SIZE;
-    }
-  else
-    {
-      offset = 0;
-      len = (p_PacketBuffer->m_SizeFlags & TP_SIZE_MASK);
-    }
-
-  if (len < 0 || (int) p_IRP->IoStatus.Information < len)
-    {
-      p_IRP->IoStatus.Information = 0;
-      p_IRP->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
-      NOTE_ERROR ();
-    }
-  else
-    {
-      p_IRP->IoStatus.Information = len;
-      p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;
-
-      __try
-	{
-	  NdisMoveMemory (p_IRP->AssociatedIrp.SystemBuffer,
-			  p_PacketBuffer->m_Data + offset,
-			  len);
-	}
-      __except (EXCEPTION_EXECUTE_HANDLER)
-	{
-	  NOTE_ERROR ();
-	  p_IRP->IoStatus.Status = STATUS_UNSUCCESSFUL;
-	  p_IRP->IoStatus.Information = 0;
-	}
-    }
-
-  __try
-    {
-      NdisFreeMemory (p_PacketBuffer,
-		      TAP_PACKET_SIZE (p_PacketBuffer->m_SizeFlags & TP_SIZE_MASK),
-		      0);
-    }
-  __except (EXCEPTION_EXECUTE_HANDLER)
-    {
-    }
-  
-  if (l_Status == STATUS_SUCCESS)
-    {
-      IoCompleteRequest (p_IRP, PriorityBoost);
-    }
-  else
-    IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-
-  return l_Status;
-}
-
-//==============================================
-// IRPs get cancelled for a number of reasons.
-//
-// The TAP device could be closed by userspace
-// when there are still pending read operations.
-//
-// The user could disable the TAP adapter in the
-// network connections control panel, while the
-// device is still open by a process.
-//==============================================
-VOID
-CancelIRPCallback (IN PDEVICE_OBJECT p_DeviceObject,
-		   IN PIRP p_IRP)
-{
-  TapAdapterPointer l_Adapter = LookupAdapterInInstanceList (p_DeviceObject);
-  CancelIRP (l_Adapter ? &l_Adapter->m_Extension : NULL, p_IRP, TRUE);
-}
-
-VOID
-CancelIRP (TapExtensionPointer p_Extension,
-	   IN PIRP p_IRP,
-	   BOOLEAN callback)
-{
-  BOOLEAN exists = FALSE;
-
-  MYASSERT (p_IRP);
-
-  if (p_Extension)
-    {
-      NdisAcquireSpinLock (&p_Extension->m_QueueLock);
-      exists = (QueueExtract (p_Extension->m_IrpQueue, p_IRP) == p_IRP);
-      NdisReleaseSpinLock (&p_Extension->m_QueueLock);
-    }
-  else
-    exists = TRUE;
-
-  if (exists)
-    {
-      IoSetCancelRoutine (p_IRP, NULL);
-      p_IRP->IoStatus.Status = STATUS_CANCELLED;
-      p_IRP->IoStatus.Information = 0;
-    }
-     
-  if (callback)
-    IoReleaseCancelSpinLock (p_IRP->CancelIrql);
-
-  if (exists)
-    IoCompleteRequest (p_IRP, IO_NO_INCREMENT);
-}
-
-//===========================================
-// Exhaust packet, IRP, and injection queues.
-//===========================================
-VOID
-FlushQueues (TapExtensionPointer p_Extension)
-{
-  PIRP l_IRP;
-  TapPacketPointer l_PacketBuffer;
-  InjectPacketPointer l_InjectBuffer;
-  int n_IRP=0, n_Packet=0, n_Inject=0;
-
-  MYASSERT (p_Extension);
-  MYASSERT (p_Extension->m_TapDevice);
-
-  while (TRUE)
-    {
-      NdisAcquireSpinLock (&p_Extension->m_QueueLock);
-      l_IRP = QueuePop (p_Extension->m_IrpQueue);
-      NdisReleaseSpinLock (&p_Extension->m_QueueLock);
-      if (l_IRP)
-	{
-	  ++n_IRP;
-	  CancelIRP (NULL, l_IRP, FALSE);
-	}
-      else
-	break;
-    }
-
-  while (TRUE)
-    {
-      NdisAcquireSpinLock (&p_Extension->m_QueueLock);
-      l_PacketBuffer = QueuePop (p_Extension->m_PacketQueue);
-      NdisReleaseSpinLock (&p_Extension->m_QueueLock);
-      if (l_PacketBuffer)
-	{
-	  ++n_Packet;
-	  MemFree (l_PacketBuffer, TAP_PACKET_SIZE (l_PacketBuffer->m_SizeFlags & TP_SIZE_MASK));
-	}
-      else
-	break;
-    }
-
-  while (TRUE)
-    {
-      NdisAcquireSpinLock (&p_Extension->m_InjectLock);
-      l_InjectBuffer = QueuePop (p_Extension->m_InjectQueue);
-      NdisReleaseSpinLock (&p_Extension->m_InjectLock);
-      if (l_InjectBuffer)
-	{
-	  ++n_Inject;
-	  INJECT_PACKET_FREE(l_InjectBuffer);
-	}
-      else
-	break;
-    }
-
-  DEBUGP ((
-	   "[%s] [TAP] FlushQueues n_IRP=[%d,%d,%d] n_Packet=[%d,%d,%d] n_Inject=[%d,%d,%d]\n",
-	   p_Extension->m_TapName,
-	   n_IRP,
-	   p_Extension->m_IrpQueue->max_size,
-	   IRP_QUEUE_SIZE,
-	   n_Packet,
-	   p_Extension->m_PacketQueue->max_size,
-	   PACKET_QUEUE_SIZE,
-	   n_Inject,
-	   p_Extension->m_InjectQueue->max_size,
-	   INJECT_QUEUE_SIZE
-	   ));
-}
-
-//===================================================
-// Tell Windows whether the TAP device should be
-// considered "connected" or "disconnected".
-//===================================================
-VOID
-SetMediaStatus (TapAdapterPointer p_Adapter, BOOLEAN state)
-{
-  if (p_Adapter->m_MediaState != state && !p_Adapter->m_MediaStateAlwaysConnected)
-    {
-      if (state)
-	NdisMIndicateStatus (p_Adapter->m_MiniportAdapterHandle,
-			     NDIS_STATUS_MEDIA_CONNECT, NULL, 0);
-      else
-	NdisMIndicateStatus (p_Adapter->m_MiniportAdapterHandle,
-			     NDIS_STATUS_MEDIA_DISCONNECT, NULL, 0);
-
-      NdisMIndicateStatusComplete (p_Adapter->m_MiniportAdapterHandle);
-      p_Adapter->m_MediaState = state;
-    }
-}
-
-
-//======================================================
-// If DHCP mode is used together with tun
-// mode, consider the fact that the P2P remote subnet
-// might enclose the DHCP masq server address.
-//======================================================
-VOID
-CheckIfDhcpAndTunMode (TapAdapterPointer p_Adapter)
-{
-  if (p_Adapter->m_tun && p_Adapter->m_dhcp_enabled)
-    {
-      if ((p_Adapter->m_dhcp_server_ip & p_Adapter->m_remoteNetmask) == p_Adapter->m_remoteNetwork)
-	{
-	  COPY_MAC (p_Adapter->m_dhcp_server_mac, p_Adapter->m_TapToUser.dest);
-	  p_Adapter->m_dhcp_server_arp = FALSE;
-	}
-    }
-}
-
-//===================================================
-// Generate an ARP reply message for specific kinds
-// ARP queries.
-//===================================================
-BOOLEAN
-ProcessARP (TapAdapterPointer p_Adapter,
-	    const PARP_PACKET src,
-	    const IPADDR adapter_ip,
-	    const IPADDR ip_network,
-	    const IPADDR ip_netmask,
-	    const MACADDR mac)
-{
-  //-----------------------------------------------
-  // Is this the kind of packet we are looking for?
-  //-----------------------------------------------
-  if (src->m_Proto == htons (ETH_P_ARP)
-      && MAC_EQUAL (src->m_MAC_Source, p_Adapter->m_MAC)
-      && MAC_EQUAL (src->m_ARP_MAC_Source, p_Adapter->m_MAC)
-      && MAC_EQUAL (src->m_MAC_Destination, p_Adapter->m_MAC_Broadcast)
-      && src->m_ARP_Operation == htons (ARP_REQUEST)
-      && src->m_MAC_AddressType == htons (MAC_ADDR_TYPE)
-      && src->m_MAC_AddressSize == sizeof (MACADDR)
-      && src->m_PROTO_AddressType == htons (ETH_P_IP)
-      && src->m_PROTO_AddressSize == sizeof (IPADDR)
-      && src->m_ARP_IP_Source == adapter_ip
-      && (src->m_ARP_IP_Destination & ip_netmask) == ip_network
-      && src->m_ARP_IP_Destination != adapter_ip)
-    {
-      ARP_PACKET *arp = (ARP_PACKET *) MemAlloc (sizeof (ARP_PACKET), TRUE);
-      if (arp)
-	{
-	  //----------------------------------------------
-	  // Initialize ARP reply fields
-	  //----------------------------------------------
-	  arp->m_Proto = htons (ETH_P_ARP);
-	  arp->m_MAC_AddressType = htons (MAC_ADDR_TYPE);
-	  arp->m_PROTO_AddressType = htons (ETH_P_IP);
-	  arp->m_MAC_AddressSize = sizeof (MACADDR);
-	  arp->m_PROTO_AddressSize = sizeof (IPADDR);
-	  arp->m_ARP_Operation = htons (ARP_REPLY);
-
-	  //----------------------------------------------
-	  // ARP addresses
-	  //----------------------------------------------      
-	  COPY_MAC (arp->m_MAC_Source, mac);
-	  COPY_MAC (arp->m_MAC_Destination, p_Adapter->m_MAC);
-	  COPY_MAC (arp->m_ARP_MAC_Source, mac);
-	  COPY_MAC (arp->m_ARP_MAC_Destination, p_Adapter->m_MAC);
-	  arp->m_ARP_IP_Source = src->m_ARP_IP_Destination;
-	  arp->m_ARP_IP_Destination = adapter_ip;
-
-	  DUMP_PACKET ("ProcessARP",
-		       (unsigned char *) arp,
-		       sizeof (ARP_PACKET));
-
-	  InjectPacketDeferred (p_Adapter, (UCHAR *) arp, sizeof (ARP_PACKET));
-
-	  MemFree (arp, sizeof (ARP_PACKET));
-	}
-
-      return TRUE;
-    }
-  else
-    return FALSE;
-}
-
-//===============================================================
-// Used in cases where internally generated packets such as
-// ARP or DHCP replies must be returned to the kernel, to be
-// seen as an incoming packet "arriving" on the interface.
-//===============================================================
-
-// Defer packet injection till IRQL < DISPATCH_LEVEL
-VOID
-InjectPacketDeferred (TapAdapterPointer p_Adapter,
-		      UCHAR *packet,
-		      const unsigned int len)
-{
-  InjectPacketPointer l_InjectBuffer;
-  PVOID result;
-
-  if (NdisAllocateMemoryWithTag (&l_InjectBuffer,
-				 INJECT_PACKET_SIZE (len),
-				 'IPAT') == NDIS_STATUS_SUCCESS)
-    {
-      l_InjectBuffer->m_Size = len;
-      NdisMoveMemory (l_InjectBuffer->m_Data, packet, len);
-      NdisAcquireSpinLock (&p_Adapter->m_Extension.m_InjectLock);
-      result = QueuePush (p_Adapter->m_Extension.m_InjectQueue, l_InjectBuffer);
-      NdisReleaseSpinLock (&p_Adapter->m_Extension.m_InjectLock);
-      if (result)
-	KeInsertQueueDpc (&p_Adapter->m_Extension.m_InjectDpc, p_Adapter, NULL);
-      else
-	INJECT_PACKET_FREE(l_InjectBuffer);
-    }
-}
-
-// Handle the injection of previously deferred packets
-VOID
-InjectPacketDpc(KDPC *Dpc,
-		PVOID DeferredContext,
-		PVOID SystemArgument1,
-		PVOID SystemArgument2)
-{
-  InjectPacketPointer l_InjectBuffer;
-  TapAdapterPointer l_Adapter = (TapAdapterPointer)SystemArgument1;
-  while (TRUE)
-    {
-      NdisAcquireSpinLock (&l_Adapter->m_Extension.m_InjectLock);
-      l_InjectBuffer = QueuePop (l_Adapter->m_Extension.m_InjectQueue);
-      NdisReleaseSpinLock (&l_Adapter->m_Extension.m_InjectLock);
-      if (l_InjectBuffer)
-	{
-	  InjectPacketNow(l_Adapter, l_InjectBuffer->m_Data, l_InjectBuffer->m_Size);
-	  INJECT_PACKET_FREE(l_InjectBuffer);
-	}
-      else
-	break;
-    }
-}
-
-// Do packet injection now
-VOID
-InjectPacketNow (TapAdapterPointer p_Adapter,
-		 UCHAR *packet,
-		 const unsigned int len)
-{
-  MYASSERT (len >= ETHERNET_HEADER_SIZE);
-
-  __try
-    {
-      //------------------------------------------------------------
-      // NdisMEthIndicateReceive and NdisMEthIndicateReceiveComplete
-      // could potentially be called reentrantly both here and in
-      // TapDeviceHook/IRP_MJ_WRITE.
-      //
-      // The DDK docs imply that this is okay.
-      //
-      // Note that reentrant behavior could only occur if the
-      // non-deferred version of InjectPacket is used.
-      //------------------------------------------------------------
-      NdisMEthIndicateReceive
-	(p_Adapter->m_MiniportAdapterHandle,
-	 (NDIS_HANDLE) p_Adapter,
-	 packet,
-	 ETHERNET_HEADER_SIZE,
-	 packet + ETHERNET_HEADER_SIZE,
-	 len - ETHERNET_HEADER_SIZE,
-	 len - ETHERNET_HEADER_SIZE);
-      
-      NdisMEthIndicateReceiveComplete (p_Adapter->m_MiniportAdapterHandle);
-    }
-  __except (EXCEPTION_EXECUTE_HANDLER)
-    {
-      DEBUGP (("[%s] NdisMEthIndicateReceive failed in InjectPacketNow\n",
-	       NAME (p_Adapter)));
-      NOTE_ERROR ();
-    }
-}
-
-//===================================================================
-// Go back to default TAP mode from Point-To-Point mode.
-// Also reset (i.e. disable) DHCP Masq mode.
-//===================================================================
-VOID ResetTapAdapterState (TapAdapterPointer p_Adapter)
-{
-  // Point-To-Point
-  p_Adapter->m_tun = FALSE;
-  p_Adapter->m_localIP = 0;
-  p_Adapter->m_remoteNetwork = 0;
-  p_Adapter->m_remoteNetmask = 0;
-  NdisZeroMemory (&p_Adapter->m_TapToUser, sizeof (p_Adapter->m_TapToUser));
-  NdisZeroMemory (&p_Adapter->m_UserToTap, sizeof (p_Adapter->m_UserToTap));
-
-  // DHCP Masq
-  p_Adapter->m_dhcp_enabled = FALSE;
-  p_Adapter->m_dhcp_server_arp = FALSE;
-  p_Adapter->m_dhcp_user_supplied_options_buffer_len = 0;
-  p_Adapter->m_dhcp_addr = 0;
-  p_Adapter->m_dhcp_netmask = 0;
-  p_Adapter->m_dhcp_server_ip = 0;
-  p_Adapter->m_dhcp_lease_time = 0;
-  p_Adapter->m_dhcp_received_discover = FALSE;
-  p_Adapter->m_dhcp_bad_requests = 0;
-  NdisZeroMemory (p_Adapter->m_dhcp_server_mac, sizeof (MACADDR));
-}
-
-#if ENABLE_NONADMIN
-
-//===================================================================
-// Set TAP device handle to be accessible without admin privileges.
-//===================================================================
-VOID AllowNonAdmin (TapExtensionPointer p_Extension)
-{
-  NTSTATUS stat;
-  SECURITY_DESCRIPTOR sd;
-  OBJECT_ATTRIBUTES oa;
-  IO_STATUS_BLOCK isb;
-  HANDLE hand = NULL;
-
-  NdisZeroMemory (&sd, sizeof (sd));
-  NdisZeroMemory (&oa, sizeof (oa));
-  NdisZeroMemory (&isb, sizeof (isb));
-
-  if (!p_Extension->m_CreatedUnicodeLinkName)
-    {
-      DEBUGP (("[TAP] AllowNonAdmin: UnicodeLinkName is uninitialized\n"));
-      NOTE_ERROR ();
-      return;
-    }
-
-  stat = RtlCreateSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
-  if (stat != STATUS_SUCCESS)
-    {
-      DEBUGP (("[TAP] AllowNonAdmin: RtlCreateSecurityDescriptor failed\n"));
-      NOTE_ERROR ();
-      return;
-    }
-
-  InitializeObjectAttributes (
-    &oa,
-    &p_Extension->m_UnicodeLinkName,
-    OBJ_KERNEL_HANDLE,
-    NULL,
-    NULL
-    );
-
-  stat = ZwOpenFile (
-    &hand,
-    WRITE_DAC,
-    &oa,
-    &isb,
-    0,
-    0
-    );
-  if (stat != STATUS_SUCCESS)
-    {
-      DEBUGP (("[TAP] AllowNonAdmin: ZwOpenFile failed, status=0x%08x\n", (unsigned int)stat));
-      NOTE_ERROR ();
-      return;
-    }
-
-  stat = ZwSetSecurityObject (hand, DACL_SECURITY_INFORMATION, &sd);
-  if (stat != STATUS_SUCCESS)
-    {
-      DEBUGP (("[TAP] AllowNonAdmin: ZwSetSecurityObject failed\n"));
-      NOTE_ERROR ();
-      return;
-    }
-
-  stat = ZwClose (hand);
-  if (stat != STATUS_SUCCESS)
-    {
-      DEBUGP (("[TAP] AllowNonAdmin: ZwClose failed\n"));
-      NOTE_ERROR ();
-      return;
-    }
-
-  DEBUGP (("[TAP] AllowNonAdmin: SUCCEEDED\n"));
-}
-
-#endif
-
-#if PACKET_TRUNCATION_CHECK
-
-VOID
-IPv4PacketSizeVerify (const UCHAR *data, ULONG length, BOOLEAN tun, const char *prefix, LONG *counter)
-{
-  const IPHDR *ip;
-  int len = length;
-
-  if (tun)
-    {
-      ip = (IPHDR *) data;
-    }
-  else
-    {
-      if (length >= sizeof (ETH_HEADER))
-	{
-	  const ETH_HEADER *eth = (ETH_HEADER *) data;
-
-	  if (eth->proto != htons (ETH_P_IP))
-	    return;
-
-	  ip = (IPHDR *) (data + sizeof (ETH_HEADER));
-	  len -= sizeof (ETH_HEADER);
-	}
-      else
-	return;
-    }
-
-  if (len >= sizeof (IPHDR))
-    {
-      const int totlen = ntohs (ip->tot_len);
-
-      DEBUGP (("[TAP] IPv4PacketSizeVerify %s len=%d totlen=%d\n", prefix, len, totlen));
-
-      if (len != totlen)
-	++(*counter);
-    }
-}
-
-#endif
-
-//======================================================================
-//                                    End of Source
-//======================================================================
diff -urN openvpn-2.1.1/tap-win32/tmp/types.h openvpn-2.1.3/tap-win32/tmp/types.h
--- openvpn-2.1.1/tap-win32/tmp/types.h	2009-12-11 06:00:45.000000000 +0100
+++ openvpn-2.1.3/tap-win32/tmp/types.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,181 +0,0 @@
-/*
- *  TAP-Win32/TAP-Win64 -- A kernel driver to provide virtual tap
- *                         device functionality on Windows.
- *
- *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
- *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
- *  and is released under the GPL version 2 (see below), however due
- *  to the extra costs of supporting Windows Vista, OpenVPN Solutions
- *  LLC reserves the right to change the terms of the TAP-Win32/TAP-Win64
- *  license for versions 9.1 and higher prior to the official release of
- *  OpenVPN 2.1.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program (see the file COPYING included with this
- *  distribution); if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef TAP_TYPES_DEFINED
-#define TAP_TYPES_DEFINED
-
-typedef struct _Queue
-{
-  ULONG base;
-  ULONG size;
-  ULONG capacity;
-  ULONG max_size;
-  PVOID data[];
-} Queue;
-
-typedef struct _TapAdapter;
-typedef struct _TapPacket;
-
-typedef union _TapAdapterQuery
-{
-  NDIS_HARDWARE_STATUS m_HardwareStatus;
-  NDIS_MEDIUM m_Medium;
-  NDIS_PHYSICAL_MEDIUM m_PhysicalMedium;
-  UCHAR m_MacAddress [6];
-  UCHAR m_Buffer [256];
-  ULONG m_Long;
-  USHORT m_Short;
-  UCHAR m_Byte;
-}
-TapAdapterQuery, *TapAdapterQueryPointer;
-
-typedef struct _TapExtension
-{
-  // TAP device object and packet queues
-  Queue *m_PacketQueue, *m_IrpQueue;
-  PDEVICE_OBJECT m_TapDevice;
-  NDIS_HANDLE m_TapDeviceHandle;
-  ULONG m_TapOpens;
-
-  // Used to lock packet queues
-  NDIS_SPIN_LOCK m_QueueLock;
-  BOOLEAN m_AllocatedSpinlocks;
-
-  // Used to bracket open/close
-  // state changes.
-  MUTEX m_OpenCloseMutex;
-
-  // True if device has been permanently halted
-  BOOLEAN m_Halt;
-
-  // TAP device name
-  unsigned char *m_TapName;
-  UNICODE_STRING m_UnicodeLinkName;
-  BOOLEAN m_CreatedUnicodeLinkName;
-
-  // Used for device status ioctl only
-  const char *m_LastErrorFilename;
-  int m_LastErrorLineNumber;
-  LONG m_NumTapOpens;
-
-  // Flags
-  BOOLEAN m_TapIsRunning;
-  BOOLEAN m_CalledTapDeviceFreeResources;
-
-  // DPC queue for deferred packet injection
-  BOOLEAN m_InjectDpcInitialized;
-  KDPC m_InjectDpc;
-  NDIS_SPIN_LOCK m_InjectLock;
-  Queue *m_InjectQueue;
-}
-TapExtension, *TapExtensionPointer;
-
-typedef struct _TapPacket
-   {
-#   define TAP_PACKET_SIZE(data_size) (sizeof (TapPacket) + (data_size))
-#   define TP_TUN 0x80000000
-#   define TP_SIZE_MASK      (~TP_TUN)
-    ULONG m_SizeFlags;
-    UCHAR m_Data []; // m_Data must be the last struct member
-   }
-TapPacket, *TapPacketPointer;
-
-typedef struct _InjectPacket
-   {
-#   define INJECT_PACKET_SIZE(data_size) (sizeof (InjectPacket) + (data_size))
-#   define INJECT_PACKET_FREE(ib)  NdisFreeMemory ((ib), INJECT_PACKET_SIZE ((ib)->m_Size), 0)
-    ULONG m_Size;
-    UCHAR m_Data []; // m_Data must be the last struct member
-   }
-InjectPacket, *InjectPacketPointer;
-
-typedef struct _TapAdapter
-{
-# define NAME(a) ((a)->m_NameAnsi.Buffer)
-  ANSI_STRING m_NameAnsi;
-  MACADDR m_MAC;
-  BOOLEAN m_InterfaceIsRunning;
-  NDIS_HANDLE m_MiniportAdapterHandle;
-  LONG m_Rx, m_Tx, m_RxErr, m_TxErr;
-#if PACKET_TRUNCATION_CHECK
-  LONG m_RxTrunc, m_TxTrunc;
-#endif
-  NDIS_MEDIUM m_Medium;
-  ULONG m_Lookahead;
-  ULONG m_MTU;
-
-  // TRUE if adapter should always be
-  // "connected" even when device node
-  // is not open by a userspace process.
-  BOOLEAN m_MediaStateAlwaysConnected;
-
-  // TRUE if device is "connected"
-  BOOLEAN m_MediaState;
-
-  // Adapter power state
-  char m_DeviceState;
-
-  // Info for point-to-point mode
-  BOOLEAN m_tun;
-  IPADDR m_localIP;
-  IPADDR m_remoteNetwork;
-  IPADDR m_remoteNetmask;
-  ETH_HEADER m_TapToUser;
-  ETH_HEADER m_UserToTap;
-  MACADDR m_MAC_Broadcast;
-
-  // Used for DHCP server masquerade
-  BOOLEAN m_dhcp_enabled;
-  IPADDR m_dhcp_addr;
-  ULONG m_dhcp_netmask;
-  IPADDR m_dhcp_server_ip;
-  BOOLEAN m_dhcp_server_arp;
-  MACADDR m_dhcp_server_mac;
-  ULONG m_dhcp_lease_time;
-  UCHAR m_dhcp_user_supplied_options_buffer[DHCP_USER_SUPPLIED_OPTIONS_BUFFER_SIZE];
-  ULONG m_dhcp_user_supplied_options_buffer_len;
-  BOOLEAN m_dhcp_received_discover;
-  ULONG m_dhcp_bad_requests;
-
-  // Help to tear down the adapter by keeping
-  // some state information on allocated
-  // resources.
-  BOOLEAN m_CalledAdapterFreeResources;
-  BOOLEAN m_RegisteredAdapterShutdownHandler;
-
-  // Multicast list info
-  NDIS_SPIN_LOCK m_MCLock;
-  BOOLEAN m_MCLockAllocated;
-  ULONG m_MCListSize;
-  MC_LIST m_MCList;
-
-  // Information on the TAP device
-  TapExtension m_Extension;
-} TapAdapter, *TapAdapterPointer;
-
-#endif
diff -urN openvpn-2.1.1/tap-win32/types.h openvpn-2.1.3/tap-win32/types.h
--- openvpn-2.1.1/tap-win32/types.h	2009-12-11 06:05:15.000000000 +0100
+++ openvpn-2.1.3/tap-win32/types.h	2010-04-28 18:25:40.000000000 +0200
@@ -4,7 +4,7 @@
  *
  *  This code was inspired by the CIPE-Win32 driver by Damion K. Wilson.
  *
- *  This source code is Copyright (C) 2002-2009 OpenVPN Technologies, Inc.,
+ *  This source code is Copyright (C) 2002-2010 OpenVPN Technologies, Inc.,
  *  and is released under the GPL version 2 (see below).
  *
  *  This program is free software; you can redistribute it and/or modify
diff -urN openvpn-2.1.1/thread.c openvpn-2.1.3/thread.c
--- openvpn-2.1.1/thread.c	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/thread.c	2010-04-28 18:25:40.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/thread.h openvpn-2.1.3/thread.h
--- openvpn-2.1.1/thread.h	2009-10-01 20:02:18.000000000 +0200
+++ openvpn-2.1.3/thread.h	2010-04-28 18:25:40.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
diff -urN openvpn-2.1.1/tun.c openvpn-2.1.3/tun.c
--- openvpn-2.1.1/tun.c	2009-11-20 14:09:14.000000000 +0100
+++ openvpn-2.1.3/tun.c	2010-07-27 23:44:33.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -55,7 +55,7 @@
 			    const char *flex_name,
 			    const in_addr_t ip,
 			    const in_addr_t netmask,
-			    unsigned int flags);
+			    const unsigned int flags);
 
 static const char *netsh_get_id (const char *dev_node, struct gc_arena *gc);
 
@@ -3383,6 +3383,48 @@
 }
 
 void
+ipconfig_register_dns (const struct env_set *es)
+{
+  struct argv argv;
+  bool status;
+  const char err[] = "ERROR: Windows ipconfig command failed";
+
+  netcmd_semaphore_lock ();
+
+  argv_init (&argv);
+
+  argv_printf (&argv, "%s%sc stop dnscache",
+	       get_win_sys_path(),
+	       WIN_NET_PATH_SUFFIX);
+  argv_msg (D_TUNTAP_INFO, &argv);
+  status = openvpn_execve_check (&argv, es, 0, err);
+  argv_reset(&argv);
+
+  argv_printf (&argv, "%s%sc start dnscache",
+	       get_win_sys_path(),
+	       WIN_NET_PATH_SUFFIX);
+  argv_msg (D_TUNTAP_INFO, &argv);
+  status = openvpn_execve_check (&argv, es, 0, err);
+  argv_reset(&argv);
+
+  argv_printf (&argv, "%s%sc /flushdns",
+	       get_win_sys_path(),
+	       WIN_IPCONFIG_PATH_SUFFIX);
+  argv_msg (D_TUNTAP_INFO, &argv);
+  status = openvpn_execve_check (&argv, es, 0, err);
+  argv_reset(&argv);
+
+  argv_printf (&argv, "%s%sc /registerdns",
+	       get_win_sys_path(),
+	       WIN_IPCONFIG_PATH_SUFFIX);
+  argv_msg (D_TUNTAP_INFO, &argv);
+  status = openvpn_execve_check (&argv, es, 0, err);
+  argv_reset(&argv);
+
+  netcmd_semaphore_release ();
+}
+
+void
 ip_addr_string_to_array (in_addr_t *dest, int *dest_len, const IP_ADDR_STRING *src)
 {
   int i = 0;
@@ -3817,8 +3859,23 @@
 	buf_printf (&cmd, " --dhcp-pre-release");
       if (tt->options.dhcp_renew)
 	buf_printf (&cmd, " --dhcp-renew");
-      buf_printf (&cmd, " --dhcp-rr %u", (unsigned int)tt->adapter_index);
+      buf_printf (&cmd, " --dhcp-internal %u", (unsigned int)tt->adapter_index);
+
+      fork_to_self (BSTR (&cmd));
+      gc_free (&gc);
+    }
+}
 
+void
+fork_register_dns_action (struct tuntap *tt)
+{
+  if (tt && tt->options.register_dns)
+    {
+      struct gc_arena gc = gc_new ();
+      struct buffer cmd = alloc_buf_gc (256, &gc);
+      const int verb = 3;
+ 
+      buf_printf (&cmd, "openvpn --verb %d --register-dns --rdns-internal", verb);
       fork_to_self (BSTR (&cmd));
       gc_free (&gc);
     }
diff -urN openvpn-2.1.1/tun.h openvpn-2.1.3/tun.h
--- openvpn-2.1.1/tun.h	2009-11-20 14:09:14.000000000 +0100
+++ openvpn-2.1.3/tun.h	2010-07-21 21:08:41.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -99,6 +99,8 @@
   bool dhcp_renew;
   bool dhcp_pre_release;
   bool dhcp_release;
+
+  bool register_dns;
 };
 
 #elif TARGET_LINUX
@@ -335,6 +337,9 @@
 bool dhcp_release_by_adapter_index(const DWORD adapter_index);
 bool dhcp_renew_by_adapter_index (const DWORD adapter_index);
 
+void fork_register_dns_action (struct tuntap *tt);
+void ipconfig_register_dns (const struct env_set *es);
+
 void tun_standby_init (struct tuntap *tt);
 bool tun_standby (struct tuntap *tt);
 
diff -urN openvpn-2.1.1/version.m4 openvpn-2.1.3/version.m4
--- openvpn-2.1.1/version.m4	2009-12-11 22:47:19.000000000 +0100
+++ openvpn-2.1.3/version.m4	2010-08-27 18:08:58.000000000 +0200
@@ -1,5 +1,5 @@
 dnl define the OpenVPN version
-define(PRODUCT_VERSION,[2.1.1])
+define(PRODUCT_VERSION,[2.1.3])
 dnl define the TAP version
 define(PRODUCT_TAP_ID,[tap0901])
 define(PRODUCT_TAP_WIN32_MIN_MAJOR,[9])
diff -urN openvpn-2.1.1/win/autodefs.h.in openvpn-2.1.3/win/autodefs.h.in
--- openvpn-2.1.1/win/autodefs.h.in	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/autodefs.h.in	2010-04-28 18:16:46.000000000 +0200
@@ -0,0 +1,31 @@
+#ifndef AUTODEFS_H
+#define AUTODEFS_H
+
+/*
+ * Minimum TAP-Win32 version number expected by userspace
+ *
+ * The TAP-Win32 version number is defined in tap-win32/SOURCES
+ */
+#define TAP_ID "@PRODUCT_TAP_ID@"
+#define TAP_WIN32_MIN_MAJOR @PRODUCT_TAP_WIN32_MIN_MAJOR@
+#define TAP_WIN32_MIN_MINOR @PRODUCT_TAP_WIN32_MIN_MINOR@
+
+/* Friendly name for TAP driver */
+#define PRODUCT_TAP_DEVICE_DESCRIPTION "@PRODUCT_TAP_DEVICE_DESCRIPTION@"
+
+/* Version number of DDK/WDK used to build TAP driver */
+#define DDKVER_MAJOR @DDKVER_MAJOR@
+
+/* Name of package */
+#define PACKAGE "@PRODUCT_UNIX_NAME@"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "@PRODUCT_NAME@"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "@PRODUCT_UNIX_NAME@"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "@PRODUCT_VERSION@"
+
+#endif
diff -urN openvpn-2.1.1/win/build.py openvpn-2.1.3/win/build.py
--- openvpn-2.1.1/win/build.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/build.py	2010-05-11 21:30:59.000000000 +0200
@@ -0,0 +1,22 @@
+import os, sys
+from wb import system, config, home_fn, cd_home
+
+os.environ['PATH'] += ";%s\\VC" % (os.path.normpath(config['MSVC']),)
+
+def build_vc(cmd):
+    system('cmd /c "vcvarsall.bat x86 && %s"' % (cmd,))
+
+def main():
+    cd_home()
+    build_vc("nmake /f %s" % (home_fn('msvc.mak'),))
+
+def clean():
+    cd_home()
+    build_vc("nmake /f %s clean" % (home_fn('msvc.mak'),))
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    if len(sys.argv) == 2 and sys.argv[1] == 'clean':
+        clean()
+    else:
+        main()
diff -urN openvpn-2.1.1/win/build_all.py openvpn-2.1.3/win/build_all.py
--- openvpn-2.1.1/win/build_all.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/build_all.py	2010-04-28 18:16:46.000000000 +0200
@@ -0,0 +1,18 @@
+from config_all import main as config_all
+from build import main as build_openvpn
+from build_ddk import main as build_ddk
+from sign import main as sign
+from make_dist import main as make_dist
+
+def main(config):
+    config_all(config)
+    build_openvpn()
+    build_ddk(config, 'tap', 'all')
+    build_ddk(config, 'tapinstall', 'all')
+    sign(config, 'all')
+    make_dist(config)
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    from wb import config
+    main(config)
diff -urN openvpn-2.1.1/win/build_ddk.py openvpn-2.1.3/win/build_ddk.py
--- openvpn-2.1.1/win/build_ddk.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/build_ddk.py	2010-08-27 18:08:58.000000000 +0200
@@ -0,0 +1,54 @@
+import os
+from wb import system, home_fn, choose_arch
+
+def build_ddk(config, dir, x64):
+    ddk_path = config['DDK_PATH']
+    ddk_major = int(config['DDKVER_MAJOR'])
+    debug = 'PRODUCT_TAP_DEBUG' in config
+    return build_tap(ddk_path, ddk_major, debug, dir, x64)
+
+def build_tap(ddk_path, ddk_major, debug, dir, x64):
+    setenv_bat = os.path.realpath(os.path.join(ddk_path, 'bin/setenv.bat'))
+    target = 'chk' if debug else 'fre'
+    if x64:
+        target += ' x64'
+    else:
+        target += ' x86'
+    if ddk_major >= 7600:
+        if x64:
+            target += ' wlh'  # vista
+        else:
+            target += ' wnet' # server 2003
+    else:
+        if x64:
+            target += ' wnet' # server 2003
+        else:
+            target += ' w2k'  # 2000
+
+    system('cmd /c "%s %s %s && cd %s && build -cef"' % (
+           setenv_bat,
+           os.path.realpath(ddk_path),
+           target,
+           dir
+           ))
+
+def main(config, proj, arch):
+    if proj == 'tap':
+        dir = home_fn('tap-win32')
+    elif proj == 'tapinstall':
+        dir = home_fn('tapinstall')
+    else:
+        raise ValueError("unknown project: %s" % (proj,))
+
+    for x64 in choose_arch(arch):
+        build_ddk(config, dir, x64)
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    import sys
+    from wb import config
+    if len(sys.argv) >= 3:
+        main(config, sys.argv[1], sys.argv[2])
+    else:
+        print "usage: build <tap|tapinstall> <x64|x86|all>"
+        sys.exit(2)
diff -urN openvpn-2.1.1/win/build_exe.py openvpn-2.1.3/win/build_exe.py
--- openvpn-2.1.1/win/build_exe.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/build_exe.py	2010-07-21 21:08:41.000000000 +0200
@@ -0,0 +1,15 @@
+from config import main as config_main
+from build import main as build_openvpn
+from build_ddk import main as build_ddk
+from sign import main as sign
+from make_dist import main as make_dist
+
+def main(config):
+    config_main(config)
+    build_openvpn()
+    make_dist(config, tap=False)
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    from wb import config
+    main(config)
diff -urN openvpn-2.1.1/win/config.py openvpn-2.1.3/win/config.py
--- openvpn-2.1.1/win/config.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/config.py	2010-07-10 05:46:50.000000000 +0200
@@ -0,0 +1,18 @@
+from wb import preprocess, autogen, mod_fn, home_fn, build_autodefs, make_headers_objs, dict_def
+
+def main(config):
+    build_autodefs(config, mod_fn('autodefs.h.in'), home_fn('autodefs.h'))
+    ho = make_headers_objs(home_fn('Makefile.am'))
+
+    preprocess(dict_def(config, [('HEADERS_OBJS', ho)]),
+               in_fn=mod_fn('msvc.mak.in'),
+               out_fn=home_fn('msvc.mak'),
+               quote_begin='@',
+               quote_end='@',
+               if_prefix='!',
+               head_comment='# %s\n\n' % autogen)
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    from wb import config
+    main(config)
diff -urN openvpn-2.1.1/win/config_all.py openvpn-2.1.3/win/config_all.py
--- openvpn-2.1.1/win/config_all.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/config_all.py	2010-04-28 18:16:46.000000000 +0200
@@ -0,0 +1,13 @@
+from config import main as config_main
+from config_tap import main as config_tap
+from config_ti import main as config_ti
+
+def main(config):
+    config_main(config)
+    config_tap(config)
+    config_ti(config)
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    from wb import config
+    main(config)
diff -urN openvpn-2.1.1/win/config_tap.py openvpn-2.1.3/win/config_tap.py
--- openvpn-2.1.1/win/config_tap.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/config_tap.py	2010-04-28 18:16:46.000000000 +0200
@@ -0,0 +1,35 @@
+import os
+from wb import preprocess, home_fn, autogen, dict_def
+
+def main(config):
+    preprocess(config,
+               in_fn=home_fn('tap-win32/SOURCES.in'),
+               out_fn=home_fn('tap-win32/SOURCES'),
+               quote_begin='@@',
+               quote_end='@@',
+               head_comment='# %s\n\n' % autogen)
+
+    preprocess(config,
+               in_fn=home_fn('tap-win32/i386/OemWin2k.inf.in'),
+               out_fn=home_fn('tap-win32/i386/OemWin2k.inf'),
+               quote_begin='@@',
+               quote_end='@@',
+               if_prefix='!',
+               head_comment='; %s\n\n' % autogen)
+
+    try:
+        os.mkdir(home_fn('tap-win32/amd64'))
+    except:
+        pass
+    preprocess(dict_def(config, [('AMD64', '1')]),
+               in_fn=home_fn('tap-win32/i386/OemWin2k.inf.in'),
+               out_fn=home_fn('tap-win32/amd64/OemWin2k.inf'),
+               quote_begin='@@',
+               quote_end='@@',
+               if_prefix='!',
+               head_comment='; %s\n\n' % autogen)
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    from wb import config
+    main(config)
diff -urN openvpn-2.1.1/win/config_ti.py openvpn-2.1.3/win/config_ti.py
--- openvpn-2.1.1/win/config_ti.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/config_ti.py	2010-04-28 18:16:46.000000000 +0200
@@ -0,0 +1,18 @@
+import os, shutil
+from wb import preprocess, home_fn, autogen
+
+def main(config):
+    src = os.path.join(home_fn(config['TISRC']), config['DDKVER_MAJOR'])
+    dest = home_fn('tapinstall')
+    shutil.rmtree(dest, ignore_errors=True)
+    shutil.copytree(src, dest)
+    preprocess(config,
+               in_fn=os.path.join(dest, 'sources.in'),
+               out_fn=os.path.join(dest, 'sources'),
+               if_prefix='!',
+               head_comment='# %s\n\n' % autogen)
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    from wb import config
+    main(config)
diff -urN openvpn-2.1.1/win/js.py openvpn-2.1.3/win/js.py
--- openvpn-2.1.1/win/js.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/js.py	2010-04-28 18:16:46.000000000 +0200
@@ -0,0 +1,10 @@
+import json
+
+# usage:
+#   print JSON().encode(kv)
+
+class JSON(json.JSONEncoder):
+    def __init__(self, **kwargs):
+        args = dict(sort_keys=True, indent=2)
+        args.update(kwargs)
+        json.JSONEncoder.__init__(self, **args)
diff -urN openvpn-2.1.1/win/make_dist.py openvpn-2.1.3/win/make_dist.py
--- openvpn-2.1.1/win/make_dist.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/make_dist.py	2010-07-21 21:08:41.000000000 +0200
@@ -0,0 +1,56 @@
+import os
+from wb import home_fn, rm_rf, mkdir, cp_a, cp
+
+def main(config, tap=True):
+    dist = config['DIST']
+    assert dist
+    dist = home_fn(dist)
+    bin = os.path.join(dist, 'bin')
+    i386 = os.path.join(dist, 'i386')
+    amd64 = os.path.join(dist, 'amd64')
+
+    # build dist and subdirectories
+    rm_rf(dist)
+    mkdir(dist)
+    mkdir(bin)
+    if tap:
+        mkdir(i386)
+        mkdir(amd64)
+
+    # copy openvpn.exe and manifest
+    cp(home_fn('openvpn.exe'), bin)
+    cp(home_fn('openvpn.exe.manifest'), bin)
+
+    # copy DLL dependencies
+    cp(home_fn(config['LZO_DIR']+'/bin/lzo2.dll'), bin)
+    cp(home_fn(config['OPENSSL_DIR']+'/bin/libeay32.dll'), bin)
+    cp(home_fn(config['OPENSSL_DIR']+'/bin/ssleay32.dll'), bin)
+
+    # copy MSVC CRT
+    cp_a(home_fn(config['MSVC_CRT']), bin)
+
+    if tap:
+        # copy TAP drivers
+        for dir_name, dest in (('amd64', amd64), ('i386', i386)):
+            dir = home_fn(os.path.join('tap-win32', dir_name))
+            for dirpath, dirnames, filenames in os.walk(dir):
+                for f in filenames:
+                    root, ext = os.path.splitext(f)
+                    if ext in ('.inf', '.cat', '.sys'):
+                        cp(os.path.join(dir, f), dest)
+                break
+
+        # copy tapinstall
+        dest = {'amd64' : amd64, 'i386' : i386}
+        for dirpath, dirnames, filenames in os.walk(home_fn('tapinstall')):
+            for f in filenames:
+                if f == 'tapinstall.exe':
+                    dir_name = os.path.basename(dirpath)
+                    src = os.path.join(dirpath, f)
+                    if dir_name in dest:
+                        cp(src, dest[dir_name])
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    from wb import config
+    main(config)
diff -urN openvpn-2.1.1/win/msvc.mak.in openvpn-2.1.3/win/msvc.mak.in
--- openvpn-2.1.1/win/msvc.mak.in	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/msvc.mak.in	2010-07-10 05:46:50.000000000 +0200
@@ -0,0 +1,57 @@
+# This makefile builds the user-mode component
+# of OpenVPN for Windows in the Visual Studio 2008 environment.
+
+# To build:
+#    python win\config.py
+#    nmake /f msvc.mak
+
+# Each of the OPENSSL and LZO dirs should have 'lib' and 'include'
+# directories under them.
+
+OPENSSL = @OPENSSL_DIR@
+OPENSSL_DYNAMIC = libeay32.lib ssleay32.lib
+
+LZO = @LZO_DIR@
+LZO_DYNAMIC = lzo2.lib
+
+INCLUDE_DIRS = -I$(OPENSSL)/include -I$(LZO)/include
+
+LIBS = $(OPENSSL_DYNAMIC) $(LZO_DYNAMIC) ws2_32.lib crypt32.lib iphlpapi.lib winmm.lib user32.lib gdi32.lib advapi32.lib wininet.lib
+
+LIB_DIRS = -LIBPATH:$(OPENSSL)\lib -LIBPATH:$(LZO)\lib
+
+EXE = openvpn.exe
+
+CPP=cl.exe
+CPP_ARG_COMMON=/nologo /W3 -DWIN32 -DWIN32_LEAN_AND_MEAN -D_CONSOLE -D_MBCS -D_CRT_SECURE_NO_DEPRECATE $(INCLUDE_DIRS) /FD /c
+
+LINK32=link.exe
+
+!ifdef PRODUCT_OPENVPN_DEBUG
+# debug:
+CPP_PROJ=$(CPP_ARG_COMMON) /MD /Z7
+LINK32_FLAGS=/nologo /subsystem:console /incremental:no /opt:ref /opt:icf /debug /out:"$(EXE)"
+# old debug:
+#CPP_PROJ=$(CPP_ARG_COMMON) /MDd /Zi /Od -D_DEBUG
+#LINK32_FLAGS=/nologo /subsystem:console /incremental:no /debug /out:"$(EXE)"
+!else
+# release:
+CPP_PROJ=$(CPP_ARG_COMMON) /O2 /MD -DNDEBUG
+LINK32_FLAGS=/nologo /subsystem:console /incremental:no /out:"$(EXE)"
+!endif
+
+# HEADERS and OBJS definitions, automatically generated
+@HEADERS_OBJS@
+
+openvpn : $(OBJS)
+	$(LINK32) @<<
+	$(LINK32_FLAGS) $(LIB_DIRS) $(LIBS) $(OBJS)
+<<
+
+clean :
+	del /Q $(OBJS) $(EXE) *.idb *.pdb
+
+.c.obj::
+   $(CPP) @<<
+   $(CPP_PROJ) $<
+<<
diff -urN openvpn-2.1.1/win/settings.in openvpn-2.1.3/win/settings.in
--- openvpn-2.1.1/win/settings.in	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/settings.in	2010-08-27 18:08:58.000000000 +0200
@@ -0,0 +1,68 @@
+# Version numbers, settings, and dependencies
+# for Windows OpenVPN installer.
+
+# Branding
+!define PRODUCT_NAME      "OpenVPN"
+!define PRODUCT_UNIX_NAME "openvpn"
+!define PRODUCT_FILE_EXT  "ovpn"
+
+# Allow --askpass and --auth-user-pass passwords to be read from a file
+;!define ENABLE_PASSWORD_SAVE
+
+# Include the OpenVPN GUI exe in the installer.
+# May be undefined.
+!define OPENVPN_GUI_DIR "../openvpn-gui"
+!define OPENVPN_GUI     "openvpn-gui-1.0.3.exe"
+
+# Prebuilt libraries.  DMALLOC is optional.
+!define OPENSSL_DIR	  "../openssl"
+!define LZO_DIR		  "../lzo"
+
+# write output files here
+!define DIST   "dist"
+
+# tapinstall.exe source code.
+# Not needed if DRVBINSRC is defined
+# (or if using pre-built mode).
+!define TISRC	"../tapinstall"
+
+# TAP Adapter parameters.  Note that PRODUCT_TAP_ID is
+# defined in version.m4.
+!define PRODUCT_TAP_DEVICE_DESCRIPTION  "TAP-Win32 Adapter V9"
+!define PRODUCT_TAP_PROVIDER            "TAP-Win32 Provider V9"
+!define PRODUCT_TAP_MAJOR_VER           9
+!define PRODUCT_TAP_MINOR_VER           7
+!define PRODUCT_TAP_RELDATE             "04/19/2010"
+
+# TAP adapter icon -- visible=0x81 or hidden=0x89
+!define PRODUCT_TAP_CHARACTERISTICS     0x81
+
+# Build debugging version of TAP driver
+;!define PRODUCT_TAP_DEBUG
+
+# Build debugging version of openvpn.exe
+;!define PRODUCT_OPENVPN_DEBUG
+
+# DDK path -- currently Windows 7 WDK
+!define DDK_PATH "c:/winddk/7600.16385.1"
+;!define DDK_PATH "c:/winddk/6001.18002"
+
+# output path for tap_span.py
+!define TAP_DIST "tap_dist"
+
+# Visual studio path
+!define MSVC "C:/Program Files/Microsoft Visual Studio 9.0"
+
+# Visual studio C run-time library path
+!define MSVC_CRT "../Microsoft.VC90.CRT"
+
+# Code Signing.
+# If undefined, don't sign any files.
+!define SIGNTOOL        "../signtool"
+!define PRODUCT_SIGN_CN "openvpn"
+
+; DEBUGGING -- set to something like "-DBG2"
+!define OUTFILE_LABEL ""
+
+; DEBUGGING -- set to something like "DEBUG2"
+!define TITLE_LABEL ""
diff -urN openvpn-2.1.1/win/show.py openvpn-2.1.3/win/show.py
--- openvpn-2.1.1/win/show.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/show.py	2010-04-28 18:16:46.000000000 +0200
@@ -0,0 +1,10 @@
+from wb import get_config
+from js import JSON
+
+def main():
+    kv = get_config()
+    print JSON().encode(kv)
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    main()
diff -urN openvpn-2.1.1/win/sign.py openvpn-2.1.3/win/sign.py
--- openvpn-2.1.1/win/sign.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/sign.py	2010-04-28 18:16:46.000000000 +0200
@@ -0,0 +1,19 @@
+import sys
+from wb import config, choose_arch, home_fn
+
+if 'SIGNTOOL' in config:
+    sys.path.append(home_fn(config['SIGNTOOL']))
+
+def main(conf, arch):
+    from signtool import SignTool
+    st = SignTool(conf)
+    for x64 in choose_arch(arch):
+        st.sign_verify(x64=x64)
+
+# if we are run directly, and not loaded as a module
+if __name__ == "__main__":
+    if len(sys.argv) >= 2:
+        main(config, sys.argv[1])
+    else:
+        print "usage: sign <x64|x86|all>"
+        sys.exit(2)
diff -urN openvpn-2.1.1/win/tap_span.py openvpn-2.1.3/win/tap_span.py
--- openvpn-2.1.1/win/tap_span.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/tap_span.py	2010-08-27 18:08:58.000000000 +0200
@@ -0,0 +1,129 @@
+import sys, os, shutil
+from wb import config, home_fn, mod_fn, preprocess, autogen, dict_def, build_autodefs, rm_rf, mkdir_silent, cp
+if 'SIGNTOOL' in config:
+    sys.path.append(home_fn(config['SIGNTOOL']))
+from signtool import SignTool
+from build_ddk import build_tap
+
+ti_dir = "c:/src/tapinstall"
+hi = ("c:/winddk/7600.16385.1", 7600, 7600, ("i386", "amd64"))
+low = ("c:/winddk/6001.18002", 6001, 5600, ("win2k",))
+dest_top = home_fn('tap_build')
+dist = home_fn(config['TAP_DIST'])
+
+def copy_tap(src, dest, x64):
+    dir = os.path.join(src, { False : 'i386', True: 'amd64' }[x64])
+    mkdir_silent(dest)
+    for dirpath, dirnames, filenames in os.walk(dir):
+        for f in filenames:
+            root, ext = os.path.splitext(f)
+            if ext in ('.inf', '.cat', '.sys'):
+                cp(os.path.join(dir, f), dest)
+        break
+
+def copy_tapinstall(src, dest, x64):
+    base = { False : 'i386', True: 'amd64' }[x64]
+    mkdir_silent(dest)
+    for dirpath, dirnames, filenames in os.walk(home_fn(src)):
+        for f in filenames:
+            if f == 'tapinstall.exe':
+                dir_name = os.path.basename(dirpath)
+                s = os.path.join(dirpath, f)
+                if dir_name == base:
+                    cp(s, dest)
+
+def main():
+    rm_rf(dest_top)
+    os.mkdir(dest_top)
+
+    rm_rf(dist)
+    os.mkdir(dist)
+
+    for ver in hi, low:
+        top = os.path.join(dest_top, str(ver[1]))
+        os.mkdir(top)
+        tap_dest = os.path.join(top, "tap-win32")
+        ti_dest = os.path.join(top, "tapinstall")
+        ti_src = os.path.join(ti_dir, str(ver[2]))
+        shutil.copytree(home_fn("tap-win32"), tap_dest)
+        shutil.copytree(ti_src, ti_dest)
+
+        i386 = os.path.join(tap_dest, "i386")
+        amd64 = os.path.join(tap_dest, "amd64")
+
+        build_amd64 = (len(ver[3]) >= 2)
+
+        build_autodefs(config, mod_fn('autodefs.h.in'), os.path.join(top, 'autodefs.h'))
+
+        st = SignTool(config, tap_dest)
+
+        preprocess(config,
+                   in_fn=os.path.join(tap_dest, 'SOURCES.in'),
+                   out_fn=os.path.join(tap_dest, 'SOURCES'),
+                   quote_begin='@@',
+                   quote_end='@@',
+                   head_comment='# %s\n\n' % autogen)
+
+        preprocess(config,
+                   in_fn=os.path.join(i386, 'OemWin2k.inf.in'),
+                   out_fn=os.path.join(i386, 'OemWin2k.inf'),
+                   quote_begin='@@',
+                   quote_end='@@',
+                   if_prefix='!',
+                   head_comment='; %s\n\n' % autogen)
+
+        preprocess(config,
+                   in_fn=os.path.join(ti_dest, 'sources.in'),
+                   out_fn=os.path.join(ti_dest, 'sources'),
+                   if_prefix='!',
+                   head_comment='# %s\n\n' % autogen)
+
+        build_tap(ddk_path=ver[0],
+                  ddk_major=ver[1],
+                  debug=False,
+                  dir=tap_dest,
+                  x64=False)
+
+        st.sign_verify(x64=False)
+
+        build_tap(ddk_path=ver[0],
+                  ddk_major=ver[1],
+                  debug=False,
+                  dir=ti_dest,
+                  x64=False)
+
+        tap_dist = os.path.join(dist, ver[3][0])
+
+        copy_tap(tap_dest, tap_dist, x64=False)
+        copy_tapinstall(ti_dest, tap_dist, x64=False)
+
+        if build_amd64:
+            os.mkdir(amd64)
+            preprocess(dict_def(config, [('AMD64', '1')]),
+                       in_fn=os.path.join(i386, 'OemWin2k.inf.in'),
+                       out_fn=os.path.join(amd64, 'OemWin2k.inf'),
+                       quote_begin='@@',
+                       quote_end='@@',
+                       if_prefix='!',
+                       head_comment='; %s\n\n' % autogen)
+
+            build_tap(ddk_path=ver[0],
+                      ddk_major=ver[1],
+                      debug=False,
+                      dir=tap_dest,
+                      x64=True)
+
+            build_tap(ddk_path=ver[0],
+                      ddk_major=ver[1],
+                      debug=False,
+                      dir=ti_dest,
+                      x64=True)
+
+            st.sign_verify(x64=True)
+
+            tap_dist_x64 = os.path.join(dist, ver[3][1])
+
+            copy_tap(tap_dest, tap_dist_x64, x64=True)
+            copy_tapinstall(ti_dest, tap_dist_x64, x64=True)
+
+main()
diff -urN openvpn-2.1.1/win/wb.py openvpn-2.1.3/win/wb.py
--- openvpn-2.1.1/win/wb.py	1970-01-01 01:00:00.000000000 +0100
+++ openvpn-2.1.3/win/wb.py	2010-08-27 18:08:58.000000000 +0200
@@ -0,0 +1,215 @@
+# Python module containing general build functions
+# for OpenVPN on Windows
+
+import os, re, shutil, stat
+
+autogen = "Automatically generated by OpenVPN Windows build system"
+
+def get_config():
+    kv = {}
+    parse_version_m4(kv, home_fn('version.m4'))
+    parse_settings_in(kv, mod_fn('settings.in'))
+
+    # config fixups
+    kv['DDKVER'] = os.path.basename(kv['DDK_PATH'])
+    kv['DDKVER_MAJOR'] = re.match(r'^(\d+)\.', kv['DDKVER']).groups()[0]
+
+    if 'VERSION_SUFFIX' in kv:
+        kv['PRODUCT_VERSION'] += kv['VERSION_SUFFIX']
+
+    return kv
+
+def mod_fn(fn, src=__file__, real=True):
+    p = os.path.join(os.path.dirname(src), os.path.normpath(fn))
+    if real:
+        p = os.path.realpath(p)
+    return p
+
+def home_fn(fn, real=True):
+    return mod_fn(os.path.join('..', fn), real=real)
+
+def cd_home():
+    os.chdir(os.path.join(os.path.dirname(__file__), '..'))
+
+def system(cmd):
+    print "RUN:", cmd
+    os.system(cmd)
+
+def parse_version_m4(kv, version_m4):
+    r = re.compile(r'^define\((\w+),\[(.*)\]\)$')
+    f = open(version_m4)
+    for line in f:
+        line = line.rstrip()
+        m = re.match(r, line)
+        if m:
+            g = m.groups()
+            kv[g[0]] = g[1]
+    f.close()
+
+def parse_settings_in(kv, settings_in):
+    r = re.compile(r'^!define\s+(\w+)(?:\s+"?(.*?)"?)?$')
+    f = open(settings_in)
+    for line in f:
+        line = line.rstrip()
+        m = re.match(r, line)
+        if m:
+            g = m.groups()
+            kv[g[0]] = g[1] or ''
+    f.close()
+
+def dict_def(dict, newdefs):
+    ret = dict.copy()
+    ret.update(newdefs)
+    return ret
+
+def build_autodefs(kv, autodefs_in, autodefs_out):
+    preprocess(kv,
+               in_fn=autodefs_in,
+               out_fn=autodefs_out,
+               quote_begin='@',
+               quote_end='@',
+               head_comment='/* %s */\n\n' % autogen)
+
+def preprocess(kv, in_fn, out_fn, quote_begin=None, quote_end=None, if_prefix=None, head_comment=None):
+    def repfn(m):
+        var, = m.groups()
+        return kv.get(var, '')
+
+    re_macro = re_ifdef = None
+
+    if quote_begin and quote_end:
+        re_macro = re.compile(r'%s(\w+)%s' % (re.escape(quote_begin), re.escape(quote_end)))
+
+    if if_prefix:
+        re_ifdef = re.compile(r'^\s*%sifdef\s+(\w+)\b' % (re.escape(if_prefix),))
+        re_else = re.compile(r'^\s*%selse\b' % (re.escape(if_prefix),))
+        re_endif = re.compile(r'^\s*%sendif\b' % (re.escape(if_prefix),))
+
+    if_stack = []
+    fin = open(in_fn)
+    fout = open(out_fn, 'w')
+    if head_comment:
+        fout.write(head_comment)
+    for line in fin:
+        if re_ifdef:
+            m = re.match(re_ifdef, line)
+            if m:
+                var, = m.groups()
+                if_stack.append(int(var in kv))
+                continue
+            elif re.match(re_else, line):
+                if_stack[-1] ^= 1
+                continue
+            elif re.match(re_endif, line):
+                if_stack.pop()
+                continue
+        if not if_stack or min(if_stack):
+            if re_macro:
+                line = re.sub(re_macro, repfn, line)
+            fout.write(line)
+    assert not if_stack
+    fin.close()
+    fout.close()
+
+def print_key_values(kv):
+    for k, v in sorted(kv.items()):
+        print "%s%s%s" % (k, ' '*(32-len(k)), repr(v))
+
+def get_sources(makefile_am):
+    c = set()
+    h = set()
+    f = open(makefile_am)
+    state = False
+    for line in f:
+        line = line.rstrip()
+        if line == 'openvpn_SOURCES = \\':
+            state = True
+        elif not line:
+            state = False
+        elif state:
+            for sf in line.split():
+                if sf.endswith('.c'):
+                    c.add(sf[:-2])
+                elif sf.endswith('.h'):
+                    h.add(sf[:-2])
+                elif sf == '\\':
+                    pass
+                else:
+                    print >>sys.stderr, "Unrecognized filename:", sf
+    f.close()
+    return [ sorted(list(s)) for s in (c, h) ]
+
+def output_mak_list(title, srclist, ext):
+    ret = "%s =" % (title,)
+    for x in srclist:
+        ret += " \\\n\t%s.%s" % (x, ext)
+    ret += '\n\n'
+    return ret
+
+def make_headers_objs(makefile_am):
+    c, h = get_sources(makefile_am)
+    ret = output_mak_list('HEADERS', h, 'h')
+    ret += output_mak_list('OBJS', c, 'obj')
+    return ret
+
+def choose_arch(arch_name):
+    if arch_name == 'x64':
+        return (True,)
+    elif arch_name == 'x86':
+        return (False,)
+    elif arch_name == 'all':
+        return (True, False)
+    else:
+        raise ValueError("architecture ('%s') must be x86, x64, or all" % (arch_name,))
+
+def rm_rf(dir):
+    print "REMOVE", dir
+    shutil.rmtree(dir, ignore_errors=True)
+
+def mkdir(dir):
+    print "MKDIR", dir
+    os.mkdir(dir)
+
+def cp_a(src, dest, dest_is_dir=True):
+    if dest_is_dir:
+        dest = os.path.join(dest, os.path.basename(src))
+    print "COPY_DIR %s %s" % (src, dest)
+    shutil.copytree(src, dest)
+
+def cp(src, dest, dest_is_dir=True):
+    if dest_is_dir:
+        dest = os.path.join(dest, os.path.basename(src))
+    print "COPY %s %s" % (src, dest)
+    shutil.copyfile(src, dest)
+
+def rm_rf(path):
+    try:
+        shutil.rmtree(path, onerror=onerror)
+    except:
+        pass
+
+def onerror(func, path, exc_info):
+    """
+    Error handler for ``shutil.rmtree``.
+
+    If the error is due to an access error (read only file)
+    it attempts to add write permission and then retries.
+
+    If the error is for another reason it re-raises the error.
+
+    Usage : ``shutil.rmtree(path, onerror=onerror)``
+    """
+    if not os.access(path, os.W_OK):
+        # Is the error an access error ?
+        os.chmod(path, stat.S_IWUSR)
+        func(path)
+    else:
+        raise
+
+def mkdir_silent(dir):
+    try:
+        os.mkdir(dir)
+    except:
+        pass
+
+config = get_config()
diff -urN openvpn-2.1.1/win32.c openvpn-2.1.3/win32.c
--- openvpn-2.1.1/win32.c	2009-11-20 14:09:14.000000000 +0100
+++ openvpn-2.1.3/win32.c	2010-07-21 21:08:41.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -971,10 +971,8 @@
 	      /* fill in STARTUPINFO struct */
 	      GetStartupInfo(&start_info);
 	      start_info.cb = sizeof(start_info);
-	      start_info.dwFlags = STARTF_USESTDHANDLES|STARTF_USESHOWWINDOW;
+	      start_info.dwFlags = STARTF_USESHOWWINDOW;
 	      start_info.wShowWindow = SW_HIDE;
-	      start_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
-	      start_info.hStdOutput = start_info.hStdError = GetStdHandle(STD_OUTPUT_HANDLE);
 
 	      if (CreateProcess (cmd, cl, NULL, NULL, FALSE, 0, env, NULL, &start_info, &proc_info))
 		{
@@ -1042,10 +1040,8 @@
   /* fill in STARTUPINFO struct */
   GetStartupInfo(&start_info);
   start_info.cb = sizeof(start_info);
-  start_info.dwFlags = STARTF_USESTDHANDLES|STARTF_USESHOWWINDOW;
+  start_info.dwFlags = STARTF_USESHOWWINDOW;
   start_info.wShowWindow = SW_HIDE;
-  start_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
-  start_info.hStdOutput = start_info.hStdError = GetStdHandle(STD_OUTPUT_HANDLE);
 
   if (CreateProcess (self_exe, cl, NULL, NULL, FALSE, 0, NULL, NULL, &start_info, &proc_info))
     {
diff -urN openvpn-2.1.1/win32.h openvpn-2.1.3/win32.h
--- openvpn-2.1.1/win32.h	2009-11-20 14:09:14.000000000 +0100
+++ openvpn-2.1.3/win32.h	2010-07-27 23:44:34.000000000 +0200
@@ -5,7 +5,7 @@
  *             packet encryption, packet authentication, and
  *             packet compression.
  *
- *  Copyright (C) 2002-2009 OpenVPN Technologies, Inc. <sales@openvpn.net>
+ *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2
@@ -33,6 +33,8 @@
 #define DEFAULT_WIN_SYS_PATH  "C:\\WINDOWS" /* --win-sys default value */
 #define NETSH_PATH_SUFFIX     "\\system32\\netsh.exe"
 #define WIN_ROUTE_PATH_SUFFIX "\\system32\\route.exe"
+#define WIN_IPCONFIG_PATH_SUFFIX "\\system32\\ipconfig.exe"
+#define WIN_NET_PATH_SUFFIX "\\system32\\net.exe"
 
 /*
  * Win32-specific OpenVPN code, targetted at the mingw
